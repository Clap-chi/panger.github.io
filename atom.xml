<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zy</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-29T06:30:02.662Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective_Cpp笔记</title>
    <link href="http://example.com/blogs/2b7e9eb2.html"/>
    <id>http://example.com/blogs/2b7e9eb2.html</id>
    <published>2023-10-27T05:45:59.000Z</published>
    <updated>2023-10-29T06:30:02.662Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231027152734799.png" alt="image-20231027152734799"></p><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>构造函数：ctor</p><p>析构函数：dtor</p><p>left-hand side(左手端)：lhs</p><p>right-hand side(右手端)：rhs</p><p>对于成员函数，左侧实参由this指针表现出来，所以有时我单独使用参数名称rhs。</p><p>“指向一个T型对象”的指针命名为pt，意思是“pointer to T”。</p><p>对于references使用类似习惯：rw可能是个reference to Widget，ra则是个reference to Airplane。</p><h2 id="TR1和Boost"><a href="#TR1和Boost" class="headerlink" title="TR1和Boost"></a>TR1和Boost</h2><ul><li>Tr1（“Technical Report 1”）是一份规范，描述加入C++标准程序库的诸多新机能。这些技能以新的class templates和function templates形式体现，针对的题目有hash tables，reference-counting smart pointers，regular expressions，以及更多。所有TR1组件都被置于命名空间tr1内，后者嵌套与命名空间std内。</li><li>Boost是个组织，亦是一个网站<a href="http://boost.org/">Boost</a>，提供可移植、同僚复审、源码开放的C++程序库。大多数TR1机能是以Boost的工作为基础。在编译器厂商于其C++程序库中含入TR1之前，对那些搜寻TR1实现品的开发人员而言，Boost网站可能是第一个逗留点。Boost提供比TR1更多的东西，所以无论如何值得了解它。</li><li></li></ul><h1 id="一、让自己习惯C"><a href="#一、让自己习惯C" class="headerlink" title="一、让自己习惯C++"></a>一、让自己习惯C++</h1><h2 id="1-1-视C-为一个语言联邦"><a href="#1-1-视C-为一个语言联邦" class="headerlink" title="1.1 视C++为一个语言联邦"></a>1.1 视C++为一个语言联邦</h2><p>将C++视为一个由语言组成的联邦而非单一语言。C++主要的4个次语言：</p><ul><li>C。C++仍是以C为基础。许多时候C++对问题的解法其实不过就是较高级的C解法，但当你以C++内的C成分工作时，高效编程守则映照出C语言的局限：没有模板（templates），没有异常（exceptions），没有重载（overloading）。</li><li>Object-Oriented C++。这部分也就是C with Classes所诉求的：classes（包括构造函数和析构函数），封装、继承、多态、virtual函数（动态绑定）等等。</li><li>Template C++。实际上由于templates威力强大，它们带来崭新的编程泛型，也就是所谓的template metaprogramming（TMP，模板元编程）。</li><li>STL。STL是个template程序库，看名称也知道，但它是非常特殊的一个。STL有自己特殊的办事方式，当你伙同STL一起工作，你必须遵守它的规约。</li></ul><p>C++并不是一个带有一组守则的一体语言，它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。</p><h2 id="1-2尽量以const，enum，inline替换-define"><a href="#1-2尽量以const，enum，inline替换-define" class="headerlink" title="1.2尽量以const，enum，inline替换#define"></a>1.2尽量以const，enum，inline替换#define</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>​记号名称ASPECT_RATIO也许从未被编译器看见；也许在编译器开始处理源码之前它就被预处理器移走了。于是记号名称ASPECT_RATIO有可能没进入记号表（symbol table）。</p><p>​以常量替换#define，有两种特殊情况：①定义常量指针。由于常量定义式通常被放在头文件内（以便被不同的源码含入），因此有必要将指针（而不是指针所指之物）声明为const。②class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员。</p><p>​无法利用#define创建一个class专属常量，因为#define并不重视作用域（scope）。一旦宏被定义，它就在其后的编译过程中有效（除非在某处被#undef）。这意味着#define不仅不能够用来定义class专属常量，也不能够提供任何封装性。</p><p>​enum hack的行为某方面说比较像#define而不像const。取一个const的地址是合法的，但取一个enum的地址不合法，而取一个#define的地址通常也不合法。</p><p>Remember：</p><ul><li>对于单纯常量，最好以const对象或enum替换#define。</li><li>对于形似函数的宏，最好改用inline函数替换#define。</li></ul><h2 id="1-3尽可能使用const"><a href="#1-3尽可能使用const" class="headerlink" title="1.3尽可能使用const"></a>1.3尽可能使用const</h2><p>​const的一件奇妙事情是，它允许你指定一个语义约束（也就是指定一个“不该被改动”的对象），而编译器会强制实施这项约束。它允许你告诉编译器和其他程序员某值应该保持不变。只要这（某值保持不变）是事实，你就该确实说出来，因为说出来可以获得编译器的襄助，确保这条约束不被违反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeeting;<span class="comment">//non-const pointer,const data</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeeting;    <span class="comment">//const pointer,non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;<span class="comment">//const pointer,const data</span></span><br></pre></td></tr></table></figure><p>​以下两种写法意义相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget* pw)</span></span>;<span class="comment">//f1获得一个指针，指向一个常量的Widget对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget <span class="type">const</span> * pw)</span></span>; <span class="comment">//f2也是</span></span><br></pre></td></tr></table></figure><p>​在一个函数声明式内，const可以和函数返回值、各参数、函数自身（如果是成员函数）产生关联。令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。</p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>​1.它们使class接口比较容易被理解。得知哪个函数可以改动对象内容而哪个函数不行，很重要。2.使“操作const对象”成为可能。</p><p>​两个成员函数如果只是常量性不同，可以被重载。</p><p>​bitwise const阵营的人相信，成员函数只有在不更改对象之任何成员变量（static除外）时才可以说是const。也就是说它不更改对象内的任何一个bit。</p><p>​logical constness这一派拥护者主张，一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才得如此。</p><p>​利用C++的一个与const相关的摆动场：mutable（可变的）。mutable释放掉non-static成员变量的bitwise constness约束。</p><h3 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h3><p>​对于”bitwise-constness非我所欲”的问题，mutable是个解决办法，但它不能解决所有的const相关难题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span></span><br><span class="line"> &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> text[position];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)<span class="comment">//现在只调用 const op[]</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">     <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="comment">//将op[]返回值的const转除</span></span><br><span class="line">       <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)    <span class="comment">//为*this加上const</span></span><br><span class="line">          [position]    <span class="comment">//调用const op[]</span></span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​共有两次转型：第一次用来为*this添加const（这使接下来调用operator[]时得以调用const版本），第二次则是以const operator[]的返回值中移除const。</p><p>​添加const的那一次转型强迫进行了一次安全转型（将non-const对象转为const对象），所以我们使用static_cast。移除const的那个动作只可以藉由const_cast完成，没有其他选择。</p><p>Remember：</p><ul><li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li><li>编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。</li><li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li></ul><h2 id="1-4确定对象被使用前已先被初始化"><a href="#1-4确定对象被使用前已先被初始化" class="headerlink" title="1.4确定对象被使用前已先被初始化"></a>1.4确定对象被使用前已先被初始化</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231027152734799.png&quot; alt=&quot;image-20231027152734799&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    
    <category term="Effective_Cpp" scheme="http://example.com/tags/Effective-Cpp/"/>
    
  </entry>
  
</feed>
