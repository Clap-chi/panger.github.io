<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zy</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-31T15:53:27.931Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective_Cpp笔记</title>
    <link href="http://example.com/blogs/2b7e9eb2.html"/>
    <id>http://example.com/blogs/2b7e9eb2.html</id>
    <published>2023-10-27T05:45:59.000Z</published>
    <updated>2023-10-31T15:53:27.931Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231027152734799.png" alt="image-20231027152734799"></p><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>构造函数：ctor</p><p>析构函数：dtor</p><p>left-hand side(左手端)：lhs</p><p>right-hand side(右手端)：rhs</p><p>对于成员函数，左侧实参由this指针表现出来，所以有时我单独使用参数名称rhs。</p><p>“指向一个T型对象”的指针命名为pt，意思是“pointer to T”。</p><p>对于references使用类似习惯：rw可能是个reference to Widget，ra则是个reference to Airplane。</p><h2 id="TR1和Boost"><a href="#TR1和Boost" class="headerlink" title="TR1和Boost"></a>TR1和Boost</h2><ul><li>Tr1（“Technical Report 1”）是一份规范，描述加入C++标准程序库的诸多新机能。这些技能以新的class templates和function templates形式体现，针对的题目有hash tables，reference-counting smart pointers，regular expressions，以及更多。所有TR1组件都被置于命名空间tr1内，后者嵌套与命名空间std内。</li><li>Boost是个组织，亦是一个网站<a href="http://boost.org/">Boost</a>，提供可移植、同僚复审、源码开放的C++程序库。大多数TR1机能是以Boost的工作为基础。在编译器厂商于其C++程序库中含入TR1之前，对那些搜寻TR1实现品的开发人员而言，Boost网站可能是第一个逗留点。Boost提供比TR1更多的东西，所以无论如何值得了解它。</li></ul><h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款1：-视C-为一个语言联邦"><a href="#条款1：-视C-为一个语言联邦" class="headerlink" title="条款1： 视C++为一个语言联邦"></a>条款1： 视C++为一个语言联邦</h2><p>将C++视为一个由语言组成的联邦而非单一语言。C++主要的4个次语言：</p><ul><li>C。C++仍是以C为基础。许多时候C++对问题的解法其实不过就是较高级的C解法，但当你以C++内的C成分工作时，高效编程守则映照出C语言的局限：没有模板（templates），没有异常（exceptions），没有重载（overloading）。</li><li>Object-Oriented C++。这部分也就是C with Classes所诉求的：classes（包括构造函数和析构函数），封装、继承、多态、virtual函数（动态绑定）等等。</li><li>Template C++。实际上由于templates威力强大，它们带来崭新的编程泛型，也就是所谓的template metaprogramming（TMP，模板元编程）。</li><li>STL。STL是个template程序库，看名称也知道，但它是非常特殊的一个。STL有自己特殊的办事方式，当你伙同STL一起工作，你必须遵守它的规约。</li></ul><p>C++并不是一个带有一组守则的一体语言，它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。</p><h2 id="条款2：尽量以const，enum，inline替换-define"><a href="#条款2：尽量以const，enum，inline替换-define" class="headerlink" title="条款2：尽量以const，enum，inline替换#define"></a>条款2：尽量以const，enum，inline替换#define</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>​记号名称ASPECT_RATIO也许从未被编译器看见；也许在编译器开始处理源码之前它就被预处理器移走了。于是记号名称ASPECT_RATIO有可能没进入记号表（symbol table）。</p><p>​以常量替换#define，有两种特殊情况：①定义常量指针。由于常量定义式通常被放在头文件内（以便被不同的源码含入），因此有必要将指针（而不是指针所指之物）声明为const。②class专属常量。为了将常量的作用域（scope）限制于class内，你必须让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员。</p><p>​无法利用#define创建一个class专属常量，因为#define并不重视作用域（scope）。一旦宏被定义，它就在其后的编译过程中有效（除非在某处被#undef）。这意味着#define不仅不能够用来定义class专属常量，也不能够提供任何封装性。</p><p>​enum hack的行为某方面说比较像#define而不像const。取一个const的地址是合法的，但取一个enum的地址不合法，而取一个#define的地址通常也不合法。</p><p><strong>Remember</strong>：</p><ul><li>对于单纯常量，最好以const对象或enum替换#define。</li><li>对于形似函数的宏，最好改用inline函数替换#define。</li></ul><h2 id="条款3：尽可能使用const"><a href="#条款3：尽可能使用const" class="headerlink" title="条款3：尽可能使用const"></a>条款3：尽可能使用const</h2><p>​const的一件奇妙事情是，它允许你指定一个语义约束（也就是指定一个“不该被改动”的对象），而编译器会强制实施这项约束。它允许你告诉编译器和其他程序员某值应该保持不变。只要这（某值保持不变）是事实，你就该确实说出来，因为说出来可以获得编译器的襄助，确保这条约束不被违反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeeting;<span class="comment">//non-const pointer,const data</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeeting;    <span class="comment">//const pointer,non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;<span class="comment">//const pointer,const data</span></span><br></pre></td></tr></table></figure><p>​以下两种写法意义相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget* pw)</span></span>;<span class="comment">//f1获得一个指针，指向一个常量的Widget对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget <span class="type">const</span> * pw)</span></span>; <span class="comment">//f2也是</span></span><br></pre></td></tr></table></figure><p>​在一个函数声明式内，const可以和函数返回值、各参数、函数自身（如果是成员函数）产生关联。令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。</p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>​1.它们使class接口比较容易被理解。得知哪个函数可以改动对象内容而哪个函数不行，很重要。2.使“操作const对象”成为可能。</p><p>​两个成员函数如果只是常量性不同，可以被重载。</p><p>​bitwise const阵营的人相信，成员函数只有在不更改对象之任何成员变量（static除外）时才可以说是const。也就是说它不更改对象内的任何一个bit。</p><p>​logical constness这一派拥护者主张，一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才得如此。</p><p>​利用C++的一个与const相关的摆动场：mutable（可变的）。mutable释放掉non-static成员变量的bitwise constness约束。</p><h3 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h3><p>​对于”bitwise-constness非我所欲”的问题，mutable是个解决办法，但它不能解决所有的const相关难题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span></span><br><span class="line"> &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> text[position];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position)<span class="comment">//现在只调用 const op[]</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">     <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="comment">//将op[]返回值的const转除</span></span><br><span class="line">       <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)    <span class="comment">//为*this加上const</span></span><br><span class="line">          [position]    <span class="comment">//调用const op[]</span></span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​共有两次转型：第一次用来为*this添加const（这使接下来调用operator[]时得以调用const版本），第二次则是以const operator[]的返回值中移除const。</p><p>​添加const的那一次转型强迫进行了一次安全转型（将non-const对象转为const对象），所以我们使用static_cast。移除const的那个动作只可以藉由const_cast完成，没有其他选择。</p><p><strong>Remember</strong>：</p><ul><li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li><li>编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。</li><li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li></ul><h2 id="条款4：确定对象被使用前已先被初始化"><a href="#条款4：确定对象被使用前已先被初始化" class="headerlink" title="条款4：确定对象被使用前已先被初始化"></a>条款4：确定对象被使用前已先被初始化</h2><p>​永远在使用对象之前先将它初始化。无任何成员的内置类型，手工完成此事。内置类型以外，确保每一个构造函数都将对象的每一个成员初始化。别混淆<strong>赋值（assignment）</strong>和<strong>初始化（initialization）</strong>。</p><p>​C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。</p><p>​C++有着十分固定的“成员初始化次序”。次序总是相同：base classes更早于其derived classes被初始化，而class的成员变量总是以其声明次序被初始化。</p><p>​ <strong>static 对象</strong>，其寿命从被构造出来直到程序结束为止，因此 stack 和 heap-based 对象都被排除。这种对象包括global 对象、定义于 namespace 作用域内的对象、在 classes 内、在函数内，以及在file作用域内被声明为static的对象。 函数内的 static 对象称为local static 对象（因为它们对函数而言是local），其他static 对象称为 non-local static 对象。程序结束时 static 对象会被自动销毁，也就是它们的析构函数会在main()结束时被自动调用。</p><p>​<strong>编译单元</strong>（translation unit）是指产出单一目标文件（single object file）的那些源码。基本上它是单一源码文件加上其所含入的头文件（#include files）。</p><p>​<strong>Real problem</strong>：如果某编译单元内的某个 non-local static 对象的初始化动作使用了另一编译单元内的某个 non-local static 对象，它所用到的这个对象可能尚未被初始化，因为<strong>C++对“定义于不同编译单元内的non-local static 对象”的初始化次序并无明确定义</strong>。</p><p>​<strong>Reason</strong>：决定它们的初始化次序相当困难，非常困难，根本无解。在其最常见形式，也就是<strong>多个编译单元内的non-local static对象经由“模板隐式具现化，implicit template instantiations”形成</strong>，不但不可能决定正确的初始化次序，甚至往往不值得寻找“可决定正确次序”的特殊情况。</p><p>​<strong>Eliminate the problem</strong>：将每个non-local static对象搬到自己的专属函数内（该对象在此函数内被声明为static）。这些函数返回一个reference指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，non-local static对象被local static对象替换了。这是<strong>Singleton</strong>模式的一个常见实现手法。</p><p>​任何一种non-const static对象，不论它是local或non-local，在多线程环境下“等待某事发生”都会有麻烦。处理这个麻烦的一种做法是：在程序的单线程启动阶段（single-threaded startup portion）手工调用所有reference-returning函数，这可消除与初始化有关的”竞速形势（race conditions）“。</p><p><strong>Remember</strong>：</p><ul><li>为内置对象进行手工初始化，因为C++不保证初始化它们。</li><li>构造函数最好使用成员初值列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序 应该和它们在class中的声明次序相同。</li><li>为免除”跨编译单元之初始化次序“问题，请以local static对象替换non-local static对象。</li></ul><h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造&#x2F;析构&#x2F;赋值运算"></a>构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款5：了解C-默默编写并调用哪些函数"><a href="#条款5：了解C-默默编写并调用哪些函数" class="headerlink" title="条款5：了解C++默默编写并调用哪些函数"></a>条款5：了解C++默默编写并调用哪些函数</h2><p>​什么时候empty class（空类）不再是个empty class呢？<strong>当C++处理过它之后</strong>。</p><p>​<strong>notice</strong>：编译器产出的析构函数是个non-virtual，除非这个class的base class自身声明有virtual析构函数（这种情况下这个函数的虚属性virtualness主要来自base class）。</p><p><strong>Remember</strong>：</p><ul><li>编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。</li></ul><h2 id="条款6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款6：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款6：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>​要阻止copying，可以将copy构造函数或copy assignment操作符声明为private。藉由明确声明一个成员函数，你阻止了编译器暗自创建其专属版本；而令这些函数为private，使你得以成功阻止人们调用它。</p><p>​一般而言这个做法并不绝对安全，因为member函数和friend函数还是可以调用你的private函数。<strong>将成员函数声明为private而且故意不实现它们</strong>，将阻止copying行为，如果某些人不慎调用任何一个，会获得一个<strong>连接错误（linkage error）</strong>。</p><p><strong>Remember</strong>：</p><ul><li>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予实现。</li></ul><h2 id="条款7：为多态基类声明virtual析构函数"><a href="#条款7：为多态基类声明virtual析构函数" class="headerlink" title="条款7：为多态基类声明virtual析构函数"></a>条款7：为多态基类声明virtual析构函数</h2><p>​如果class不含virtual函数，通常表示它并不意图被用来做一个base class。</p><p>​欲实现出 virtual 函数，对象必须携带某些信息，主要用来在运行期决定哪一个 virtual 函数该被调用。这份信息通常是由一个所谓vptr （virtual table pointer）指针指 出。vptr 指向一个函数指针构成的数组，称为vtbl（virtual table）；每一个带有 virtual 函数的 class 都有一个相应的vtbl。当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl——编译器在其中寻找适当的函数指针。</p><p>​只有当class内含至少一个virtual函数，才为它声明virtual析构函数。</p><p>​标准string不含任何virtual函数。不要企图继承一个标准容器或任何其他“带有non-virtual析构函数”的class。</p><p>​pure virtual函数导致abstract（抽象）classes——也就是不能被实体化（instantiated）的class。也就是说，你不能为那种类型创建对象。</p><p>​必须为pure virtual析构函数提供一份定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWOV</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AWOV</span>() = <span class="number">0</span>;<span class="comment">//声明pure virtual析构函数</span></span><br><span class="line">&#125;</span><br><span class="line">AWOV::~AWOV &#123; &#125;<span class="comment">//pure virtual析构函数的定义</span></span><br></pre></td></tr></table></figure><p>​析构函数的运作方式是，最深层派生（most derived）的那个class其析构函数最先被调用，然后是其每一个base class的析构函数被调用。</p><p>​“给base classes一个virtual析构函数”，这个规则只适用于polymorphic（带多态性质的）base classes身上。这种base classes的设计目的是为了用来“通过base class接口处理derived class对象”。</p><p><strong>Remember</strong>：</p><ul><li>polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。</li><li>Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性（polymorphically），就不该声明virtual析构函数。</li></ul><h2 id="条款8：别让异常逃离析构函数"><a href="#条款8：别让异常逃离析构函数" class="headerlink" title="条款8：别让异常逃离析构函数"></a>条款8：别让异常逃离析构函数</h2><p><strong>Remember</strong>：</p><ul><li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul><h2 id="条款9：绝不在构造和析构过程中调用virtual函数"><a href="#条款9：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款9：绝不在构造和析构过程中调用virtual函数"></a>条款9：绝不在构造和析构过程中调用virtual函数</h2><p>​base class构造期间virtual函数绝不会下降到derived classes阶层。取而代之的是，对象的作为就像隶属base类型一样。非正式的说法或许比较传神：在base class构造期间，virtual函数不是virtual函数。</p><p>​确定你的构造函数和析构函数都没有（在对象被创建和被销魂期间）调用virtual函数，而它们调用的所有函数也都服从同一约束。</p><p>​你无法使用virtual函数从base classes向下调用，在构造期间，你可以藉由“令derived classes将必要的构造信息向上传递至base class构造函数”替换之而加以弥补。</p><p>​比起在成员初值列（member initialization list）内给予base class所需数据，利用辅助函数创建一个值传给base class构造函数往往比较方便（也比较可读）。令此函数为static，也就不可能意外指向“初期未成熟之对象内尚未初始化的成员变量”。这很重要，正是因为“那些成员变量处于未定义状态”，所以“在base class构造和析构期间调用的virtual函数不可下降至derived classes”。</p><p><strong>Remember</strong>：</p><p>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）。</p><h2 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator&#x3D;返回一个reference to *this"></a>条款10：令operator&#x3D;返回一个reference to *this</h2><p>​为了实现“连锁赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参。</p><p>​这只是个协议，并无强制性。</p><p><strong>Remember</strong>：</p><p>​令赋值（assignment）操作符返回一个reference to *this。</p><h2 id="条款11：在operator-中处理”自我赋值”"><a href="#条款11：在operator-中处理”自我赋值”" class="headerlink" title="条款11：在operator&#x3D;中处理”自我赋值”"></a>条款11：在operator&#x3D;中处理”自我赋值”</h2><p>​并不明显的自我赋值，是“别名”（aliasing）带来的结果：所谓“别名”就是”有一个以上的方法指称（指涉）某对象“。</p><p>​在operator&#x3D;函数内手工排列语句（确保代码不但“异常安全”而且“自我赋值安全”）的一个替代方案是，使用所谓的 copy and swap 技术。</p><p><strong>Remember</strong>：</p><ul><li>确保当对象自我赋值时 operator&#x3D; 有良好行为。其中技术包括比较“来源对象” 和“目标对象”的地址、精心周到的语句顺序、以及 copy-and-swap。</li><li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li></ul><h2 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h2><p>​copying函数：copy构造函数和copy assignment操作符。</p><p>​编写一个copying函数，（1）确保复制所有local成员变量，（2）调用所有base classes内的适当的copying函数。</p><p>​不该令copy assignment操作符调用copy构造函数。反方向，令copy构造函数调用copy assignment操作符同样无意义。构造函数来初始化新对象，而assignment操作符只施行于已初始化对象身上。</p><p>​如果copy构造函数和copy assignment操作符有相近的代码，消除重复代码的做法是，建立一个新的成员函数给两者调用。这样的函数往往是private而且常被命名为init。这个策略可以安全消除copy构造函数和copy assignment操作符之间的代码重复。</p><p><strong>Remember</strong>：</p><ul><li>Copying 函数应该确保复制“对象内的所有成员变量”及“所有 base class 成分”。 </li><li>不要尝试以某个 copying 函数实现另一个copying 函数。应该将共同机能放进第三个函数中，并由两个coping 函数共同调用。</li></ul><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231027152734799.png&quot; alt=&quot;image-20231027152734799&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    
    <category term="Effective_Cpp" scheme="http://example.com/tags/Effective-Cpp/"/>
    
  </entry>
  
</feed>
