<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Cpp设计模式 | 久朝暮</title><meta name="keywords" content="C++设计模式"><meta name="author" content="久朝暮"><meta name="copyright" content="久朝暮"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Cpp设计模式"><meta name="application-name" content="Cpp设计模式"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#ffffff"><meta property="og:type" content="article"><meta property="og:title" content="Cpp设计模式"><meta property="og:url" content="https://gaoyubo.cn/blogs/1155b381.html"><meta property="og:site_name" content="久朝暮"><meta property="og:description" content="设计模式简介深入理解面向对象向下：深入理解三大面向对象机制  封装，隐藏内部实现 继承，复用现有代码 多态，改写对象行为  向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”。 解决复杂性：  分解 分而治之，将大问题分解为多个小问题，将复"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg"><meta property="article:author" content="久朝暮"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg"><meta name="description" content="设计模式简介深入理解面向对象向下：深入理解三大面向对象机制  封装，隐藏内部实现 继承，复用现有代码 多态，改写对象行为  向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”。 解决复杂性：  分解 分而治之，将大问题分解为多个小问题，将复"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://gaoyubo.cn/blogs/1155b381"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🏃 脚踏实地行动派","👆🏻 专注C++开发"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 久朝暮","link":"链接: ","source":"来源: 久朝暮","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '久朝暮',
  title: 'Cpp设计模式',
  postAI: '',
  pageFillDescription: '设计模式简介, 深入理解面向对象, 面向对象设计原则, 重新认识面向对象, 面向对象设计原则, 模板方法, 组件协作模式, Template Method模式, 动机, 模式定义, 结构类图, 要点总结, Strategy策略模式, 动机, 模式定义, 结构类图, 要点总结, Observer观察者模式, 动机, 模式定义, 结构类图, 要点总结, 单一职责模式, Decorator装饰模式, 动机, 模式定义, 结构类图, 要点总结, Bridge桥模式, 动机, 模式定义, 结构类图, 要点总结, 对象创建模式, Factory Method工厂方法, 动机, 模式定义, 结构类图, 要点总结, Abstract Factory抽象工厂, 动机, 模式定义, 结构类图, 要点总结, Prototype原型模式, 动机, 模式定义, 结构类图, 要点总结, Builder构建器（不常用）, 动机, 模式定义, 结构类图, 要点总结, 对象性能模式, Singleton单件模式, 动机, 模式定义, 结构类图, 要点总结, Flyweight享元模式, 动机, 模式定义, 结构类图, 要点总结, 接口隔离模式, Façade门面模式, 系统间耦合的复杂度, 动机, 模式定义, 结构类图, 要点总结, Proxy代理模式, 动机, 模式定义, 结构类图, 要点总结, Adapter适配器, 动机, 模式定义, 结构类图, 要点总结, Mediator中介者（不常用）, 动机, 模式定义, 结构类图, 要点总结, 状态变化模式, State状态模式, 动机, 模式定义, 结构类图, 要点总结, Memento备忘录（过时）, 动机, 模式定义, 结构类图, 要点总结, 数据结构模式, Composite组合模式, 动机, 模式定义, 结构类图, 要点总结, Iterator迭代器（面向对象实现已过时）, 动机, 模式定义, 结构类图, 要点总结, Chain of Resposibility职责链（过时）, 动机, 模式定义, 结构类图, 要点总结, 行为变化模式, Command命令模式（应用不广泛）, 动机, 模式定义, 结构类图, 要点总结, Visitor访问器（不常用）, 动机, 模式定义, 结构类图, 要点总结, 领域规则模式, Interpreter解析器（不常用）, 动机, 模式定义, 结构类图, 要点总结, 重构技法, 成长之路设计模式简介深入理解面向对象向下深入理解三大面向对象机制封装隐藏内部实现继承复用现有代码多态改写对象行为向上深刻把握面向对象机制所带来的抽象意义理解如何使用这些机制来表达现实世界掌握什么是好的面向对象设计解决复杂性分解分而治之将大问题分解为多个小问题将复杂问题分解为多个简单问题抽象由于不能掌握全部的复杂对象选择忽视它的非本质细节而去处理泛化和理想化了的对象模型面向对象设计原则重新认识面向对象理解隔离变化从宏观层面来看面向对象的构建方式更能适应软件的变化能将变化所带来的影响减为最小各司其职从微观层面来看面向对象的方式更强调各个类的责任由于需求变化导致的新增类型不应该影响原来类型的实现是所谓各负其责对象是什么从语言实现层面来看对象封装了代码和数据从规格层面讲对象是一系列可被使用的公共接口从概念层面讲对象是某种拥有责任的抽象面向对象设计原则依赖倒置原则高层模块稳定不应该依赖于低层模块变化二者都应该依赖于抽象稳定抽象稳定不应该依赖于实现细节变化实现细节应该依赖于抽象稳定开放封闭原则对扩展开放对更改封闭类模块应该是可扩展的但是不可修改单一职责原则一个类应该仅有一个引起它变化的原因变化的方向隐含着类的责任替换原则子类必须能够替换它们的基类继承表达类型抽象接口隔离原则不应该强迫客户程序依赖它们不用的方法接口应该小而完备优先使用对象组合而不是类继承类继承通常为白箱复用对象组合通常为黑箱复用继承在某种程度上破坏了封装性子类父类耦合度高而对象组合则只要求被组合的对象具有良好定义的接口耦合度低封装变化点使用封装来创建对象之间的分界层让设计者可以在分界层的一侧进行修改而不会对令另一侧产生不良的影响从而实现层次间的松耦合针对接口编程而不是针对实现编程不将变量类型声明为某个特定的具体类而是声明为某个接口客户程序无需获知对象的具体类型只需要知道对象所具有的接口减少系统中各部分的依赖关系从而实现高聚内松耦合的类型设计方案模板方法组件协作模式框架与应用程序的划分组件协作模式通过晚期绑定来实现框架与应用程序之间的松耦合是二者之间协作时常用的模式典序模式模式动机在软件构建过程中对于某一项任务它常常有稳定的整体操作结构但各个子步骤却有很多改变的需求或者由于固有的原因比如框架与应用之间的关系而无法和任务的整体结构同时实现模式定义定义一个操作中的算法的骨架稳定而将一些步骤延迟变化到子类中使得子类可以不改变复用一个算法的结构即可重定义重写该算法的某些特定步骤结构类图要点总结模式说一种非常基础性的设计模式在面向对象系统中有着大量的应用它用最简洁的机制虚函数的多态性为很多应用程序框架提供了灵活的扩展点是代码复用的方面的基本实现结构除了可以灵活应对子步骤的变化外不要调用我让我来调用你的反向控制结构是的典型应用在具体实现方面被调用的虚方法可以具有实现也可以没有任何实现抽象方法纯虚方法但一般推荐将它们设置为方法策略模式动机在软件构建过程中某些对象使用的算法可能多种多样经常改变如果将这些算法都编码到对象中将会使对象变得异常复杂而且有时候支持不使用的算法也是一个性能负担模式定义定义一系列算法把它们一个个封装起来并且使它们可互相替换变化该模式使得算法可独立于使用它的客户程序稳定而变化扩展子类化结构类图要点总结及其子类为组件提供了一系列可重用的算法从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换模式提供了用条件判断语句以外的另一种选择消除条件判断语句就是在解耦合含有许多条件判断语句的代码通常都需要模式如果对象没有实例变量那么各个上下文可以共享同一个对象从而节省对象开销观察者模式动机在软件构建过程中我们需要为某些对象建立一种通知依赖关系一个对象目标对象的状态发生改变所有的依赖对象观察者对象都将得到通知如果这样的依赖关系过于紧密将使软件不能很好地抵御变化使用面向对象技术可以将这种依赖关系弱化并形成一种稳定的依赖关系从而实现软件体系结构的松耦合模式定义定义对象间的一种一对多变化的依赖关系以便当一个对象的状态发生改变时所有依赖于它的对象都得到通知并自动更新结构类图要点总结使用面向对象的抽象模式使得我们可以独立地改变目标与观察者从而使二者之间的依赖关系达致松耦合目标发送通知时无需指定观察者通知可以携带通知信息作为参数会自动传播观察者自己决定是否需要订阅通知目标对象对此一无所知模式是基于事件的框架中非常常用的设计模式也是模式的一个重要组成部分单一职责模式在软件组件的设计中如果责任划分的不清晰使用继承得到的结果往往是随着需求的变化子类急剧膨胀同时充斥着重复代码这时候的关键是划清责任典型模式装饰模式动机在某些情况下我们可能会过度地使用继承来扩展对象的功能由于继承为类型引入的静态特质使得这种扩展方式缺乏灵活性并且随着子类的增多扩展功能的增多各种子类的组合扩展功能的组合会导致更多子类的膨胀模式定义动态组合地给一个对象增加一些额外的职责就增加功能而言模式比生成子类继承更为灵活消除重复代码减少子类个数结构类图要点总结通过采用组合而非继承的手法模式实现了在运行时动态扩展对象功能的能力而且可以根据需要扩展多个功能避免了使用继承带来的灵活性差和多子类衍生问题类在接口上表现为的继承关系即类继承了类所具有的接口但在实现上又表现为的组合关系即类又使用了另外一个类模式的目的并非解决多子类衍生的多继承问题模式应用的要点在于解决主体类在多个方向上的扩展功能是为装饰的含义桥模式动机由于某些类型的固有的实现逻辑使得它们具有两个变化的维度乃至多个维度的变化模式定义将抽象部分业务功能与实现部分平台实现分离使它们都可以独立地变化结构类图要点总结模式使用对象间的组合关系解耦了抽象和实现之间固有的绑定关系使得抽象和实现可以沿着各自的维度来变化所谓抽象和实现沿着各自纬度的变化即子类化它们模式有时候类似于多继承方案但是多继承方案往往违背单职责原则即一个类只有一个变化的原因复用性比较差模式是比多继承方案更好的解决方法模式的应用一般在两个非常强的变化维度有时一个类也有多于两个的变化维度这时可以使用的扩展模式对象创建模式通过对象创建模式绕开来避免对象创建过程中所导致的紧耦合依赖具体类从而支持对象创建的稳定它是接口抽象之后的第一步工作典型模式工厂方法动机在软件系统中经常面临着创建对象的工作由于需求的变化需要创建的对象的具体类型经常变化模式定义定义一个用于创建对象的接口让子类决定实例化哪个一个类使得一个类的实例化延迟目的解耦手段虚函数到子类结构类图要点总结模式用于隔离类对象的使用者和具体类型之间的耦合关系面对一个经常变化的具体类型紧耦合关系会导致软件的脆弱模式通过面向对象的手法将所要创建的具体对象工作延迟到子类从而实现一种扩展而非更改的策略较好地解决了这种紧耦合关系模式解决单个对象的需求变化缺点在于要求创建方法参数相同抽象工厂动机在软件系统中经常面临着一系列相互依赖的对象的创建工作同时由于需求的变化往往存在更多系列对象的创建工作模式定义提供一个接口让该接口负责创建一系列相关或者相互依赖的对象无需指定它们具体的类结构类图要点总结如果没有应对多系列对象构建的需求变化则没有必要使用模式这时候使用简单的工厂完全可以系列对象指的是在某一特定系列下的对象之间有相互依赖或作用的关系不同系列的对象之间不能相互依赖模式主要在于应对新系列的需求变动其缺点在于难以应对新对象的需求变动原型模式动机在软件系统中经常面临着某些结构复杂的对象的创建工作由于需求的变化这些对象经常面临着剧烈的变化但是它们却拥有比较稳定一致的接口模式定义使用原型实例指定创建对象的种类然后通过拷贝深拷贝这些原型来创建新的对象结构类图要点总结模式同样用于隔离类对象的使用者和具体类型易变类之间的耦合关系它同样要求这些易变类拥有稳定的接口模式对于如何创建易变类的实体对象采用原型克隆的方法来做它使得我们可以非常灵活地动态创建拥有某些稳定接口的新对象所需工作仅仅是注册一个新类的对象即原型然后在任何需要的地方模式中的方法可以利用某些框架中的序列化来实现深拷贝构建器不常用动机在软件系统中有时候面临着一个复杂对象的创建工作其通常由各个部分的子对象用一定的算法构成由于需求的变化这个复杂对象的各个部分经常面临着剧烈的变化但是将它们组合在一起的算法却相对稳定模式定义将一个复杂对象的构建与其表示相分离使得同样的构建过程稳定可以创建不同的表示变化结构类图要点总结模式主要用于分步骤构建一个复杂的对象在这其中分步骤是一个稳定的算法而复杂对象的各个部分则经常变化变化点在哪里封装哪里模式主要在于应对复杂对象各个部分的频繁需求变动其缺点在于难以应对分步骤构建算法的需求变动在模式中要注意不同语言中构造器内调用虚函数的差别对象性能模式面向对象很好地解决了抽象的问题但是必不可免地要付出一定的代价对于通常情况来讲面向对象的成本大都可以忽略不计但是某些情况面向对象所带来的成本必须谨慎处理典型模式单件模式动机在软件系统中经常有这样一些特殊的类必须保证它们在系统中只存在一个实例才能确保它们的逻辑正确性以及良好的效率模式定义保证一个类仅有一个实例并提供一个该实例的全局访问点结构类图要点总结模式中的实例构造器可以设置为以允许子类派生模式一般不要支持拷贝构造函数和接口因为这有可能导致多个对象实例与模式的初衷违背如何实现多线程环境下安全的注意对双检查锁的正确实现享元模式动机在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很块充斥在系统中从而带来很高的运行时代价主要指内存需求方面的代价模式定义运用共享技术有效地支持大量细粒度的对象结构类图要点总结面向对象很好地解决了抽象性的问题但是作为一个运行在机器中的程序实体我们需要考虑对象的代价问题主要解决面向对象的代价问题一般不触及面向对象的抽象性问题采用对象共享的做法来降低系统中对象的个数从而降低细粒度对象给系统带来的内存压力在具体实现方面要注意对象状态最好是只读的处理对象的数量太大从而导致对象内存开销加大什么样的数量才算大这需要我们仔细的根据具体应用情况进行评估而不能凭空臆断接口隔离模式在组件构建过程中某些接口之间直接的依赖常常会带来很多问题甚至根本无法实现采用添加一层间接稳定接口来隔离本来互相紧密关联的接口是一种常见的解决方案典型模式门面模式系统间耦合的复杂度动机上述方案的问题在于组件的客户和组件各种复杂的子系统有了过多的耦合随着外部客户程序和各子系统的演化这种过多的耦合面临很多变化的挑战模式定义为子系统中的一组接口提供一个一致稳定的界面模式定义了一个高层接口这个接口使得这一子系统更加容易使用复用结构类图要点总结从客户程序的角度来看模式简化了整个组件系统的接口对于组件内部与外部客户程序来说达到了一种解耦的效果内部子系统的任何变化不会影响到接口的变化设计模式更注重从架构的层次去看整个系统而不是单个类的层次很多时候更是一种架构设计模式设计模式并非一个集装箱可以任意地放进任何多个对象模式中组件的内部应该是相互耦合关系比较大的一系列组件而不是一个简单的功能集合代理模式动机在面向对象系统中有些对象由于某种原因比如对象创建的开销很大或者某些操作需要安全控制或者需要进程外的访问等直接访问会给使用者或者系统结构带来很多麻烦模式定义为其他对象提供一种代理以控制隔离使用接口对这个对象的访问结构类图要点总结增加一层间接层是软件系统中对许多复杂问题的一种常见解决方法在面向对象系统中直接使用某些对象会带来很多问题作为间接层的对象便是解决这一问题的常用手段具体设计模式的实现方法实现粒度都相差很大有些可能对单个对象做细粒度的控制如技术有些可能对组件模块提供抽象代理层在架构层次对对象做并不一定要求保持接口完整的一致性只要能够实现间接控制有时候损及一些透明性是可以接受的适配器动机在软件系统中由于应用环境的变化常常需要将一些现存的对象放在新的环境中应用但是新环境要求的接口是这些现存对象所不满足的模式定义将一个类的接口转换成客户希望的另一个接口模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作结构类图要点总结模式主要应用于希望复用一些现存的类但是接口又与复用环境要求不一致的情况在遗留代码复用类库迁移等方面非常有用定义了两种模式的实现结构对象适配器和类适配器但类适配器采用多继承的实现方式一般不推荐使用对象适配器采用对象组合的方式更符合松耦合精神模式可以实现的非常灵活不必拘泥于中定义的两种结构例如完全可以将模式中的现存对象作为新的接口方法参数来达到适配的目的中介者不常用动机在软件构建过程中经常会出现多个对象互相关联交互的情况对象之间常常会维持一种复杂的引用关系如果遇到一些需求的更改这种直接的引用关系将面临不断的变化在这种情况下使用一个中介对象来管理对象间的关联关系避免相互交互的对象之间的紧耦合引用关系从而更好地抵御变化模式定义用一个中介对象来封装封装变化一系列的对象交互中介者使各对象不需要显式的相互引用编译时依赖运行时依赖从而使其耦合松散管理变化而且可以独立地改变它们之间的交互结构类图要点总结将多个对象间复杂的关联关系解耦模式将多个对象间的控制逻辑进行集中管理变多个对象互相关联为多个对象和一个中介者关联简化了系统的维护抵御了可能的变化随着控制逻辑的复杂化具体对象的实现可能相当复杂这时候可以对对象进行分解处理模式是解耦系统间单向的对象关联关系模式是解耦系统内各个对象之间双向的关联关系状态变化模式在组件构建过程中某些对象的状态经常面临变化如何对这些变化进行有效的管理同时又维持高层模块的稳定状态变化模式为这一问题提供了一种解决方案典型模式状态模式动机在软件构建过程中某些对象的状态如果改变其行为也会随之而发生变化比如文档处于只读状态其支持的行为和读写状态支持的行为就可能完全不同模式定义允许一个对象在其内部状态改变时改变它的行为从而使对象看起来似乎修改了其行为结构类图要点总结模式将所有与一个特定状态相关的行为都放入一个的子类对象中在对象状态切换时切换相应的对象但同时维持的接口这样实现了具体操作与状态转换之间的解耦为不同的状态引入不同的对象使得状态转换变得更加明确而且可以保证不会出现状态不一致的情况因为转换是原子性的即要么彻底转换过来要么不转换如果对象没有实例变量那么各个上下文可以共享同一个对象从而节省对象开销备忘录过时动机在软件构建过程中某些对象的状态在转换过程中可能由于某种需要要求程序能够回溯到对象之前处于某个点时的状态如果使用一些共有接口来让其他对象得到对象的状态便会暴露对象的细节实现模式定义在不破坏封装性的前提下捕获一个对象的内部状态并在该对象之外保存这个状态这样以后就可以将该对象恢复到原先保存的状态结构类图要点总结备忘录存储原发器对象的内部状态在需要时恢复原发器状态模式的核心是信息隐藏即需要向外接隐藏信息保持其封装性但同时又需要将状态保持到外界由于现代语言运行时如等都具有相当的对象序列化支持因此往往采用效率较高又较容易正确实现的序列化方案来实现模式数据结构模式常常有一些组件在内部具有特定的数据结构如果让客户程序依赖这些特定的数据结构将极大地破坏组件的复用这时候将这些特定数据结构封装在内部在外部提供统一的接口来实现与特定数据结构无关的访问是一种行之有效的解决方案典型模式组合模式动机软件在某些情况下客户代码过多地依赖于对象容器复杂的内部实现结构对象容器内部实现结构而非抽象接口的变化将引起客户代码的频繁变化带来了代码的维护性扩展性等弊端模式定义将对象组合成树形结构以表示部分整体的层次结构使得用户对单个对象和组合对象的使用具有一致性稳定结构类图要点总结模式采用树形结构来实现普遍存在的对象容器从而将一对多的关系转化为一对一的关系使得客户代码可以一致地复用处理对象和对象容器无需关心处理的是单个的对象还是组合的对象容器将客户代码与复杂的对象容器结构解耦是的核心思想解耦之后客户代码将与纯粹的抽象接口而非对象容器的内部实现结构发生依赖从而更能应对变化模式在具体实现中可以让父对象中的子对象反向追溯如果父对象有频繁的遍历需求可使用缓存技巧来改善效率迭代器面向对象实现已过时动机在软件构建过程中集合对象内部结构常常变化各异但对于这些集合对象我们希望在不暴露其内部结构的同时可以让外部客户代码透明地访问其中包含的元素同时这种透明遍历也为同一种算法在多种集合对象上进行操作提供了可能模式定义提供一种方法顺序访问一个聚合对象中的各个元素而又不暴露稳定该对象的内部表示结构类图要点总结迭代抽象访问一个聚合对象的内容而无需暴露它的内部表示迭代多态为遍历不同的集合结构提供一个统一的接口从而支持同样的算法在不同的集合结构上进行操作迭代器的健壮性考虑遍历的同时更改迭代器所在的集合结构会导致问题职责链过时动机在软件构建过程中一个请求可能被多个对象处理但是每个请求在运行时只能有一个接收者如果显示指定将必不可少地带来请求发送者与接收者的紧耦合模式定义使多个对象都有机会处理请求从而避免请求的发送者和接收者之间的耦合关系将这些对象连成一条链并沿着这条链传递请求直到有一个对象处理它为止结构类图要点总结模式的应用场合在于一个请求可能有多个接受者但是最后真正的接受者只有一个这时候请求发送者与接受者的耦合有可能出现变化脆弱的症状职责链的目的就是将二者解耦从而更好地应对变化应用了模式后对象的职责分派将更具灵活性我们可以在运行时动态添加修改请求的处理职责如果请求传递到职责链的末尾仍得不到处理应该有一个合理的缺省机制这也是每一个接受对象的责任而不是发出请求的对象的责任行为变化模式在组件的构建过程中组件行为的变化经常导致组件本身剧烈的变化行为变化模式将组件的行为和组件本身进行解耦从而支持组件行为的变化实现两者之间的松耦合典型模式命令模式应用不广泛动机在软件构建过程中行为请求者与行为实现者通常呈现一种紧耦合但在某些场合比如需要对行为进行记录撤销重做事务等处理这种无法抵御变化的紧耦合是不合适的模式定义将一个请求行为封装为一个对象从而使你可用不同的请求对客户进行参数化对请求排队或记录请求日志以及支持可撤销的操作结构类图要点总结模式的根本目的在于将行为请求者与行为实现者解耦在面向对象语言中常见的实现手段是将行为抽象为对象实现接口的具体命令对象有时候根据需要可能会保存一些额外的状态信息通过使用模式可以将多个命令封装为一个复合命令模式与中的函数对象有些类似但两者定义行为接口的规范有所区别以面向对象中的接口实现来定义行为接口规范更严格但有性能损失函数对象以函数签名来定义行为接口规范更灵活性能更高访问器不常用动机在软件构建过程中由于需求的改变某些类层次结构中常常需要增加新的行为方法如果直接在基类中做这样的更改将会给子类带来很繁重的变更负担甚至破坏原有设计模式定义表示一个作用于某对象结构中的各元素的操作使得可以在不改变稳定各元素的类的前提下定义扩展作用于这些元素的新操作变化结构类图要点总结模式通过所谓双重分发来实现在不更改不添加新的操作编译时类层次结构的前提下在运行时透明地为类层次结构上的各个类动态添加新的操作支持变化所谓双重分发即模式中间包括了两个多态分发注意其中的多态机制第一个为方法的多态辨析第二个为方法的多态辨析模式的最大缺点在于扩展类层次结构增添新的子类会导致类的改变因此模式适用于类层次结构稳定而其中的操作却经常面临频繁改动领域规则模式在特定领域中某些变化虽然频繁但可以抽象为某种规则这时候结合特定领域将问题抽象为语法规则从而给出在该领域下的一般性解决方案典型模式解析器不常用动机在软件构建过程中如果某一特定领域的问题比较复杂类似的结构不断重复出现如果使用普通的编程方式来实现将面临非常频繁的变化模式定义给定一个语言定义它的文法的一种表示并定义一种解释器这个解释器使用该表示来解释语言中的句子结构类图要点总结模式的应用场合是模式应用中的难点只有满足业务规则频繁变化且类似的结构不断重复出现并且容易抽象为语法规则的问题才适合使用模式使用模式来表示文法规则从而可以使用面向对象技巧来方便地扩展文法模式比较适合简单的文法表示对于复杂的文法表示模式会产生比较大的类层次结构需要求助于语法分析生成器这样的标准工具重构技法静态动态早绑定晚绑定继承组合编译时依赖运行时依赖紧耦合松耦合成长之路手中无剑心中无剑见模式而不知手中有剑心中无剑可以识别模式作为应用开发人员使用模式手中有剑心中有剑作为框架开发人员为应用设计某些模式手中无剑心中有剑忘掉模式只有原则',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-19 16:47:32',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">久朝暮</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/album/"><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-STL/" style="font-size: 1.05rem;">C++ STL<sup>1</sup></a><a href="/tags/C-2-0/" style="font-size: 1.05rem;">C++2.0<sup>1</sup></a><a href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">C++内存管理<sup>1</sup></a><a href="/tags/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">C++设计模式<sup>1</sup></a><a href="/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">C++面向对象高级编程<sup>1</sup></a><a href="/tags/Effective-C/" style="font-size: 1.05rem;">Effective C++<sup>1</sup></a><a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" style="font-size: 1.05rem;">Linux常用函数<sup>1</sup></a><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">Linux系统命令<sup>1</sup></a><a href="/tags/UCAS%E8%AF%BE%E7%A8%8B/" style="font-size: 1.05rem;">UCAS课程<sup>2</sup></a><a href="/tags/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%BF%9E%E7%BD%91%E6%8A%80%E6%9C%AF/" style="font-size: 1.05rem;">移动互连网技术<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/" itemprop="url">C++</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++设计模式</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Cpp设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-18T11:10:38.000Z" title="发表于 2023-11-18 19:10:38">2023-11-18</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-12-19T08:47:32.006Z" title="更新于 2023-12-19 16:47:32">2023-12-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">8.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://gaoyubo.cn/blogs/1155b381.html"><header><a class="post-meta-categories" href="/categories/C/" itemprop="url">C++</a><a href="/tags/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" tabindex="-1" itemprop="url">C++设计模式</a><h1 id="CrawlerTitle" itemprop="name headline">Cpp设计模式</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">久朝暮</span><time itemprop="dateCreated datePublished" datetime="2023-11-18T11:10:38.000Z" title="发表于 2023-11-18 19:10:38">2023-11-18</time><time itemprop="dateCreated datePublished" datetime="2023-12-19T08:47:32.006Z" title="更新于 2023-12-19 16:47:32">2023-12-19</time></header><h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><h2 id="深入理解面向对象"><a href="#深入理解面向对象" class="headerlink" title="深入理解面向对象"></a>深入理解面向对象</h2><p>向下：深入理解三大面向对象机制</p>
<ul>
<li>封装，隐藏内部实现</li>
<li>继承，复用现有代码</li>
<li>多态，改写对象行为</li>
</ul>
<p>向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”。</p>
<p>解决复杂性：</p>
<ul>
<li><strong>分解</strong><ul>
<li>分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。</li>
</ul>
</li>
<li><strong>抽象</strong><ul>
<li>由于不能掌握全部的复杂对象，选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。</li>
</ul>
</li>
</ul>
<h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><h2 id="重新认识面向对象"><a href="#重新认识面向对象" class="headerlink" title="重新认识面向对象"></a>重新认识面向对象</h2><ul>
<li><p>理解隔离变化</p>
<ul>
<li>从<code>宏观层面</code>来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小</li>
</ul>
</li>
<li><p>各司其职</p>
<ul>
<li>从<code>微观层面</code>来看，面向对象的方式更强调各个类的“责任”</li>
<li>由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓<code>各负其责</code></li>
</ul>
</li>
<li>对象是什么?<ul>
<li>从<code>语言实现</code>层面来看，对象封装了代码和数据</li>
<li>从<code>规格层面</code>讲，对象是一系列可被使用的公共接口</li>
<li>从<code>概念层面</code>讲，对象是某种拥有责任的抽象</li>
</ul>
</li>
</ul>
<h2 id="面向对象设计原则-1"><a href="#面向对象设计原则-1" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p><code>依赖倒置原则</code>（<em>DIP</em>）：</p>
<ul>
<li>高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）</li>
<li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</li>
</ul>
<p><code>开放封闭原则</code>（<em>OCP</em>）：</p>
<ul>
<li>对扩展开放，对更改封闭</li>
<li>类模块应该是可扩展的，但是不可修改</li>
</ul>
<p><code>单一职责原则</code>（<em>SRP</em>）：</p>
<ul>
<li>一个类应该仅有一个引起它变化的原因</li>
<li>变化的方向隐含着类的责任</li>
</ul>
<p><code>Liskov替换原则</code>（<em>LSP</em>）：</p>
<ul>
<li>子类必须能够替换它们的基类（IS-A）</li>
<li>继承表达类型抽象</li>
</ul>
<p><code>接口隔离原则</code>（<em>ISP</em>）：</p>
<ul>
<li>不应该强迫客户程序依赖它们不用的方法</li>
<li>接口应该小而完备</li>
</ul>
<p><code>优先使用对象组合，而不是类继承</code>：</p>
<ul>
<li>类继承通常为”白箱复用“，对象组合通常为”黑箱复用“</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高</li>
<li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低</li>
</ul>
<p><code>封装变化点</code>：</p>
<ul>
<li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对令另一侧产生不良的影响，从而实现层次间的松耦合</li>
</ul>
<p><code>针对接口编程，而不是针对实现编程</code>：</p>
<ul>
<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li>
<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口</li>
<li>减少系统中各部分的依赖关系，从而实现“高聚内、松耦合”的类型设计方案</li>
</ul>
<h1 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h1><h2 id="“组件协作”模式"><a href="#“组件协作”模式" class="headerlink" title="“组件协作”模式"></a>“组件协作”模式</h2><p>​    <code>框架</code>与<code>应用程序</code>的划分，”组件协作”模式通过<code>晚期绑定</code>，来实现框架与应用程序之间的<code>松耦合</code>，是二者之间协作时常用的模式。</p>
<p>典序模式：</p>
<ul>
<li><strong>Template Method</strong></li>
<li><strong>Strategy</strong></li>
<li><strong>Observer/Event</strong></li>
</ul>
<h3 id="Template-Method模式"><a href="#Template-Method模式" class="headerlink" title="Template Method模式"></a>Template Method模式</h3><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>​    在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p>
<h4 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h4><p>​    定义一个操作中的算法的<code>骨架</code>（稳定），而将一些步骤<code>延迟</code>（变化）到子类中。Template Method使得子类可以不改变（复用）一个算法的结构即可重定义（override重写）该算法的某些特定步骤。</p>
<h4 id="结构类图"><a href="#结构类图" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231120222618841.png" alt="image-20231120222618841"></p>
<h4 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Template Method模式说一种非常<code>基础性</code>的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（<code>虚函数的多态性</code>）为很多应用程序框架提供了灵活的<code>扩展点</code>，是代码复用的方面的基本实现结构。</li>
<li>除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你” 的<code>反向控制结构</code>是Template Method的典型应用。</li>
<li>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为<code>protected</code>方法。</li>
</ul>
<h3 id="Strategy策略模式"><a href="#Strategy策略模式" class="headerlink" title="Strategy策略模式"></a>Strategy策略模式</h3><h4 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担。</p>
<h4 id="模式定义-1"><a href="#模式定义-1" class="headerlink" title="模式定义"></a>模式定义</h4><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。</p>
<h4 id="结构类图-1"><a href="#结构类图-1" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231120222409218.png" alt="image-20231120222409218"></p>
<h4 id="要点总结-1"><a href="#要点总结-1" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在<code>运行时</code>方便地根据需要在各个算法之间进行切换。</li>
<li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在<code>解耦合</code>。含有<code>许多条件判断语句</code>的代码通常都需要Strategy模式。</li>
<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。</li>
</ul>
<h3 id="Observer观察者模式"><a href="#Observer观察者模式" class="headerlink" title="Observer观察者模式"></a>Observer观察者模式</h3><h4 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，<code>所有的依赖对象</code>（观察者对象）都将得到<code>通知</code>。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。</p>
<p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的<code>松耦合</code>。</p>
<h4 id="模式定义-2"><a href="#模式定义-2" class="headerlink" title="模式定义"></a>模式定义</h4><p>定义对象间的一种<code>一对多</code>（变化）的依赖关系，以便当<code>一个对象</code>（<em>Subject</em>）的状态发生改变时，<code>所有依赖于它的对象</code>都得到通知并自动更新。</p>
<h4 id="结构类图-2"><a href="#结构类图-2" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231120222300089.png" alt="image-20231120222300089"></p>
<h4 id="要点总结-2"><a href="#要点总结-2" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>使用面向对象的抽象，Observer模式使得我们可以<code>独立地改变</code>目标与观察者，从而使二者之间的依赖关系达致松耦合。</li>
<li>目标发送通知时，<code>无需指定观察者</code>，通知（可以携带通知信息作为参数）会自动传播。</li>
<li>观察者自己决定是否需要订阅通知，目标对象对此一无所知。</li>
<li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。</li>
</ul>
<h2 id="“单一职责”模式"><a href="#“单一职责”模式" class="headerlink" title="“单一职责”模式"></a>“单一职责”模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</p>
<p>典型模式：</p>
<ul>
<li><strong>Decorator</strong></li>
<li><strong>Bridge</strong></li>
</ul>
<h3 id="Decorator装饰模式"><a href="#Decorator装饰模式" class="headerlink" title="Decorator装饰模式"></a>Decorator装饰模式</h3><h4 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h4><ul>
<li>在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于<code>继承</code>为类型引入的<code>静态特质</code>，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</li>
</ul>
<h4 id="模式定义-3"><a href="#模式定义-3" class="headerlink" title="模式定义"></a>模式定义</h4><p><code>动态</code>（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（<code>消除重复代码</code>&amp;<code>减少子类个数</code>）。</p>
<h4 id="结构类图-3"><a href="#结构类图-3" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/R3D2TU9_8B_IUS1Y0H0BK%252.png" alt="img"></p>
<h4 id="要点总结-3"><a href="#要点总结-3" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</li>
<li>Decorator类在接口上表现为<code>is-a Component</code>的<code>继承</code>关系，即 Decorator类继承了Component类所具有的接口。但在实现上又表现为<code>has-a Component</code>的<code>组合</code>关系，即Decorator类又使用了另外一个Component类。</li>
<li>Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决<code>“主体类在多个方向上的扩展功能”</code>——是为<code>“装饰”</code>的含义。</li>
</ul>
<h3 id="Bridge桥模式"><a href="#Bridge桥模式" class="headerlink" title="Bridge桥模式"></a>Bridge桥模式</h3><h4 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h4><p>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化。</p>
<h4 id="模式定义-4"><a href="#模式定义-4" class="headerlink" title="模式定义"></a>模式定义</h4><p>将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。</p>
<h4 id="结构类图-4"><a href="#结构类图-4" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231119233730329.png" alt="image-20231119233730329"></p>
<h4 id="要点总结-4"><a href="#要点总结-4" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</li>
<li>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单—职责原则（即一个类只有一个变化的原因），复用性比较差。 Bridge模式是比多继承方案更好的解决方法。</li>
<li>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</li>
</ul>
<h2 id="“对象创建”模式"><a href="#“对象创建”模式" class="headerlink" title="“对象创建”模式"></a>“对象创建”模式</h2><p>通过”对象创建“模式<code>绕开new</code>，来避免对象创建（new）过程中所导致的<code>紧耦合</code>（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</p>
<p>典型模式：</p>
<ul>
<li><strong>Factory Method</strong></li>
<li><strong>Abstract Factory</strong></li>
<li><strong>Prototype</strong></li>
<li><strong>Builder</strong></li>
</ul>
<h3 id="Factory-Method工厂方法"><a href="#Factory-Method工厂方法" class="headerlink" title="Factory Method工厂方法"></a>Factory Method工厂方法</h3><h4 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h4><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。</p>
<h4 id="模式定义-5"><a href="#模式定义-5" class="headerlink" title="模式定义"></a>模式定义</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪个一个类。Factory Method使得一个类的<code>实例化延迟</code>（目的：解耦，手段：虚函数）<code>到子类</code>。</p>
<h4 id="结构类图-5"><a href="#结构类图-5" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231120200340583.png" alt="image-20231120200340583"></p>
<h4 id="要点总结-5"><a href="#要点总结-5" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦 合关系。面对一个经常变化的具体类型，紧耦合关系（<em>new</em>）会导致软件的脆弱。</li>
<li>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作<code>延迟</code>到子类，从而实现一种<code>扩展</code>（而非更改）的策略，较好地解决了这种紧耦合关系。</li>
<li>Factory Method模式解决<code>“单个对象”</code>的需求变化。缺点在于要求创建<code>方法/参数</code>相同。</li>
</ul>
<h3 id="Abstract-Factory抽象工厂"><a href="#Abstract-Factory抽象工厂" class="headerlink" title="Abstract Factory抽象工厂"></a>Abstract Factory抽象工厂</h3><h4 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h4><p>在软件系统中，经常面临着<code>“一系列相互依赖的对象”</code>的创建工作；同时，由于需求的变化，往往存在<code>更多系列对象</code>的创建工作。</p>
<h4 id="模式定义-6"><a href="#模式定义-6" class="headerlink" title="模式定义"></a>模式定义</h4><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</p>
<h4 id="结构类图-6"><a href="#结构类图-6" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231120205243838.png" alt="image-20231120205243838"></p>
<h4 id="要点总结-6"><a href="#要点总结-6" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>如果没有应对“多系列对象构建”的需求变化,则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以。</li>
<li><code>“系列对象”</code>指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。</li>
<li>Abstract Factory模式主要在于应对<code>“新系列”</code>的需求变动。其缺点在于难以应对<code>“新对象”</code>的需求变动。</li>
</ul>
<h3 id="Prototype原型模式"><a href="#Prototype原型模式" class="headerlink" title="Prototype原型模式"></a>Prototype原型模式</h3><h4 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h4><p>在软件系统中，经常面临着<code>“某些结构复杂的对象”</code>的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</p>
<h4 id="模式定义-7"><a href="#模式定义-7" class="headerlink" title="模式定义"></a>模式定义</h4><p>使用<code>原型实例</code>指定创建对象的种类，然后通过<code>拷贝</code>（深拷贝）这些原型来创建新的对象。</p>
<h4 id="结构类图-7"><a href="#结构类图-7" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231120211241207.png" alt="image-20231120211241207"></p>
<h4 id="要点总结-7"><a href="#要点总结-7" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有<code>“稳定的接口”</code>。</li>
<li>Prototype模式对于“如何创建易变类的实体对象”采用<code>“原型克隆”</code>的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象（即原型）， 然后在任何需要的地方Clone。</li>
<li>Prototype模式中的<code>Clone方法</code>可以利用某些框架中的<code>序列化</code>来实现<code>深拷贝</code>。</li>
</ul>
<h3 id="Builder构建器（不常用）"><a href="#Builder构建器（不常用）" class="headerlink" title="Builder构建器（不常用）"></a>Builder构建器（不常用）</h3><h4 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h4><p>在软件系统中，有时候面临着<code>“一个复杂对象”</code>的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们<code>组合</code>在一起的算法却相对稳定。</p>
<h4 id="模式定义-8"><a href="#模式定义-8" class="headerlink" title="模式定义"></a>模式定义</h4><p>将一个复杂对象的<code>构建</code>与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。</p>
<h4 id="结构类图-8"><a href="#结构类图-8" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231120214135747.png" alt="image-20231120214135747"></p>
<h4 id="要点总结-8"><a href="#要点总结-8" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</li>
<li>变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。</li>
<li>在Builder模式中，要注意不同语言中构造器内<code>调用虚函数</code>的差别 (C++ vs C#)。</li>
</ul>
<h2 id="“对象性能”模式"><a href="#“对象性能”模式" class="headerlink" title="“对象性能”模式"></a>“对象性能”模式</h2><p>面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是<code>某些情况</code>，面向对象所带来的成本必须谨慎处理。</p>
<p>典型模式：</p>
<ul>
<li><strong>Singleton</strong></li>
<li><strong>Flyweight</strong></li>
</ul>
<h3 id="Singleton单件模式"><a href="#Singleton单件模式" class="headerlink" title="Singleton单件模式"></a>Singleton单件模式</h3><h4 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h4><p>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中<code>只存在一个实例</code>，才能确保它们的逻辑正确性、以及良好的效率。</p>
<h4 id="模式定义-9"><a href="#模式定义-9" class="headerlink" title="模式定义"></a>模式定义</h4><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。</p>
<h4 id="结构类图-9"><a href="#结构类图-9" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231120221457163.png" alt="image-20231120221457163"></p>
<h4 id="要点总结-9"><a href="#要点总结-9" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li>
<li>Singleton模式一般<code>不要支持拷贝构造函数</code>和<code>Clone接口</code>，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。</li>
<li>如何实现多线程环境下安全的Singleton? 注意对<code>双检查锁</code>的正确实现。</li>
</ul>
<h3 id="Flyweight享元模式"><a href="#Flyweight享元模式" class="headerlink" title="Flyweight享元模式"></a>Flyweight享元模式</h3><h4 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h4><p>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很块充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。</p>
<h4 id="模式定义-10"><a href="#模式定义-10" class="headerlink" title="模式定义"></a>模式定义</h4><p>运用<code>共享</code>技术有效地支持<code>大量</code>细粒度的对象。</p>
<h4 id="结构类图-10"><a href="#结构类图-10" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121173601268.png" alt="image-20231121173601268"></p>
<h4 id="要点总结-10"><a href="#要点总结-10" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的<code>代价问题</code>，一般不触及面向对象的抽象性问题。</li>
<li>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象<code>状态</code>（最好是只读）的处理。</li>
<li>对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行<code>评估</code>，而不能<code>凭空臆断</code>。</li>
</ul>
<h2 id="“接口隔离”模式"><a href="#“接口隔离”模式" class="headerlink" title="“接口隔离”模式"></a>“接口隔离”模式</h2><p>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层<code>间接</code>（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</p>
<p>典型模式：</p>
<ul>
<li><strong>Façade</strong></li>
<li><strong>Proxy</strong></li>
<li><strong>Adapter</strong></li>
<li><strong>Mediator</strong></li>
</ul>
<h3 id="Facade门面模式"><a href="#Facade门面模式" class="headerlink" title="Façade门面模式"></a>Façade门面模式</h3><h4 id="系统间耦合的复杂度"><a href="#系统间耦合的复杂度" class="headerlink" title="系统间耦合的复杂度"></a>系统间耦合的复杂度</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121181251775.png" alt="image-20231121181251775"></p>
<h4 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h4><p>上述A方案的问题在于组件的客户和组件各种复杂的<code>子系统</code>有了<code>过多的耦合</code>，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</p>
<h4 id="模式定义-11"><a href="#模式定义-11" class="headerlink" title="模式定义"></a>模式定义</h4><p>为子系统中的一组接口提供一个<code>一致</code>（稳定）的界面，Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（<code>复用</code>）。</p>
<h4 id="结构类图-11"><a href="#结构类图-11" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121184512984.png" alt="image-20231121184512984"></p>
<h4 id="要点总结-11"><a href="#要点总结-11" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>从客户程序的角度来看，Façade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种<code>“解耦”</code>的效果—— 内部子系统的任何变化不会影响到Façade接口的变化。</li>
<li>Façade设计模式更注重从<code>架构</code>的层次去看整个系统，而不是单个类的层次。Façade很多时候更是一种架构设计模式。</li>
<li>Façade设计模式并非一个集装箱，可以任意地放进任何多个对象。 Façade模式中组件的内部应该是<code>“相互耦合关系比较大的一系列组件”</code>，而不是一个简单的功能集合。</li>
</ul>
<h3 id="Proxy代理模式"><a href="#Proxy代理模式" class="headerlink" title="Proxy代理模式"></a>Proxy代理模式</h3><h4 id="动机-12"><a href="#动机-12" class="headerlink" title="动机"></a>动机</h4><p>在面向对象系统中，有些对象由于某种原因（比如<code>对象创建的开销很大</code>，或者<code>某些操作需要安全控制</code>，或者<code>需要进程外的访问</code>等），直接访问会给使用者、或者系统结构带来很多麻烦。</p>
<h4 id="模式定义-12"><a href="#模式定义-12" class="headerlink" title="模式定义"></a>模式定义</h4><p>为其他对象提供一种代理以<code>控制（隔离，使用接口）</code>对这个对象的访问。</p>
<h4 id="结构类图-12"><a href="#结构类图-12" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121185353338.png" alt="image-20231121185353338"></p>
<h4 id="要点总结-12"><a href="#要点总结-12" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li><code>“增加一层间接层”</code>是软件系统中对许多复杂问题的一种常见解决方 法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。</li>
<li>具体proxy设计模式的实现方法、实现粒度都<code>相差很大</code>，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。</li>
<li>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候<code>损及一些透明性</code>是可以接受的。</li>
</ul>
<h3 id="Adapter适配器"><a href="#Adapter适配器" class="headerlink" title="Adapter适配器"></a>Adapter适配器</h3><h4 id="动机-13"><a href="#动机-13" class="headerlink" title="动机"></a>动机</h4><p>在软件系统中，由于应用环境的变化，常常需要将<strong>“一些现存的对象”</strong>放在新的环境中应用，但是<strong>新环境要求的接口</strong>是这些现存对象所不满足的。</p>
<h4 id="模式定义-13"><a href="#模式定义-13" class="headerlink" title="模式定义"></a>模式定义</h4><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于<strong>接口不兼容</strong>而不能一起工作的那些类<strong>可以一起工作</strong>。</p>
<h4 id="结构类图-13"><a href="#结构类图-13" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121200241869.png" alt="image-20231121200241869"></p>
<h4 id="要点总结-13"><a href="#要点总结-13" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Adapter模式主要应用于<strong>“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”</strong>，在<code>遗留代码复用</code>、<code>类库迁移</code>等方面非常有用。</li>
<li>GoF 23定义了两种Adapter模式的实现结构：<code>对象适配器</code>和<code>类适配器</code>。但类适配器采用<code>“多继承”</code>的实现方式，<code>一般不推荐使用</code>。<strong>对象适配器采用“对象组合”的方式，更符合松耦合精神</strong>。</li>
<li>Adapter模式可以实现的非常灵活，不必拘泥于Gof23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。</li>
</ul>
<h3 id="Mediator中介者（不常用）"><a href="#Mediator中介者（不常用）" class="headerlink" title="Mediator中介者（不常用）"></a>Mediator中介者（不常用）</h3><h4 id="动机-14"><a href="#动机-14" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，经常会出现<strong>多个对象</strong>互相关联交互的情况，对象之间常常会维持一种<strong>复杂的引用关系</strong>，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</p>
<p>在这种情况下，使用一个”中介对象“来管理对象间的关联关系，<strong>避免相互交互的对象之间的紧耦合引用关系</strong>，从而更好地抵御变化。</p>
<h4 id="模式定义-14"><a href="#模式定义-14" class="headerlink" title="模式定义"></a>模式定义</h4><p>用一个中介对象来<strong>封装</strong>（<code>封装变化</code>）一系列的对象交互。中介者使各对象不需要显式的<strong>相互引用</strong>（<code>编译时依赖</code> -&gt; 运行时依赖），从而使其<strong>耦合松散</strong>（管理变化），而且可以独立地改变它们之间的交互。</p>
<h4 id="结构类图-14"><a href="#结构类图-14" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121203025050.png" alt="image-20231121203025050"></p>
<h4 id="要点总结-14"><a href="#要点总结-14" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>将多个对象间复杂的关联关系<code>解耦</code>，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为<code>“多个对象和一个中介者关联”</code>，<strong>简化了系统的维护，抵御了可能的变化。</strong></li>
<li>随着控制逻辑的复杂化，Mediator具体对象的实现<strong>可能相当复杂</strong>。 这时候可以对Mediator对象进行<code>分解处理</code>。</li>
<li><strong>Façade模式</strong>是<code>解耦系统间（单向）</code>的对象关联关系；<strong>Mediator模式</strong>是<code>解耦系统内各个对象之间（双向）</code>的关联关系。</li>
</ul>
<h2 id="“状态变化”模式"><a href="#“状态变化”模式" class="headerlink" title="“状态变化”模式"></a>“状态变化”模式</h2><p>在组件构建过程中，某些<strong>对象的状态</strong>经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？<strong>”状态变化“模式</strong>为这一问题提供了一种解决方案。</p>
<p>典型模式：</p>
<ul>
<li><strong>State</strong></li>
<li><strong>Memento</strong></li>
</ul>
<h3 id="State状态模式"><a href="#State状态模式" class="headerlink" title="State状态模式"></a>State状态模式</h3><h4 id="动机-15"><a href="#动机-15" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如<code>文档处于只读状态</code>，其支持的行为和读写状态支持的行为就可能完全不同。</p>
<h4 id="模式定义-15"><a href="#模式定义-15" class="headerlink" title="模式定义"></a>模式定义</h4><p>允许一个对象在其<code>内部状态改变时改变它的行为</code>。从而使对象看起来似乎修改了其行为。</p>
<h4 id="结构类图-15"><a href="#结构类图-15" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121210733382.png" alt="image-20231121210733382"></p>
<h4 id="要点总结-15"><a href="#要点总结-15" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>State模式将<strong>所有与一个特定状态相关的行为都放入一个State的子类对象中</strong>，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了<strong>具体操作与状态转换之间的解耦</strong>。</li>
<li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证<strong>不会出现状态不一</strong>致的情况，因为转换是<code>原子性的</code>——即要么彻底转换过来，要么不转换。</li>
<li>如果State对象<strong>没有实例变量</strong>，那么各个上下文可以<strong>共享同一个 State对象</strong>，从而节省对象开销。</li>
</ul>
<h3 id="Memento备忘录（过时）"><a href="#Memento备忘录（过时）" class="headerlink" title="Memento备忘录（过时）"></a>Memento备忘录（过时）</h3><h4 id="动机-16"><a href="#动机-16" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够<code>回溯</code>到对象之前处于某个点时的状态。如果使用一些共有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</p>
<h4 id="模式定义-16"><a href="#模式定义-16" class="headerlink" title="模式定义"></a>模式定义</h4><p>在<code>不破坏封装性</code>的前提下，捕获一个对象的内部状态，并在该<code>对象之外</code>保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</p>
<h4 id="结构类图-16"><a href="#结构类图-16" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121221204619.png" alt="image-20231121221204619"></p>
<h4 id="要点总结-16"><a href="#要点总结-16" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>备忘录（<em>Memento</em>）存储原发器（<em>Originator</em>）对象的内部状态，在需要时恢复原发器状态。</li>
<li>Memento模式的核心是<code>信息隐藏</code>，即Originator需要向外接隐藏信息，<code>保持其封装性</code>。但同时又需要将状态<code>保持到外界</code>（<em>Memento</em>）。</li>
<li>由于现代语言运行时（如C#、Java等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的<code>序列化方案</code>来实现Memento模式。</li>
</ul>
<h2 id="”数据结构“模式"><a href="#”数据结构“模式" class="headerlink" title="”数据结构“模式"></a>”数据结构“模式</h2><p>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</p>
<p>典型模式：</p>
<ul>
<li><strong>Composite</strong></li>
<li><strong>Iterator</strong></li>
<li><strong>Chain of Resposibility</strong></li>
</ul>
<h3 id="Composite组合模式"><a href="#Composite组合模式" class="headerlink" title="Composite组合模式"></a>Composite组合模式</h3><h4 id="动机-17"><a href="#动机-17" class="headerlink" title="动机"></a>动机</h4><p>软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</p>
<h4 id="模式定义-17"><a href="#模式定义-17" class="headerlink" title="模式定义"></a>模式定义</h4><p>将对象组合成<code>树形结构</code>以表示<code>”部分-整体“</code>的层次结构。Composite使得用户对单个对象和组合对象的使用<code>具有一致性</code>（稳定）。</p>
<h4 id="结构类图-17"><a href="#结构类图-17" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121223440958.png" alt="image-20231121223440958"></p>
<h4 id="要点总结-17"><a href="#要点总结-17" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Composite模式采用<code>树形结构</code>来实现普遍存在的对象容器，从而将<strong>“一对多”</strong>的关系转化为<strong>“一对一”</strong>的关系，使得客户代码可以<code>一致地</code>（复用）处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。</li>
<li><code>将“客户代码与复杂的对象容器结构”解耦</code>是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的内部实现结构——发生依赖，从而更能“应对变化”。</li>
<li>Composite模式在具体实现中，可以让父对象中的子对象<strong>反向追溯</strong>；如果父对象有频繁的遍历需求，可使用<strong>缓存技巧</strong>来改善效率。</li>
</ul>
<h3 id="Iterator迭代器（面向对象实现已过时）"><a href="#Iterator迭代器（面向对象实现已过时）" class="headerlink" title="Iterator迭代器（面向对象实现已过时）"></a>Iterator迭代器（面向对象实现已过时）</h3><h4 id="动机-18"><a href="#动机-18" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种<strong>“透明遍历”</strong>也为“同一种算法在多种集合对象上进行操作”提供了可能。</p>
<h4 id="模式定义-18"><a href="#模式定义-18" class="headerlink" title="模式定义"></a>模式定义</h4><p>提供一种方法<code>顺序访问</code>一个聚合对象中的各个元素，而又<code>不暴露</code>（稳定）该对象的内部表示。</p>
<h4 id="结构类图-18"><a href="#结构类图-18" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121224544481.png" alt="image-20231121224544481"></p>
<h4 id="要点总结-18"><a href="#要点总结-18" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。</li>
<li>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li>
<li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</li>
</ul>
<h3 id="Chain-of-Resposibility职责链（过时）"><a href="#Chain-of-Resposibility职责链（过时）" class="headerlink" title="Chain of Resposibility职责链（过时）"></a>Chain of Resposibility职责链（过时）</h3><h4 id="动机-19"><a href="#动机-19" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接收者，如果显示指定，将必不可少地带来请求发送者与接收者的紧耦合。</p>
<h4 id="模式定义-19"><a href="#模式定义-19" class="headerlink" title="模式定义"></a>模式定义</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象<code>连成一条链</code>，并沿着这条链传递请求，直到有一个对象处理它为止。</p>
<h4 id="结构类图-19"><a href="#结构类图-19" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231121230805596.png" alt="image-20231121230805596"></p>
<h4 id="要点总结-19"><a href="#要点总结-19" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Chain of Responsibility 模式的应用场合在于“一个请求可能有多个接受者,但是最后真正的接受者只有一个”，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</li>
<li>应用了Chain of Responsibility 模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。</li>
<li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li>
</ul>
<h2 id="“行为变化”模式"><a href="#“行为变化”模式" class="headerlink" title="“行为变化”模式"></a>“行为变化”模式</h2><p>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。”行为变化“模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</p>
<p>典型模式：</p>
<ul>
<li><strong>Command</strong></li>
<li><strong>Visitor</strong></li>
</ul>
<h3 id="Command命令模式（应用不广泛）"><a href="#Command命令模式（应用不广泛）" class="headerlink" title="Command命令模式（应用不广泛）"></a>Command命令模式（应用不广泛）</h3><h4 id="动机-20"><a href="#动机-20" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，”行为请求者“与”行为实现者“通常呈现一种”紧耦合“。但在某些场合——比如需要对行为进行”记录、撤销/重做（undo/redo）、事务“等处理，这种无法抵御变化的紧耦合是不合适的。</p>
<h4 id="模式定义-20"><a href="#模式定义-20" class="headerlink" title="模式定义"></a>模式定义</h4><p>将一个请求（行为）<code>封装为一个对象</code>，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
<h4 id="结构类图-20"><a href="#结构类图-20" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231122001510001.png" alt="image-20231122001510001"></p>
<h4 id="要点总结-20"><a href="#要点总结-20" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Command模式的根本目的在于将<strong>“行为请求者”与“行为实现者”解耦</strong>，在面向对象语言中，常见的实现手段是<code>“将行为抽象为对象”</code>。</li>
<li>实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个“命令”封装为一个<code>“复合命令”MacroCommand</code>。</li>
<li>Command模式与C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的<code>“接口-实现”</code>来定义<br>行为接口规范，更严格，但有性能损失；C++函数对象以<code>函数签名</code>来定义行为接口规范，更灵活，性能更高。</li>
</ul>
<h3 id="Visitor访问器（不常用）"><a href="#Visitor访问器（不常用）" class="headerlink" title="Visitor访问器（不常用）"></a>Visitor访问器（不常用）</h3><h4 id="动机-21"><a href="#动机-21" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。</p>
<h4 id="模式定义-21"><a href="#模式定义-21" class="headerlink" title="模式定义"></a>模式定义</h4><p>表示一个作用于某对象结构中的各元素的操作。使得可以在<code>不改变</code>（稳定）各元素的类的前提下定义（<code>扩展</code>）作用于这些元素的新操作（变化）。</p>
<h4 id="结构类图-21"><a href="#结构类图-21" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231122122555418.png" alt="image-20231122122555418"></p>
<h4 id="要点总结-21"><a href="#要点总结-21" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Visitor模式通过所谓<code>双重分发</code>（<em>double dispatch</em>）来实现在不更改 （不添加新的操作-编译时）Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作（支持变化）。</li>
<li>所谓双重分发即Visitor模式中间包括了<code>两个多态分发</code>（注意其中的多态机制）：第一个为<strong>accept方法的多态辨析</strong>；第二个为 <strong>visitElementX方法的多态辨析</strong>。</li>
<li>Visitor模式的最大<strong>缺点</strong>在于<strong>扩展类层次结构</strong>（增添新的Element子类），<strong>会导致Visitor类的改变</strong>。因此Vistor模式适用于<code>“Element类层次结构稳定，而其中的操作却经常面临频繁改动”</code>。</li>
</ul>
<h2 id="“领域规则”模式"><a href="#“领域规则”模式" class="headerlink" title="“领域规则”模式"></a>“领域规则”模式</h2><p>在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。</p>
<p>典型模式：</p>
<ul>
<li><strong>Interpreter</strong></li>
</ul>
<h3 id="Interpreter解析器（不常用）"><a href="#Interpreter解析器（不常用）" class="headerlink" title="Interpreter解析器（不常用）"></a>Interpreter解析器（不常用）</h3><h4 id="动机-22"><a href="#动机-22" class="headerlink" title="动机"></a>动机</h4><p>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。</p>
<h4 id="模式定义-22"><a href="#模式定义-22" class="headerlink" title="模式定义"></a>模式定义</h4><p>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。</p>
<h4 id="结构类图-22"><a href="#结构类图-22" class="headerlink" title="结构类图"></a>结构类图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231122133536927.png" alt="image-20231122133536927"></p>
<h4 id="要点总结-22"><a href="#要点总结-22" class="headerlink" title="要点总结"></a>要点总结</h4><ul>
<li>Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足<strong>“业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题”</strong>才适合使用Interpreter模式。</li>
<li>使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地<strong>“扩展”</strong>文法。</li>
<li>Interpreter模式比较适合<strong>简单的文法表示</strong>，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于<strong>语法分析生成器</strong>这样的标准工具。</li>
</ul>
<h1 id="重构技法"><a href="#重构技法" class="headerlink" title="重构技法"></a>重构技法</h1><ul>
<li>静态 -&gt; 动态</li>
<li>早绑定 -&gt; 晚绑定</li>
<li>继承 -&gt; 组合</li>
<li>编译时依赖 -&gt; 运行时依赖</li>
<li>紧耦合 -&gt; 松耦合</li>
</ul>
<h1 id="成长之路"><a href="#成长之路" class="headerlink" title="成长之路"></a>成长之路</h1><ul>
<li>“手中无剑，心中无剑”：见模式而不知</li>
<li>“手中有剑，心中无剑”：可以识别模式，作为应用开发人员使用模式</li>
<li>“手中有剑，心中有剑”：作为框架开发人员为应用设计某些模式</li>
<li>“手中无剑，心中有剑”：忘掉模式，只有原则</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">久朝暮</div><div class="post-copyright__author_desc">紫气东来</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://gaoyubo.cn/blogs/1155b381.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://gaoyubo.cn/blogs/1155b381.html')">Cpp设计模式</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://gaoyubo.cn/blogs/1155b381.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Cpp设计模式&amp;url=https://gaoyubo.cn/blogs/1155b381.html&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gaoyubo.cn" target="_blank">久朝暮</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++设计模式<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blogs/3006dc10.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">STL</div></div></a></div><div class="next-post pull-right"><a href="/blogs/713c1ac0.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Cpp11</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/7dbc6721bad89.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">开发、算法、课程总结</b>相关的内容，还有<b style="color:#fff">个人生活</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">久朝暮</h1><div class="author-info__desc">紫气东来</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/zy-zy9" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/479202769" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%90%9C%E4%B8%80%E6%90%9C.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%90%9C%E4%B8%80%E6%90%9Cback.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">设计模式简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">深入理解面向对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.</span> <span class="toc-text">面向对象设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">重新认识面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-1"><span class="toc-number">2.2.</span> <span class="toc-text">面向对象设计原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">模板方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E2%80%9D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">“组件协作”模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-Method%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">Template Method模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strategy%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">Strategy策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-1"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-1"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-1"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observer%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.3.</span> <span class="toc-text">Observer观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-2"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-2"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-2"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.1.3.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E2%80%9D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">“单一职责”模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Decorator%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">Decorator装饰模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-3"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-3"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-3"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-3"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bridge%E6%A1%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">Bridge桥模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-4"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-4"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-4"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-4"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E2%80%9D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">“对象创建”模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Factory-Method%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">Factory Method工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-5"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-5"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-5"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-5"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Abstract-Factory%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="toc-number">3.3.2.</span> <span class="toc-text">Abstract Factory抽象工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-6"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-6"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-6"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-6"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prototype%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">Prototype原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-7"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-7"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-7"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-7"><span class="toc-number">3.3.3.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Builder%E6%9E%84%E5%BB%BA%E5%99%A8%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">3.3.4.</span> <span class="toc-text">Builder构建器（不常用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-8"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-8"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-8"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-8"><span class="toc-number">3.3.4.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%E2%80%9D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">“对象性能”模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Singleton%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">Singleton单件模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-9"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-9"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-9"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-9"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flyweight%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">Flyweight享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-10"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-10"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-10"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-10"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E2%80%9D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">“接口隔离”模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Facade%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">Façade门面模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%97%B4%E8%80%A6%E5%90%88%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">系统间耦合的复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-11"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-11"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-11"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-11"><span class="toc-number">3.5.1.5.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">Proxy代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-12"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-12"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-12"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-12"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Adapter%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">3.5.3.</span> <span class="toc-text">Adapter适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-13"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-13"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-13"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-13"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mediator%E4%B8%AD%E4%BB%8B%E8%80%85%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">3.5.4.</span> <span class="toc-text">Mediator中介者（不常用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-14"><span class="toc-number">3.5.4.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-14"><span class="toc-number">3.5.4.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-14"><span class="toc-number">3.5.4.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-14"><span class="toc-number">3.5.4.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E2%80%9D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">“状态变化”模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#State%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.1.</span> <span class="toc-text">State状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-15"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-15"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-15"><span class="toc-number">3.6.1.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-15"><span class="toc-number">3.6.1.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memento%E5%A4%87%E5%BF%98%E5%BD%95%EF%BC%88%E8%BF%87%E6%97%B6%EF%BC%89"><span class="toc-number">3.6.2.</span> <span class="toc-text">Memento备忘录（过时）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-16"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-16"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-16"><span class="toc-number">3.6.2.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-16"><span class="toc-number">3.6.2.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">”数据结构“模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Composite%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.1.</span> <span class="toc-text">Composite组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-17"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-17"><span class="toc-number">3.7.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-17"><span class="toc-number">3.7.1.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-17"><span class="toc-number">3.7.1.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E5%B7%B2%E8%BF%87%E6%97%B6%EF%BC%89"><span class="toc-number">3.7.2.</span> <span class="toc-text">Iterator迭代器（面向对象实现已过时）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-18"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-18"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-18"><span class="toc-number">3.7.2.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-18"><span class="toc-number">3.7.2.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chain-of-Resposibility%E8%81%8C%E8%B4%A3%E9%93%BE%EF%BC%88%E8%BF%87%E6%97%B6%EF%BC%89"><span class="toc-number">3.7.3.</span> <span class="toc-text">Chain of Resposibility职责链（过时）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-19"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-19"><span class="toc-number">3.7.3.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-19"><span class="toc-number">3.7.3.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-19"><span class="toc-number">3.7.3.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%E2%80%9D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.8.</span> <span class="toc-text">“行为变化”模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Command%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%BA%94%E7%94%A8%E4%B8%8D%E5%B9%BF%E6%B3%9B%EF%BC%89"><span class="toc-number">3.8.1.</span> <span class="toc-text">Command命令模式（应用不广泛）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-20"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-20"><span class="toc-number">3.8.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-20"><span class="toc-number">3.8.1.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-20"><span class="toc-number">3.8.1.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Visitor%E8%AE%BF%E9%97%AE%E5%99%A8%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">3.8.2.</span> <span class="toc-text">Visitor访问器（不常用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-21"><span class="toc-number">3.8.2.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-21"><span class="toc-number">3.8.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-21"><span class="toc-number">3.8.2.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-21"><span class="toc-number">3.8.2.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%E2%80%9D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.9.</span> <span class="toc-text">“领域规则”模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Interpreter%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">3.9.1.</span> <span class="toc-text">Interpreter解析器（不常用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA-22"><span class="toc-number">3.9.1.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-22"><span class="toc-number">3.9.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE-22"><span class="toc-number">3.9.1.3.</span> <span class="toc-text">结构类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-22"><span class="toc-number">3.9.1.4.</span> <span class="toc-text">要点总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E6%8A%80%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">重构技法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF"><span class="toc-number">5.</span> <span class="toc-text">成长之路</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/9a8cdc59.html" title="计算机网络复习">计算机网络复习</a><time datetime="2024-01-05T13:36:41.000Z" title="发表于 2024-01-05 21:36:41">2024-01-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/6fbd99c.html" title="操作系统高级教程思考题">操作系统高级教程思考题</a><time datetime="2023-12-14T14:46:27.000Z" title="发表于 2023-12-14 22:46:27">2023-12-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2d14aaf0.html" title="Linux常用函数">Linux常用函数</a><time datetime="2023-11-30T05:58:58.000Z" title="发表于 2023-11-30 13:58:58">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/b9528813.html" title="Linux系统命令">Linux系统命令</a><time datetime="2023-11-29T00:27:51.000Z" title="发表于 2023-11-29 08:27:51">2023-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/66f88466.html" title="Cpp内存管理">Cpp内存管理</a><time datetime="2023-11-25T06:52:29.000Z" title="发表于 2023-11-25 14:52:29">2023-11-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="/wzy2096@126.com" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/zy-zy9" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/479202769" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.douyin.com/user/self" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a></div><div class="copyright">&copy;2020 - 2024 By 久朝暮</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/album/"><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-STL/" style="font-size: 0.88rem;">C++ STL<sup>1</sup></a><a href="/tags/C-2-0/" style="font-size: 0.88rem;">C++2.0<sup>1</sup></a><a href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">C++内存管理<sup>1</sup></a><a href="/tags/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">C++设计模式<sup>1</sup></a><a href="/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">C++面向对象高级编程<sup>1</sup></a><a href="/tags/Effective-C/" style="font-size: 0.88rem;">Effective C++<sup>1</sup></a><a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" style="font-size: 0.88rem;">Linux常用函数<sup>1</sup></a><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/" style="font-size: 0.88rem;">Linux系统命令<sup>1</sup></a><a href="/tags/UCAS%E8%AF%BE%E7%A8%8B/" style="font-size: 0.88rem;">UCAS课程<sup>2</sup></a><a href="/tags/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%BF%9E%E7%BD%91%E6%8A%80%E6%9C%AF/" style="font-size: 0.88rem;">移动互连网技术<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Tt2yKI8TpkxMniyxFfGh8FX6-gzGzoHsz',
      appKey: '5oQifQ5aHzJHGp2AUh22jSe3',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>