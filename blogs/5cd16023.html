<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>高级AI复习 | 久朝暮</title><meta name="keywords" content="UCAS课程"><meta name="author" content="久朝暮"><meta name="copyright" content="久朝暮"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="高级AI复习"><meta name="application-name" content="高级AI复习"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#ffffff"><meta property="og:type" content="article"><meta property="og:title" content="高级AI复习"><meta property="og:url" content="https://gaoyubo.cn/blogs/5cd16023.html"><meta property="og:site_name" content="久朝暮"><meta property="og:description" content="高级AI复习 3个综合题 前两个15 最后大题 20分 三个简答 30分 选择题 20分 选择题不会选C（沈华伟老师部分） 罗平老师部分 ⊨ 蕴含符号不是一个合法的连接词， a ⊨ b不是一个合法的语言。 Resolution (single rule)归结原理和Modus Ponen"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg"><meta property="article:author" content="久朝暮"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg"><meta name="description" content="高级AI复习 3个综合题 前两个15 最后大题 20分 三个简答 30分 选择题 20分 选择题不会选C（沈华伟老师部分） 罗平老师部分 ⊨ 蕴含符号不是一个合法的连接词， a ⊨ b不是一个合法的语言。 Resolution (single rule)归结原理和Modus Ponen"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://gaoyubo.cn/blogs/5cd16023"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🏃 脚踏实地行动派","👆🏻 专注C++开发"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 久朝暮","link":"链接: ","source":"来源: 久朝暮","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '久朝暮',
  title: '高级AI复习',
  postAI: '',
  pageFillDescription: '高级AI复习, 罗平老师部分, 关于思考的终极算法, 逻辑研究的内容, 蕴涵（Entailment）重要概念, 连接词的引入：是为了方便进行知识表示, 逻辑等价（≡）, 命题逻辑中的知识库 𝐾𝐵, Entailment与implication的区别, 奇怪小岛（考知识表示）, 奇怪小岛上的逻辑问题, 推理问题1, C是骑士还是无赖？——骑士, 把思考过程机械化, 归结原理, 字句型, 基本思想, 归结反演, 归结原理的可靠性和完备性, Hron子句与Definite子句, Modus Ponens, Prolog, 5的阶乘, 斐波那契数列, 搜索, Tree search, General tree search框架, Graph search框架, 搜索策略, Informed Search（启发式搜索）, 最佳优先搜索, A* 搜索, 可容许性证明, A* 算法最优性证明, 连结主义, Single-variable Prediction, Neural Networks, 沈华伟老师部分, 三大分支学派, 图灵测试, 在人工智能水平测试中如果某项人工智能通过了图灵测试则表示其智能水平：从表现来看难以将其和人区分开来, 基本原理, 构成要素, 算法过程, 粒子速度更新公式解读, 算法终止条件, 适用范围, 多臂赌博机, 利用和探索, 策略学习, 博弈论, 博弈的要素, 田忌赛马中田忌的策略集合, 囚徒困境, 纳什均衡, 帕累托最优, 社会最优, 拍卖, 首价密封报价拍卖, 次价密封报价拍卖, 讨价, maxmin策略和minmax策略, 匹配市场, 最优匹配, 价格导向的匹配, 议价权, 网络中节点位置的重要性, 结局的稳定性, 纳什议价解, 因果模型图𝒅 -分离, 后门准则, （简答）图神经网络（GNNs）--自己总结, GNNs的能力：一个经验观点, 关于表达能力, GNNs的两个典型任务, 节点分类, 图分类, （押）GNNs的表达能力能否通过提高深度而无限提高？有界限吗？, （综合题）强化学习：格子游戏(突破：5个格子)高级复习个综合题前两个最后大题分三个简答分选择题分选择题不会选沈华伟老师部分罗平老师部分蕴含符号不是一个合法的连接词不是一个合法的语言归结原理和都非常重要把变成合取范式可能考不考谓词逻辑不考可靠性和完备性证明会考一点代码一定能推出正确的东西嘛写的阶层斐波那契数列关于思考的终极算法逻辑研究的内容研究形式化定义的之间的关系两个角度语义蕴含逻辑推导语法演绎形式推演完备性可靠性蕴涵重要概念蕴涵表示一件事情可以从另一件事情推导出来如果当且仅当在所有为真的情况中才为真连接词的引入是为了方便进行知识表示看成同或逻辑等价如果两个句子在相同的模型中为真则它们在逻辑上是等价的命题逻辑中的知识库满足命题逻辑语法的的集合假设这组中一共有个原子命题真值指派对每个原子名字赋值一共有种真值指派其中使得中的每个都为真的真值指派就是的在此基础上在命题逻辑中我们可以明确的定义枚举行对符号的不同赋值如果行中为真检查是否也为真与的区别蕴涵逻辑上的概念描述两组句子之间的关系蕴涵命题之间的一种运算符用于知识表示和都可以用否合取析取来表示那么定义和这两种连接词有何用途呢蕴涵表示一个命题的逻辑结构其中一个命题的成立暗示着另一个命题的成立在条件语句中如果前提成立则结论也成立在逻辑推理和知识表示中起到重要作用帮助建立因果关系和推导结论双条件表示两个命题之间的等价关系即两者要么同时成立要么同时不成立通常用于表达两个命题具有相同的真值在知识表示中它用于说明两个概念或条件是等同的这两种连接词在逻辑学和计算机科学中有广泛的应用帮助表示复杂的关系和逻辑结构和提供了一种形式化的方式来描述命题之间的关系支持逻辑推理和知识表示的表达有效性和可满足性一个句子在所有模型中都为真时是有效的例如有效性通过演绎定理与推理相关如果那么当且仅当是有效的一个句子在某些模型中为真时是可满足的例如一个句子在没有模型中为真时是不可满足的例如可满足性通过以下方式与推理联系起来如果那么当且仅当是不可满足的即通过归谬法证明注表示的句子是这里是是中的所有句子奇怪小岛考知识表示奇怪小岛上的逻辑问题埃德加艾伯克朗比是一位人类学家他对说谎和说真话的逻辑和社会学特别感兴趣有一天他决定去参观骑士和无赖的岛在那里那些被称为骑士的人总是说真话而无赖总是撒谎此外每个居民不是骑士就是无赖获取关键信息骑士总是说真话无赖总是撒谎每个居民不是骑士就是无赖推理问题在他到达的那一天艾伯克朗比遇到了三名居民我们将称之为和他问你是骑士还是无赖回答了但回答不清楚以至于艾伯克朗比听不清他说了什么然后他问他说了什么回答说他说他是无赖此时插嘴说不要相信那个那是个谎言是骑士还是无赖骑士思考过程或者是骑士只说真话或者是无赖只说假话二者必居其一假如是骑士他不可能说自己是无赖因为那不是事实假如是无赖也同样不可能说自己是无赖因为那是真话所以说的话不可能是我是无赖因此说的不是事实他必然是无赖因此说的是事实结论是骑士可以是任何人实际上可以知道这个岛上不会有任何人说自己是无赖没说话就可以判定是无赖把思考过程机械化知识表示将一组知识形式化为符号第个人是骑士第个人是无赖第个人说了一句话当前的知识库说说的话是是无赖说在撒谎画出真值表根据蕴含的定义有归结原理字句型原子谓词公式及其否定统称为文字例如等都是文字任何文字的析取式称为子句例如都是子句不含任何文字的子句称为空子句由于空子句不含有任何文字也就不能被任何解释所满足因此空子句是永假的不可满足的由子句或空子句所构成的集合称为子句集定理设有谓词公式其标准子句集为则为不可满足的充要条件是可满足的基本思想由谓词公式转化为子句集的方法可以知道在子句集中子句之间是合取关系其中只要有一个子句为不可满足则整个子句集就是不可满足的另外前面已经指出空子句是不可满足的因此一个子句集中如果包含有空子句则此子句集就一定是不可满足的首先把欲证明问题的结论否定并加入子句集得到一个扩充的子句集然后设法检验子句集是否含有空子句若含有空子句则表明是不可满足的若不含有空子句则继续使用归结法在子句集中选择合适的子句进行归结直至导出空句子或不能继续归结为止归结反演在命题逻辑中已知证明为真的归结反演过程如下否定目标公式得把并入到公式集中得到把化为子句集应用归结原理对子句集中的子句进行归结并把每次得到的归结式并入中如此反复进行若出现空子句则停止归结此时就证明了为真归结原理的可靠性和完备性归结原理的可靠性语义上推演得到的知识在语法上正确利用真值表保证归结的过程是正确的即可推理规则是可靠的归结原理的完备性如果语法上能够推演得到那么语义上正确归结原理的完备性证明即证明如果那么因为等价于永假即是不可满足的而等价于可以归结出空子句即包含空子句因此只要证明如果是不可满足的则包含空子句等价于证明逆否命题即如果不包含空子句那么是可满足的针对中的原子命题构造首先因为不包含空子句即不包含永假的句子从到顺序的指派的真值如果中包含一个子句此子句包含且此子句的其它文字都已经被指派为在之前的步骤中进行的或不包含其它文字则把指派为否则把指派为用反证法证明这个真值指派使得中的字句都为真假设在此过程的第步我们这样来指派使得某个子句为且假设这是首次出现的子句此时子句只能是如下两种形式之一或者显然如果中只包含以上两个子句之一子句是不会在此真值指派中为的因此此时应该同时包含了以上两个子句以上两个子句显然是满足归结条件的也就是说它归结后的子句也应该在中同时该子句已经被指派为了这与我们之前的假设矛盾子句与子句限定子句恰好只含一个正文字的析取式子句至多只有一个正文字的析取式每个限定子句都可以被写作蕴含式它的前提是正文字的合取式结论为单个正文字使用子句的推理可以使用前向链接和反向链接规则规则是可靠的即证明用真值表证明即可完备性证明证明若则表示所有中的原始子句以及用规则所能推理出的所有子句构造如下真值指派对于任意变量指派为当且仅当使用反证法证明在下为真假设此时为则必然存在一个限定子句在下为若该子句为也就是说在中均且为根据定义又根据规则而根据先前的定义应该为因此矛盾若该子句为在下为为则矛盾若根据蕴涵定义在中为真根据前面定义也就是说一定能推出正确的东西嘛是一种逻辑编程语言其基于一阶谓词演算的主要特点是使用逻辑规则和事实来表示问题通过向系统提供问题描述可以进行逻辑推理和搜索寻找问题的解然而并不总是能保证返回正确的结果的推理过程依赖于用户提供的逻辑规则和事实以及查询时所使用的目标如果用户提供的逻辑规则或事实存在错误或者查询目标设置得不当可能会产生不正确的结果的推理过程也可能受到计算机的限制和资源限制的影响在处理复杂问题时搜索空间可能会变得非常庞大导致计算效率下降或者算法无法找到解决方案的阶乘基本情况的阶乘是递归规则计算的阶乘在这个例子中是一个谓词接受两个参数第一个参数是要计算阶乘的数字第二个参数是计算得到的阶乘结果查询结果应该是这段代码使用递归定义了阶乘并在基本情况为时返回斐波那契数列基本情况前两个斐波那契数是递归规则计算第个斐波那契数在这个例子中是一个谓词接受两个参数第一个参数是要计算的斐波那契数的索引第二个参数是计算得到的斐波那契数通过查询谓词来计算斐波那契数列中的第个数查询结果应该是表示斐波那契数列中第个数是搜索算法框架要记住通过下面四个来评估算法的好坏非常重要与和比较考试难点一定要记住和一定要记住要掌握什么是模拟退火算法从初始状态开始扩展当前状态搜索的本质是现在跟进一个选择把其他的放在一边问题策略返回一个解决方案或失败使用问题的初始状态初始化搜索树循环直到结束如果没有可扩展的候选节点则返回失败根据策略选择一个叶子节点进行扩展如果节点包含目标状态则返回相应的解决方案否则扩展节点并将生成的节点添加到搜索树中结束所有的搜索算法都共享这种树状搜索结构它们的变化主要取决于它们如何选择要扩展的状态即所谓的搜索策略框架初始化算法开始时将初始状态对应的节点加入到搜索边界中这个节点包含了初始状态的信息主循环进入一个无限循环直到找到解决方案或搜索边界为空搜索边界非空检查检查搜索边界是否为空如果为空表示无法找到解决方案算法返回失败节点选择从搜索边界中选择一个节点通常是按照某种优先级选择的例如广度优先深度优先最佳优先等目标测试检查当前选取的节点是否满足问题的目标测试如果满足算法返回当前节点作为解决方案节点扩展对当前节点进行扩展操作生成可能的后继节点这一步可能会根据问题的具体性质进行不同的扩展例如在搜索树的分支更新搜索边界将生成的后继节点加入搜索边界中以便在下一次循环中进行探索结束如果成功找到解决方案则返回解决方案的节点如果搜索边界为空且没有找到解决方案则算法返回失败这个函数用于扩展给定的节点并返回一个节点集合表示由该节点可以到达的所有后继节点对于每个可能的动作和其结果创建一个新节点设置其父节点动作状态路径成本和深度并将其添加到后继节点集合中最后返回后继节点集合这个搜索算法采用迭代深化的深度优先搜索策略通过不断扩展当前搜索树的深度直到找到解决方案或搜索完整个树在搜索的过程中使用边界来存储待扩展的节点从而实现深度优先的搜索框架不同于不同于不同于初始化首先创建一个空的集合用于记录已经访问过的状态不同处然后将初始状态对应的节点加入到搜索边界中主循环进入一个无限循环直到找到解决方案或搜索边界为空搜索边界非空检查检查搜索边界是否为空如果为空表示无法找到解决方案算法返回失败节点选择从搜索边界中选择一个节点通常是按照某种优先级选择的例如广度优先深度优先最佳优先等目标检测检查当前选取的节点是否满足问题的目标测试如果满足算法返回当前节点作为解决方案重复状态检查检查当前节点的状态是否已经在中如果不在表示是一个新状态将其加入不同处节点扩展对当前节点进行扩展操作生成可能的后继节点这一步可能会根据问题的具体性质进行不同的扩展例如在搜索图的顶点更新搜索边界将生成的后继节点加入搜索边界中以便在下一次循环中进行探索结束如果成功找到解决方案则返回解决方案的节点如果搜索边界为空且没有找到解决方案则算法返回失败搜索策略一种策略由选择节点扩展的顺序来定义策略可以通过以下维度进行评估完备性是否总是能够找到解决方案如果存在的话时间复杂度生成扩展的节点数空间复杂度内存中的最大节点数最优性是否总是能够找到成本最低的解决方案时间和空间复杂度是以以下标准来衡量的搜索树的最大分支因子最小成本解决方案的深度状态空间的最大深度可能为非启发式搜索宽度优先搜索先进先出队列更快更大的内存时间复杂度深度宽度则时间复杂度空间复杂度深度优先搜索后进先出队列栈内存少速度慢时间复杂度指任意节点地最大深度空间复杂度空间复杂度低回溯搜索深度优先搜索地一个变种空间复杂度更低统一代价搜索优先级队列以最小成本为出队准则如果步长成本相等则等于宽度优先启发式搜索最佳优先搜索是一般树搜索和图搜索的一个实例节点是结语评价函数被选择扩展的评价函数是代价估计品估值最低的节点被选择首先进行扩展与一致代价搜索类似最佳优先是而不是对优先级队列排队由启发函数构成节点到目标节点的最小代价路径的代价估计值贪婪最佳优先搜索试图扩展离目标最近的节点这样可以很快找到解最坏情况下时间和空间复杂度都是搜索结合和即经过节点的最小代价解的估计代价搜索的可采纳性和一致性可采纳启发式可容许性可采纳启发式是指对于搜索问题的每个状态启发式函数对从该状态到目标状态的估计不超过实际最短路径的估计换句话说如果是一个可采纳启发式那么对于每个状态都满足以下不等式实际从到目标的最短路径的代价在路径搜索算法中可采纳启发式通常用于引导算法朝着更有可能导致最优解的方向搜索直线距离是可采纳的启发式两点之间直线最短所以用直线距离肯定不会高估一致性单调性一致启发式是指对于搜索问题的每一对相邻的状态和其后继节点满足以下不等式其中是从状态经过动作到达的实际代价简而言之一致启发式保证在搜索过程中从一个状态到达其后继节点的路径代价不会小于启发式函数对该节点的估计一致的启发函数都是可容许的反之不成立可采纳启发式是一种特殊的一致启发式即当时一致启发式就是可采纳启发式一致启发式通常用于等搜索算法以保证算法的最优性可容许性证明假设最佳路径上有个节点考虑的情况就是目标节点则有更一般的情况假设在最优路径上离目标节点还有步并且是可容许的则有算法最优性证明算法的最优性证明基于其使用的启发式函数是可容许的设是算法在某个时刻从中选择扩展的节点令为从初始节点到节点的实际路径成本为从节点到目标节点的启发式估计假设存在一条路径到达目标节点其代价为这个路径可以被划分为多个段每个段由一个节点和其后继节点以及对应的动作组成可容许性由于启发式函数是可容许的对于任何节点都有选择最小代价节点算法在选择节点进行扩展时会选择具有最小的评估函数值的节点因此对于节点有对于扩展的节点当算法扩展节点时会将其后继节点加入到中且因此节点的评估函数值对于节点其评估函数值为目标节点的情况当目标节点被扩展时算法会终止由于启发式函数的可容许性且由于算法的选择和扩展节点的规则以及启发式函数的可容许性我们可以得出结论算法在搜索过程中选择和扩展节点的顺序保证了它找到的解决方案具有最小的代价因此算法是最优的模拟退火算法模拟退火算法是一种启发式优化算法灵感来源于固体物体的退火过程在固体物体退火过程中通过加热和逐渐冷却物体的分子结构会逐渐趋于平衡状态类似地在模拟退火算法中通过接受一些差距更大的解有助于跳出局部最小值并在搜索空间中找到全局最优解如果该移动视情况改善则该移动被接收否则算法以某个小于的概率接收该移动如果移动导致状态变坏概率则成指数级下降评估值变坏接受坏解决方案的概率随减小如果让温度下降得足够慢算法找到全局最优解得概率逼近于剪枝到目前为止路径上发现的的最佳到目前为止路径上发现的的最佳剪枝先辈层后继层剪枝后继层先辈层连结主义优化目标函数是什么怎么优化怎么去预测前馈神经网络卷积神经网络循环神经网络计算图分别是什么如何优化梯度下降算法在任意图自动求梯度的算法非常重要反向传播考试来考一下沈华伟老师部分三大分支学派行为主义学派联结主义学派符号主义学派图灵测试一个人在完全不接触对方和的情况下和对方进行一系列的问答如果在相当长时间内他无法根据这些问题判断对方是人还是计算机那么就认为该计算机具有同人相当的智能即计算机是能思维的在人工智能水平测试中如果某项人工智能通过了图灵测试则表示其智能水平从表现来看难以将其和人区分开来简答粒子群优化算法基本原理一种随机优化方法通过粒子群在解空间中进行搜索寻找最优解适应度最大的解构成要素粒子群每个粒子对应所求解问题的一个可行解粒子通过其位置和速度表示粒子在第轮的位置粒子在第轮的速度记录粒子的历史最好位置全局历史最好位置计算适应度的函数适应度算法过程初始化初始化粒子群每个粒子的位置和速度即和粒子的历史最好位置和全局历史最好位置循环执行如下三步直至满足结束条件计算每个粒子的适应度更新每个粒子历史最好适应度及其相应的位置更新当前全局最好适应度及其相应位置更新每个粒子的速度和位置粒子速度更新公式解读惯性项保持原速度不变的倾向记忆项回到历史最好位置的倾向社会项走向粒子群全局最好位置的倾向权重参数一般取值为随机参数和之间的随机数算法终止条件迭代的轮数最佳位置连续未更新的轮数适应度函数的值到达预期要求适用范围适用于求解连续解空间的优化问题多臂赌博机一台赌博机有多个摇臂每个摇臂摇出的奖励大小不确定玩家希望摇固定次数的臂所获得的期望累积奖励最大多臂赌博机的优化目标是最大化累计期望收益贪心策略优化的目标是当前行为的期望收益在贪心策略中有一个探索和利用的权衡贪心策略以的概率选择进行探索随机选择一个摇臂而以的概率选择进行利用选择目前被认为是最好的摇臂这意味着随着摇臂次数的增加贪心策略不会收敛到贪心策略而是会一直保持一定程度的探索以便发现更好的摇臂策略随着摇臂次数的增加最终会收敛到贪心策略利用和探索利用按照贪心策略进行选择即选择最大的行为优点最大化即时奖励缺点由于只是对的估计估计的不确定性导致按照贪心策略选择的行为不一定是最大的行为探索选择贪心策略之外的行为优点长期奖励会比较高通过探索可以找出奖励更大的行为供后续选择缺点短期奖励会比较低每步选择在利用和探索中二选一如何平衡利用和探索是关键策略学习动态规划方法蒙特卡洛方法时序差分方法参数近似方法穷尽搜索方法记住下面四个方法计算状态估值函数时的示意图选择题博弈论博弈的要素局中人在博弈中有权决定自己行动方案的博弈参加者局中人不一定是具体的人博弈中利益完全一致的参与者只能看成一个局中人重要假设局中人是自私的理性人不存在侥幸心理不可能利用其它局中人的失误来扩大自己的利益以最大化个人利益为目的田忌赛马中田忌的策略集合上中下上下中中上下中下上下上中下中上囚徒困境局中人两个囚徒策略抗拒坦白效用函数矩阵抗拒坦白抗拒坦白纳什均衡坦白坦白一方保持策略不变坦白另一方如果改变策略抗拒其效用会降低从变成纳什均衡策略组合坦白坦白不是帕累托最优帕累托最优的决策组合一共有个坦白抗拒抗拒坦白抗拒抗拒社会最优策略组合是抗拒抗拒纳什均衡纳什均衡定义如果一个局势下每个局中人的策略都是相对其他局中人当前策略的最佳应对则称该局势是一个纳什均衡纳什均衡就是博弈的一个均衡解是一个僵局即给定其他人不动没有人有动的积极性谁动谁吃亏帕累托最优对于一组策略选择局势若不存在其他策略选择使所有参与者得到至少和目前一样高的回报且至少一个参与者会得到严格较高的回报则这组策略选择为帕累托最优社会最优使参与者的回报之和最大的策略选择局势社会最优的结果一定也是帕累托最优的结果帕累托最优不一定是社会最优拍卖首价密封报价拍卖纳什均衡每个竞拍者的报价低于其对商品的估价最优报价低于估价竞拍者越多报价越接近于估价次价密封报价拍卖纳什均衡每个竞拍者会倾向于采用其对商品的估价进行报价讨价卖家和买家之间的博弈讨价的对象是双方对商品估价之差策略和策略策略最大化自己最坏情况时的收益策略最小化对手的最大收益零和博弈情况下和是对偶的策略和策略等价于纳什均衡策略匹配市场最优匹配匹配的效用成功匹配的估价之和称为匹配的效用最优匹配效用最大的匹配最优匹配对于个体而言不一定最优甚至是最差的价格导向的匹配价格导向的匹配问题的形式化表示估价不低于价格时买方可以接受如果则买方可以接受卖方的价格如果成交买方获得的效用是对于买方如果使其效用最大的卖方是那么在二部图中添加一条由指向的边对于同一个买方如果有多个卖方使其效用最大则添加多条边最终得到一个买方偏好图示例议价权网络中节点位置的重要性节点在网络中所处的位置不同导致其在博弈中的权利不同结局的稳定性不稳定边对于结局中未参与配对的边如果边的两个端点获得的收益之和小于则称这条边为不稳定边不稳定边的存在意味着其两个端点可以通过改变报价而改变结局稳定结局如果一个结局中不存在不稳定边则称该结局为稳定结局纳什议价解议价的对象如何分配剩余价值纳什议价解的收益是的收益是均衡结局给定一个结局如果结局中的任意一个参与配对的边都满足纳什议价解的条件则称该结局是均衡结局注意均衡结局一定是稳定结局因此在寻找均衡结局时可以先寻找稳定结局进而确定均衡结局因果模型图分离分离用于确定因果模型图中任意一对节点是否独立一条路径会被一组节点阻断当且仅当路径包含链结构或分叉结构且中间节点在中或路径包含一个对撞结构且对撞节点及其子孙节点都不在中如果一组节点阻断了和间的每一条路径则和在的条件下是分离的即有一个阻断节点就足以阻断整条路径以下一组变量是否能形成变量与的分离后门准则给定因果模型图中一对有序变量若变量集合满足阻断了与之间的每条含有指向的路径换个理解就是阻断和之间的后门路径中没有的后代节点换个理解就是保持从到的因果路径不变则称满足关于的后门准则后门路径如果一条连接和的路径中有指向的箭头则这条路径被称为从到的后门路径找出满足变量对的后门准则的变量集简答图神经网络自己总结图神经网络取得了显著的成功在节点分类链接预测和图分类方面实现最先进的经验性能新型的设计主要基于经验直觉启发式和实验试错我们缺乏对的性质和局限性的理论认识一个基本问题是的表达能力的能力一个经验观点用于量子化学的利用预测分子的量子特性传统的方法如密度泛函理论是计算昂贵的基于的玻璃系统动力学建模关于表达能力可能出现的不同事件的数目的表达能力是例如能够区分种不同的状态给定不超过瓶水其中一瓶是有毒的最多需要只老鼠来识别哪一瓶是有毒的近似能力单层感知器的表达能力单层感知器不是一个通用的近似器例如异或不能被单层感知器近似多层感知器为我们提供了一个通用的近似器通用近似定理随着层数增加表达能力呈指数级增长的两个典型任务图的两个典型任务节点分类图分类节点分类给一个小型示例层图卷积网络层表达能力有限不能完全区分所有节点层层可以完全区分这个小型示例中的所有节点的深度很重要图分类图分类性能的高表达能力是否意味着在下游任务例如图分类中会有良好的性能高表达能力并不总是带来良好的性能注意低表达能力总是意味着较差的性能押的表达能力能否通过提高深度而无限提高有界限吗的表达能力无法通过无限增加深度来无限提升对的表达能力存在上限随着深度的增加它们确实变得更具表达能力能够捕捉复杂的图结构然而这种提升是有限的最近的研究表明具有固定有限深度的可能无法表达某些图属性而且它们的表达能力可能在一定深度之后饱和这个限制通常被称为或它指出具有特定架构如图同构网络的具有有限的表达能力无法区分某些非同构图测试为基于聚合的的表达能力提供了一个上限是一种最强大的基于聚合的层感知器多层感知器均值池最大池池总和综合题强化学习格子游戏突破个格子',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-18 15:43:33',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">久朝暮</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/album/"><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-STL/" style="font-size: 1.05rem;">C++ STL<sup>1</sup></a><a href="/tags/C-2-0/" style="font-size: 1.05rem;">C++2.0<sup>1</sup></a><a href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">C++内存管理<sup>1</sup></a><a href="/tags/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">C++设计模式<sup>1</sup></a><a href="/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">C++面向对象高级编程<sup>1</sup></a><a href="/tags/Effective-C/" style="font-size: 1.05rem;">Effective C++<sup>1</sup></a><a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" style="font-size: 1.05rem;">Linux常用函数<sup>1</sup></a><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">Linux系统命令<sup>1</sup></a><a href="/tags/UCAS%E8%AF%BE%E7%A8%8B/" style="font-size: 1.05rem;">UCAS课程<sup>4</sup></a><a href="/tags/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%BF%9E%E7%BD%91%E6%8A%80%E6%9C%AF/" style="font-size: 1.05rem;">移动互连网技术<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BD%E7%A7%91%E5%A4%A7%E8%AF%BE%E7%A8%8B/" itemprop="url">国科大课程</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/UCAS%E8%AF%BE%E7%A8%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>UCAS课程</span></a></span></div></div><h1 class="post-title" itemprop="name headline">高级AI复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-01-18T05:41:14.000Z" title="发表于 2024-01-18 13:41:14">2024-01-18</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-01-18T07:43:33.580Z" title="更新于 2024-01-18 15:43:33">2024-01-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">10.1k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://gaoyubo.cn/blogs/5cd16023.html"><header><a class="post-meta-categories" href="/categories/%E5%9B%BD%E7%A7%91%E5%A4%A7%E8%AF%BE%E7%A8%8B/" itemprop="url">国科大课程</a><a href="/tags/UCAS%E8%AF%BE%E7%A8%8B/" tabindex="-1" itemprop="url">UCAS课程</a><h1 id="CrawlerTitle" itemprop="name headline">高级AI复习</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">久朝暮</span><time itemprop="dateCreated datePublished" datetime="2024-01-18T05:41:14.000Z" title="发表于 2024-01-18 13:41:14">2024-01-18</time><time itemprop="dateCreated datePublished" datetime="2024-01-18T07:43:33.580Z" title="更新于 2024-01-18 15:43:33">2024-01-18</time></header><h1 id="高级ai复习">高级AI复习</h1>
<p>3个综合题 前两个15 最后大题 20分</p>
<p>三个简答 30分</p>
<p>选择题 20分</p>
<p>选择题不会选C（沈华伟老师部分）</p>
<h1 id="罗平老师部分">罗平老师部分</h1>
<p>⊨ 蕴含符号不是一个合法的连接词， a ⊨ b不是一个合法的语言。</p>
<p>Resolution (single rule)归结原理和Modus Ponens for Definite
Clauses都非常重要。</p>
<p>把sentence变成合取范式可能考。</p>
<p>Datalog不考。</p>
<p>谓词逻辑不考可靠性和完备性证明。</p>
<p>Prolog会考一点代码。Prolog一定能推出正确的东西嘛？</p>
<p>Prolog写5的阶层，斐波那契数列。</p>
<h2 id="关于思考的终极算法">关于思考的“终极算法”</h2>
<ul>
<li><strong>Knowledge base</strong> = set of <strong>sentences</strong>
in a <strong>formal</strong> language</li>
<li><strong>KB</strong>（Knowledge base）</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240111181953065.png" alt="image-20240111181953065">
<figcaption aria-hidden="true">image-20240111181953065</figcaption>
</figure>
<h2 id="逻辑研究的内容">逻辑研究的内容</h2>
<ul>
<li>研究形式化定义的 sentences 之间的关系</li>
<li>两个角度：
<ul>
<li><strong>语义：entailment
蕴含（<code>⊨</code>​），逻辑推导</strong></li>
<li><strong>语法：inference
演绎（<code>⊢</code>​），形式推演</strong></li>
</ul></li>
<li>⊆ (完备性)</li>
<li>⊇ (可靠性)</li>
</ul>
<h3 id="蕴涵entailment重要概念">蕴涵（Entailment）重要概念</h3>
<p>蕴涵表示一件事情可以从另一件事情推导出来：</p>
<ul>
<li>如果<code>𝐾𝐵 ⊨ 𝛼</code>当且仅当在所有 𝐾𝐵 为真的情况中 𝛼 才为真</li>
</ul>
<h3 id="连接词的引入是为了方便进行知识表示">连接词的引入：是为了方便进行知识表示</h3>
<ul>
<li><span class="math inline">\(S_1\)</span> ⟹ <span class="math inline">\(S_2\)</span> is true if <span class="math inline">\(S_1\)</span>is false or <span class="math inline">\(S_2\)</span> is true
<ul>
<li>i.e., is false if <span class="math inline">\(S_1\)</span>is true
and<span class="math inline">\(S_2\)</span>is false</li>
</ul></li>
<li><span class="math inline">\(S_1\)</span> ⟺ <span class="math inline">\(S_2\)</span> is true if <span class="math inline">\(S_1\)</span> ⟹ <span class="math inline">\(S_2\)</span> is true and <span class="math inline">\(S_2\)</span> ⟹ <span class="math inline">\(S_1\)</span> is true（看成同或）</li>
</ul>
<h3 id="逻辑等价">逻辑等价（≡）</h3>
<p>如果两个句子在相同的模型中为真，则它们在<strong>逻辑上是等价</strong>的：</p>
<ul>
<li><code>α ≡ β if and only if α ⊨ β and β ⊨ α</code></li>
</ul>
<h3 id="命题逻辑中的知识库-𝐾𝐵">命题逻辑中的知识库 𝐾𝐵</h3>
<ul>
<li>𝐾𝐵：满足命题逻辑语法的 sentence 的集合</li>
<li>假设：这组 sentence 中，一共有n个原子命题</li>
<li>真值指派（truth assignment）：对每个原子名字赋值</li>
<li>一共有 <span class="math inline">\(2^n\)</span>
种真值指派，其中：使得 𝐾𝐵 中的每个 sentence 都为真的真值指派，就是 𝐾𝐵 的
model</li>
<li>在此基础上，在命题逻辑中，我们可以明确的定义<code>𝐾𝐵 ⊨ 𝛼</code></li>
<li>枚举行（对符号的不同赋值），如果行中 𝐾𝐵 为真，检查 𝛼 是否也为真</li>
</ul>
<h3 id="entailment与implication的区别">Entailment与implication的区别</h3>
<ul>
<li>Entailment（⊨蕴涵）：逻辑上的概念，描述两组sentence（句子）之间的关系</li>
<li>Implication（⟹蕴涵）：命题之间的一种运算符，<code>用于知识表示</code></li>
</ul>
<h3 id="implication和biconditional都可以用negation否-conjunction合取-disjunction析取来表示那么定义implication和biconditional这两种连接词有何用途呢">implication（⟹）和biconditional（⟺）都可以用negation（否）,
conjunction（合取）,
disjunction（析取）来表示，那么，定义implication和biconditional这两种连接词有何用途呢？</h3>
<ul>
<li><p><strong>Implication（蕴涵）</strong>：表示一个命题的逻辑结构，其中一个命题的成立暗示着另一个命题的成立。在条件语句中，如果前提成立，则结论也成立。Implication在逻辑推理和知识表示中起到重要作用，<strong>帮助建立因果关系和推导结论</strong>。</p></li>
<li><p><strong>Biconditional（双条件）</strong>：表示两个命题之间的等价关系，即两者要么同时成立，要么同时不成立。Biconditional通常用于表达两个命题具有相同的真值。在知识表示中，它<strong>用于说明两个概念或条件是等同的</strong>。</p></li>
<li><p>这两种连接词在逻辑学和计算机科学中有广泛的应用，帮助表示复杂的关系和逻辑结构。
Implication和Biconditional<strong>提供了一种形式化的方式来描述命题之间的关系，支持逻辑推理和知识表示的表达</strong>。</p></li>
</ul>
<h3 id="validity-有效性和satisfiability-可满足性">Validity
(有效性)和Satisfiability (可满足性)</h3>
<ul>
<li>一个句子在<strong>所有模型中</strong>都为真时是<code>有效的</code>，例如：𝑇𝑟𝑢𝑒,
𝐴∨¬𝐴, 𝐴⟹𝐴, (𝐴∧(𝐴⇒𝐵))⟹𝐵
<ul>
<li>有效性通过<code>演绎定理</code>与推理相关：</li>
<li>如果 𝐾𝐵 ⊨𝛼 那么当且仅当 (𝐾𝐵 ⟹ 𝛼) 是有效的</li>
</ul></li>
<li>一个句子在<strong>某些模型中</strong>为真时是<code>可满足的</code>，例如：𝐴∨𝐵,
𝐶</li>
<li>一个句子在<strong>没有模型中</strong>为真时是<code>不可满足的</code>，例如：𝐴∧¬𝐴
<ul>
<li>可满足性通过以下方式与推理联系起来：</li>
<li>如果 𝐾𝐵 ⊨ 𝛼 那么当且仅当（𝐾𝐵⋀¬𝛼）是不可满足的</li>
<li>即通过<code>归谬法</code>证明 𝛼</li>
</ul></li>
<li>注：（KB ⟹ α）表示的句子是（<span class="math inline">\(𝛼_1\)</span>⋀ ⋯ <span class="math inline">\(𝛼_k\)</span> ⟹ α)，这里是<span class="math inline">\(𝛼_1\)</span>⋯ <span class="math inline">\(𝛼_k\)</span>是KB中的所有句子</li>
</ul>
<h2 id="奇怪小岛考知识表示">奇怪小岛（考知识表示）</h2>
<h3 id="奇怪小岛上的逻辑问题">奇怪小岛上的逻辑问题</h3>
<p>埃德加·艾伯克朗比是一位人类学家，他对说谎和说真话的逻辑和社会学特别感兴趣。有一天，他决定去参观骑士和无赖的岛，在那里，那些被称为<strong>骑士的人总是说真话</strong>，而<strong>无赖总是撒谎</strong>。此外，<strong>每个居民不是骑士就是无赖</strong>。</p>
<p>获取关键信息：</p>
<ul>
<li><strong>骑士总是说真话</strong></li>
<li><strong>无赖总是撒谎</strong></li>
<li><strong>每个居民不是骑士就是无赖</strong></li>
</ul>
<h3 id="推理问题1">推理问题1</h3>
<ul>
<li>在他到达的那一天，艾伯克朗比遇到了三名居民，我们将称之为A、B和C。</li>
<li>他问A：“你是骑士还是无赖？”
A回答了，但回答不清楚，以至于艾伯克朗比听不清他说了什么。然后，他问B：“他说了什么？”
B回答说：“他说他是无赖。”
此时，C插嘴说：“不要相信那个，那是个谎言！”</li>
</ul>
<h4 id="c是骑士还是无赖骑士">C是骑士还是无赖？——骑士</h4>
<p>思考过程：</p>
<ol type="1">
<li><p>A或者是骑士（只说真话），或者是无赖（只说假话），二者必居其一。</p></li>
<li><p>假如A是骑士，他不可能说自己是无赖，因为那不是事实。</p></li>
<li><p>假如A是无赖，也同样不可能说自己是无赖，因为那是真话。</p></li>
<li><p>所以，A说的话不可能是“我是无赖”。</p></li>
<li><p>因此，B说的不是事实，他必然是无赖。</p></li>
<li><p>因此，C说的是事实。</p></li>
<li><p>结论：C是骑士。</p></li>
</ol>
<ul>
<li>A可以是任何人，实际上可以知道<strong>这个岛上不会有任何人说自己是无赖</strong></li>
<li>C没说话就可以判定B是无赖</li>
</ul>
<h4 id="把思考过程机械化">把思考过程机械化</h4>
<ul>
<li><p><code>知识表示</code>（将一组知识形式化为符号）</p>
<ul>
<li>第<span class="math inline">\(i\)</span>个人是骑士：<span class="math inline">\(A_i\)</span></li>
<li>第<span class="math inline">\(i\)</span>个人是无赖：¬<span class="math inline">\(A_i\)</span></li>
<li>第<span class="math inline">\(i\)</span>个人说了一句话P：<span class="math inline">\(A_i\)</span> ⟺ P</li>
</ul></li>
<li><p><code>当前的知识库</code></p>
<ul>
<li>B说：A说的话是A是无赖：<span class="math inline">\(A_2\)</span> ⟺
(<span class="math inline">\(A_1\)</span> ⟺ ¬<span class="math inline">\(A_1\)</span>)</li>
<li>C说B在撒谎：<span class="math inline">\(A_3\)</span> ⟺ ¬<span class="math inline">\(A_2\)</span></li>
</ul></li>
<li><p><code>画出真值表</code></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(A_1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(A_2\)</span></th>
<th style="text-align: center;"><span class="math inline">\(A_3\)</span></th>
<th style="text-align: center;"><span class="math inline">\(A_2\)</span>⟺(<span class="math inline">\(A_1\)</span> ⟺ ¬<span class="math inline">\(A_1\)</span>)</th>
<th style="text-align: center;"><span class="math inline">\(A_3\)</span>
⟺ ¬<span class="math inline">\(A_2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;"><code>1</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;"><code>1</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table></li>
<li><p><code>根据蕴含的定义</code>，有：<strong>𝐾𝐵 ⊨ <span class="math inline">\(A_3\)</span></strong></p></li>
</ul>
<h2 id="归结原理">归结原理</h2>
<h3 id="字句型">字句型</h3>
<ul>
<li>原子谓词公式及其否定统称为<code>文字</code>
<ul>
<li>例如，P(x)，Q(x)等都是文字</li>
</ul></li>
<li>任何<code>文字</code>的析取式称为<code>子句</code>
<ul>
<li>例如，P(x) V Q(x)，P(x, f(x)) V Q(x, g(x))都是子句</li>
</ul></li>
<li>不含任何<code>文字</code>的子句称为<code>空子句</code></li>
<li>由于<code>空子句</code>不含有任何<code>文字</code>，也就不能被任何解释所满足，因此<code>空子句是永假的，不可满足的</code></li>
<li>由<code>子句</code>或<code>空子句</code>所构成的集合称为<code>子句集</code></li>
</ul>
<p>定理：设有谓词公式F，其标准子句集为S，则F为不可满足的充要条件是S可满足的。</p>
<h3 id="基本思想">基本思想</h3>
<p>由谓词公式转化为子句集的方法可以知道，在子句集中子句之间是合取关系。其中，只要有一个子句为不可满足，则整个子句集就是不可满足的，另外，前面已经指出空子句是不可满足的。因此，<strong>一个子句集中如果包含有空子句，则此子句集就一定是不可满足的</strong>。</p>
<blockquote>
<p>首先把欲证明问题的结论否定，并加入子句集，得到一个扩充的子句集
S'，然后设法检验子句集S'是否含有空子句，若含有空子句，则表明 S'
是不可满足的；若不含有空子句，则继续使用归结法，在子句集中选择合适的子句进行归结，直至导出空句子或不能继续归结为止。</p>
</blockquote>
<h3 id="归结反演">归结反演</h3>
<p>在命题逻辑中，已知 𝐾𝐵，证明 α
为真的归结反演过程如下：（<code>&#123;𝐾𝐵, ¬α&#125; ⊢ ∅</code>）</p>
<blockquote>
<ol type="1">
<li>否定目标公式 α，得 ¬α；</li>
<li>把 ¬α 并入到公式集 KB 中，得到 {𝐾𝐵, ¬α}；</li>
<li>把 {𝐾𝐵, ¬α} 化为子句集S；</li>
<li>应用归结原理对子句集 S 中的子句进行归结，并把每次得到的归结式并入 S
中，如此反复进行，若出现<code>空子句</code>，则停止归结，此时就证明了 α
为真。</li>
</ol>
</blockquote>
<h3 id="归结原理的可靠性和完备性">归结原理的可靠性和完备性</h3>
<p>归结原理的可靠性：语义上推演得到的知识在语法上正确利用真值表，保证归结的过程是正确的即可。（推理规则是可靠的）</p>
<p>归结原理的完备性：如果语法上能够推演得到，那么语义上正确。</p>
<p>归结原理的<code>完备性证明</code>：（即证明如果 𝐾𝐵 ⊨ 𝛼 ，那么 𝐾𝐵 ⊢
𝛼）</p>
<ul>
<li>因为 𝐾𝐵 ⊨ 𝛼 等价于 𝐾𝐵 ∧ ¬𝛼 永假，即 S = {𝐾𝐵, ¬α}是不可满足的</li>
<li>而 𝐾𝐵 ⊢ 𝛼 等价于 𝐾𝐵 ∧ ¬𝛼 可以归结出空子句，即 RC(S) 包含空子句</li>
<li>因此只要证明：如果 S 是不可满足的，则 RC(S)
包含空子句，等价于证明逆否命题，即<strong>如果 RC(S) 不包含空子句，那么
S 是可满足的</strong></li>
<li>针对 RC(S) 中的原子命题 <span class="math inline">\(R_1,R_2,⋯,R_l\)</span>，构造model：</li>
<li>首先因为 RC(S) 不包含空子句，即 RC(S) 不包含永假的句子</li>
<li>从 <span class="math inline">\(i = 1\)</span> 到 <span class="math inline">\(l\)</span> ，顺序的指派 <span class="math inline">\(R_1,R_2,⋯,R_l\)</span> 的真值：
<ul>
<li>如果 RC(S) 中包含一个子句，此子句包含 ¬<span class="math inline">\(R_i\)</span>，且此子句的其它文字都已经被指派为
False（在之前的步骤中进行的）或不包含其它文字，则把 <span class="math inline">\(R_i\)</span> 指派为 False；否则，把 <span class="math inline">\(R_i\)</span> 指派为 True</li>
</ul></li>
<li>用反证法证明：这个真值指派使得 RC(S) 中的字句都为真。
<ul>
<li>假设，在此过程的第 <span class="math inline">\(i\)</span>
步，我们这样来指派 <span class="math inline">\(R_i\)</span> 使得某个子句
C 为 False，且假设这是<code>首次</code>出现 Fasle 的子句，此时，子句 C
只能是如下两种形式之一：</li>
<li><strong>𝐹𝑎𝑙𝑠𝑒 ⋁ 𝐹𝑎𝑙𝑠𝑒 ⋯ ⋁ 𝐹𝑎𝑙𝑠𝑒 ⋁</strong> <span class="math inline">\(R_i\)</span> 或者 <strong>𝐹𝑎𝑙𝑠𝑒 ⋁ 𝐹𝑎𝑙𝑠𝑒 ⋯ ⋁ 𝐹𝑎𝑙𝑠𝑒
⋁ </strong>¬<span class="math inline">\(R_i\)</span></li>
<li>显然，如果 RC(S) 中只包含以上两个子句之一，子句 C
是不会在此真值指派中为 False 的。因此，RC(S)
此时应该同时包含了以上两个子句</li>
<li>以上两个子句显然是满足归结条件的，也就是说，它归结后的子句也应该在
RC(S) 中；同时，该子句已经被指派为 False
了；这与我们之前的假设<code>矛盾</code>。</li>
</ul></li>
</ul>
<h2 id="hron子句与definite子句">Hron子句与Definite子句</h2>
<p>限定子句：恰好只含一个正文字的析取式</p>
<p>Hron子句：至多只有一个正文字的析取式</p>
<p>每个限定子句都可以被写作蕴含式，它的前提是正文字的合取式，结论为单个正文字</p>
<p>使用Hron子句的推理可以使用前向链接和反向链接</p>
<h2 id="modus-ponens">Modus Ponens</h2>
<p>Modus Ponens 规则：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240116230947673.png" alt="image-20240116230947673" style="zoom:67%;"></p>
<p>Modus Ponens 规则是可靠的，即证明：<strong><span class="math inline">\(α_1\)</span> ⋀ ⋯ ⋀ <span class="math inline">\(α_n\)</span> ⋀ (<span class="math inline">\(α_1\)</span> ⋀ ⋯ ⋀ <span class="math inline">\(α_n\)</span> ⇒ β) ⊨ β</strong></p>
<ul>
<li>用真值表证明<strong><span class="math inline">\(α_1\)</span> ⋀ ⋯ ⋀
<span class="math inline">\(α_n\)</span> ⋀ (<span class="math inline">\(α_1\)</span> ⋀ ⋯ ⋀ <span class="math inline">\(α_n\)</span> ⇒ β) ⊨ β</strong>即可</li>
</ul>
<p>Modus Ponens 完备性证明：</p>
<ul>
<li>证明若 𝐾𝐵 ⊨ 𝛼 ，则 𝐾𝐵 ⊢ 𝛼</li>
<li>RC(𝐾𝐵) 表示所有 𝐾𝐵 中的原始子句以及用 Modus Ponens
规则所能推理出的所有子句</li>
<li>构造如下真值指派 m：对于任意变量 𝛼，𝛼 指派为 True 当且仅当 <span class="math inline">\(\alpha \in  RC(𝐾𝐵)\)</span></li>
<li>使用反证法证明：在 m下，𝐾𝐵 为真
<ul>
<li>假设此时 𝐾𝐵 为 false，则必然存在一个限定子句，在 m 下为 false</li>
<li>若该子句为<span class="math inline">\(α_1\)</span> ⋀ ⋯ ⋀ <span class="math inline">\(α_n\)</span> ⇒ β
<ul>
<li>也就是说，在 m 中, <span class="math inline">\(α_1\)</span>,...,<span class="math inline">\(α_n\)</span> 均 True，且 β 为False</li>
<li>根据定义， <span class="math inline">\(\alpha_i
\in  RC(𝐾𝐵)\)</span>，又根据 Modus Ponens 规则， <span class="math inline">\(\beta \in  RC(𝐾𝐵)\)</span>，而根据先前的定义 β
应该为 True，因此矛盾</li>
</ul></li>
<li>若该子句为 β，在 m 下为 β 为 false，则 <span class="math inline">\(\beta \notin  RC(𝐾𝐵)\)</span>，矛盾</li>
</ul></li>
<li>若 𝐾𝐵 ⊨ 𝛼，根据蕴涵定义，在 m 中 𝛼 为真，根据前面定义<span class="math inline">\(\alpha \in  RC(𝐾𝐵)\)</span>，也就是说 𝐾𝐵 ⊢ 𝛼</li>
</ul>
<h2 id="prolog">Prolog</h2>
<p>Prolog一定能推出正确的东西嘛？</p>
<ul>
<li>Prolog 是一种逻辑编程语言，其基于一阶谓词演算。Prolog
的主要特点是使用逻辑规则和事实来表示问题，通过向系统提供问题描述，Prolog
可以进行逻辑推理和搜索，寻找问题的解。</li>
<li>然而，Prolog 并不总是能保证返回正确的结果。Prolog
的推理过程依赖于用户提供的逻辑规则和事实，以及查询时所使用的目标。如果用户提供的逻辑规则或事实存在错误，或者查询目标设置得不当，Prolog
可能会产生不正确的结果。</li>
<li>Prolog
的推理过程也可能受到计算机的限制和资源限制的影响。在处理复杂问题时，搜索空间可能会变得非常庞大，导致计算效率下降，或者算法无法找到解决方案。</li>
</ul>
<h3 id="的阶乘">5的阶乘</h3>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 基本情况：0的阶乘是1</span></span><br><span class="line">factorial(<span class="number">0</span>, <span class="number">1</span>).</span><br><span class="line"></span><br><span class="line"><span class="comment">% 递归规则：计算 N 的阶乘</span></span><br><span class="line">factorial(<span class="symbol">N</span>, <span class="symbol">Result</span>) :-</span><br><span class="line">    <span class="symbol">N</span> &gt; <span class="number">0</span>,</span><br><span class="line">    <span class="symbol">N1</span> is <span class="symbol">N</span> - <span class="number">1</span>,</span><br><span class="line">    factorial(<span class="symbol">N1</span>, <span class="symbol">Result1</span>),</span><br><span class="line">    <span class="symbol">Result</span> is <span class="symbol">N</span> * <span class="symbol">Result1</span>.</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>factorial/2</code>
是一个谓词，接受两个参数，第一个参数是要计算阶乘的数字，第二个参数是计算得到的阶乘结果。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?- factorial(<span class="number">5</span>, <span class="symbol">Result</span>).</span><br></pre></td></tr></table></figure>
<p>查询结果应该是
<code>Result = 120</code>。这段代码使用递归定义了阶乘，并在基本情况（N为0时）返回1。</p>
<h3 id="斐波那契数列">斐波那契数列</h3>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 基本情况：前两个斐波那契数是1</span></span><br><span class="line">fibonacci(<span class="number">0</span>, <span class="number">1</span>).</span><br><span class="line">fibonacci(<span class="number">1</span>, <span class="number">1</span>).</span><br><span class="line"></span><br><span class="line"><span class="comment">% 递归规则：计算第 N 个斐波那契数</span></span><br><span class="line">fibonacci(<span class="symbol">N</span>, <span class="symbol">Result</span>) :-</span><br><span class="line">    <span class="symbol">N</span> &gt; <span class="number">1</span>,</span><br><span class="line">    <span class="symbol">N1</span> is <span class="symbol">N</span> - <span class="number">1</span>,</span><br><span class="line">    <span class="symbol">N2</span> is <span class="symbol">N</span> - <span class="number">2</span>,</span><br><span class="line">    fibonacci(<span class="symbol">N1</span>, <span class="symbol">Result1</span>),</span><br><span class="line">    fibonacci(<span class="symbol">N2</span>, <span class="symbol">Result2</span>),</span><br><span class="line">    <span class="symbol">Result</span> is <span class="symbol">Result1</span> + <span class="symbol">Result2</span>.</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>fibonacci/2</code>
是一个谓词，接受两个参数，第一个参数是要计算的斐波那契数的索引，第二个参数是计算得到的斐波那契数。</p>
<p>通过查询 <code>fibonacci/2</code> 谓词来计算斐波那契数列中的第 N
个数：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?- fibonacci(<span class="number">5</span>, <span class="symbol">Result</span>).</span><br></pre></td></tr></table></figure>
<p>查询结果应该是 <code>Result = 8</code>，表示斐波那契数列中第 5 个数是
8。</p>
<h1 id="搜索">搜索</h1>
<p><strong>Tree search</strong>，<strong>Graph
search</strong>算法框架要记住.</p>
<p>通过下面四个来评估算法的好坏：</p>
<p><strong>completeness</strong>——does it always find a solution if one
exists?</p>
<p><strong>time complexity</strong>——number of nodes
generated/expanded</p>
<p><strong>space complexity</strong>——maximum number of nodes in
memory</p>
<p><strong>optimality</strong>——does it always find a least-cost
solution?</p>
<p>Uniformed Search：Breadth-first search、Depth-first
search、Uniform-cost search</p>
<p>Informed Search：g(n): Uniform-cost search；h(n)；f(n)=g(n)+h(n): A*
search（非常重要A*）</p>
<p>Admissible heuristics、Consistent heuristics与Tree search和graph
search比较。（考试难点）</p>
<p>Mini Max（一定要记住）和Alpha-Beta
Prunining（一定要记住）要掌握。</p>
<p>什么是模拟退火算法Simulated Annealing？</p>
<h2 id="tree-search">Tree search</h2>
<ul>
<li>从初始状态开始</li>
<li>扩展当前状态
<ul>
<li>搜索的本质是：现在跟进一个选择，把其他的放在一边</li>
</ul></li>
</ul>
<blockquote>
<p>function TREE-SEARCH(问题, 策略) 返回一个解决方案或失败</p>
<p>​ 使用问题的初始状态初始化搜索树</p>
<p>​ 循环直到结束</p>
<p>​ 如果没有可扩展的候选节点，则返回失败</p>
<p>​ 根据策略选择一个叶子节点进行扩展</p>
<p>​ 如果节点包含目标状态，则返回相应的解决方案</p>
<p>​ 否则，扩展节点并将生成的节点添加到搜索树中</p>
<p>​ 结束</p>
</blockquote>
<p>所有的搜索算法都共享这种树状搜索结构，它们的变化主要取决于它们如何选择要扩展的状态——即所谓的搜索策略。</p>
<h3 id="general-tree-search框架">General tree search框架</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function TREE-SEARCH(problem, fringe) returns a solution, or failure</span><br><span class="line">    fringe ← INSERT(MAKE-NODE(INITIAL-STATE[problem]), fringe)</span><br><span class="line">    loop do</span><br><span class="line">        if fringe is empty then return failure</span><br><span class="line">        node ← REMOvE-FRONT(fringe)</span><br><span class="line">        if GOAL-TEST(problem, STATE(node)) then return node</span><br><span class="line">        fringe ← INSERTALL(ExPAND(node, problem), fringe)</span><br><span class="line">function ExPAND(node, problem) returns a set of nodes</span><br><span class="line">    successors ← the empty set</span><br><span class="line">    for each action, result in SuCCESsOR-FN(problem, STATE[node]) do</span><br><span class="line">        s ← a new NoDE</span><br><span class="line">        PARENT-NODE[s] ← node; ACTION[s] ← action; STATE[s] ← result</span><br><span class="line">        PATH-CosT[s] ← PATH-CosT[node] + STEP-CosT(node, action, s)</span><br><span class="line">        DEPTH[s] ← DEPTH[node] + 1</span><br><span class="line">        add s to successors</span><br><span class="line">    return successors</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化</strong>：算法开始时，将初始状态对应的节点加入到搜索边界
<code>fringe</code> 中。这个节点包含了初始状态的信息。</li>
<li><strong>主循环</strong>：进入一个无限循环，直到找到解决方案或搜索边界为空。</li>
<li><ul>
<li><strong>搜索边界非空检查</strong>：检查搜索边界 <code>fringe</code>
是否为空。如果为空，表示无法找到解决方案，算法返回失败。</li>
<li><strong>节点选择</strong>：从搜索边界中选择一个节点（通常是按照某种优先级选择的，例如广度优先、深度优先、最佳优先等）。</li>
<li><strong>目标测试</strong>：检查当前选取的节点是否满足问题的目标测试。如果满足，算法返回当前节点作为解决方案。</li>
<li><strong>节点扩展</strong>：对当前节点进行扩展操作，生成可能的后继节点。这一步可能会根据问题的具体性质进行不同的扩展，例如在搜索树的分支。</li>
<li><strong>更新搜索边界</strong>：将生成的后继节点加入搜索边界
<code>fringe</code> 中，以便在下一次循环中进行探索。</li>
</ul></li>
<li><strong>结束</strong>：如果成功找到解决方案，则返回解决方案的节点。如果搜索边界为空且没有找到解决方案，则算法返回失败。</li>
</ul>
<blockquote>
<p><code>ExPAND(node, problem)</code>：这个函数用于扩展给定的节点，并返回一个节点集合，表示由该节点可以到达的所有后继节点。对于每个可能的动作和其结果，创建一个新节点，设置其父节点、动作、状态、路径成本和深度，并将其添加到后继节点集合中。最后，返回后继节点集合。</p>
</blockquote>
<p>这个搜索算法采用迭代深化的深度优先搜索策略，通过不断扩展当前搜索树的深度，直到找到解决方案或搜索完整个树。在搜索的过程中，使用
fringe（边界）来存储待扩展的节点，从而实现深度优先的搜索。</p>
<h2 id="graph-search框架">Graph search框架</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function GRAPH-SEARCH( problem, fringe) returns a solution, or failure</span><br><span class="line">    closed ← an empty set  //不同于General tree search</span><br><span class="line">    fringe ← INSERT(MAKE-NODE(INITIAL-STATE[problem]).fringe)</span><br><span class="line">    loop do</span><br><span class="line">        if fringe is empty then return failure</span><br><span class="line">        node ← REMOvE-FRONT(fringe)</span><br><span class="line">        if GOAL-TEsT(problem,STATE[node])then return node</span><br><span class="line">        if STATE[node] is not in closed then  //不同于General tree search</span><br><span class="line">            add STATE[node] to closed      //不同于General tree search</span><br><span class="line">            fringe ← INSERTALL(ExPAND(node, problem),fringe)</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化</strong>：首先，创建一个空的集合
<code>closed</code>，用于记录已经访问过的状态（<code>不同处</code>）。然后，将初始状态对应的节点加入到搜索边界
<code>fringe</code> 中。</li>
<li><strong>主循环</strong>：进入一个无限循环，直到找到解决方案或搜索边界为空。
<ul>
<li><strong>搜索边界非空检查</strong>：检查搜索边界 <code>fringe</code>
是否为空，如果为空，表示无法找到解决方案，算法返回失败。</li>
<li><strong>节点选择</strong>：从搜索边界中选择一个节点（通常是按照某种优先级选择的，例如广度优先、深度优先、最佳优先等）。</li>
<li><strong>目标检测</strong>：检查当前选取的节点是否满足问题的目标测试。如果满足，算法返回当前节点作为解决方案。</li>
<li><strong>重复状态检查</strong>：检查当前节点的状态是否已经在
<code>closed</code> 中。如果不在，表示是一个新状态，将其加入
<code>closed</code>。（<code>不同处</code>）</li>
<li><strong>节点扩展</strong>：对当前节点进行扩展操作，生成可能的后继节点。这一步可能会根据问题的具体性质进行不同的扩展，例如在搜索图的顶点。</li>
<li><strong>更新搜索边界</strong>：将生成的后继节点加入搜索边界
<code>fringe</code> 中，以便在下一次循环中进行探索。</li>
</ul></li>
<li><strong>结束</strong>：如果成功找到解决方案，则返回解决方案的节点。如果搜索边界为空且没有找到解决方案，则算法返回失败。</li>
</ul>
<h2 id="搜索策略">搜索策略</h2>
<p>一种策略由选择节点扩展的顺序来定义。</p>
<p>策略可以通过以下维度进行评估：</p>
<ul>
<li><strong>完备性</strong>（completeness）：是否总是能够找到解决方案（如果存在的话）？</li>
<li><strong>时间复杂度</strong>（time
complexity）：生成/扩展的节点数</li>
<li><strong>空间复杂度</strong>（space
complexity）：内存中的最大节点数</li>
<li><strong>最优性</strong>（optimality）：是否总是能够找到成本最低的解决方案？</li>
</ul>
<p>时间和空间复杂度是以以下标准来衡量的：</p>
<ul>
<li>b：搜索树的最大分支因子</li>
<li>d：最小成本解决方案的深度</li>
<li>m：状态空间的最大深度（可能为∞）</li>
</ul>
<h2 id="uninformed-search非启发式搜索">Uninformed
Search（非启发式搜索）</h2>
<ul>
<li><strong>宽度优先搜索</strong>（Breadth-first search）：先进先出队列
<ul>
<li>更快、更大的内存</li>
<li>时间复杂度：深度d，宽度b，则时间复杂度<span class="math inline">\(O(b^{d+1})\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(b^d)\)</span></li>
</ul></li>
<li><strong>深度优先搜索</strong>（Depth-first
search）：后进先出队列（栈）
<ul>
<li>内存少，速度慢</li>
<li>时间复杂度：<span class="math inline">\(O(b^m)\)</span>，m指任意节点地最大深度</li>
<li>空间复杂度：<span class="math inline">\(O(bm)\)</span>，空间复杂度低</li>
</ul></li>
<li><strong>回溯搜索</strong>：深度优先搜索地一个变种，空间复杂度更低，<span class="math inline">\(O(m)\)</span></li>
<li><strong>统一代价搜索</strong>（Uniform-cost
search）：优先级队列（以最小成本为出队准则）
<ul>
<li>如果步长成本相等，则等于宽度优先</li>
</ul></li>
</ul>
<h2 id="informed-search启发式搜索">Informed Search（启发式搜索）</h2>
<h3 id="最佳优先搜索">最佳优先搜索</h3>
<ul>
<li>是一般树搜索和图搜索的一个实例，节点是结语评价函数 <span class="math inline">\(f(n)\)</span> 被选择扩展的</li>
<li>评价函数是代价估计，品估值最低的节点被选择首先进行扩展</li>
<li>与一致代价搜索类似，最佳优先是 <span class="math inline">\(f\)</span> 而不是 <span class="math inline">\(g\)</span> 对优先级队列排队</li>
</ul>
<p><span class="math inline">\(f\)</span> 由启发函数构成：<span class="math inline">\(h(n)\)</span> = 节点 <span class="math inline">\(n\)</span>
到目标节点的最小代价路径的代价估计值</p>
<p><strong>贪婪最佳优先搜索</strong>：试图扩展离目标最近的节点，这样可以很快找到解，最坏情况下时间和空间复杂度都是
<span class="math inline">\(O(b^m)\)</span></p>
<h3 id="a-搜索">A* 搜索</h3>
<ul>
<li>结合 <span class="math inline">\(g(n)\)</span> 和 <span class="math inline">\(h(n)\)</span>，即 <span class="math inline">\(f(n)\)</span> = <span class="math inline">\(g(n)\)</span> + <span class="math inline">\(h(n)\)</span></li>
<li><span class="math inline">\(f(n)\)</span>：经过节点 <span class="math inline">\(n\)</span> 的最小代价解的估计代价</li>
</ul>
<p>A* 搜索的<strong>可采纳性</strong>和<strong>一致性</strong>：</p>
<ul>
<li>可采纳启发式（可容许性）：
<ul>
<li>可采纳启发式是指对于搜索问题的每个状态，<strong>启发式函数对从该状态到目标状态的估计不超过实际最短路径的估计</strong></li>
<li>换句话说，如果 <span class="math inline">\(h(n)\)</span>
是一个可采纳启发式，那么对于每个状态 <span class="math inline">\(n\)</span>，都满足以下不等式：<strong><span class="math inline">\(h(n) ≤\)</span> 实际从 <span class="math inline">\(n\)</span> 到目标的最短路径的代价</strong></li>
<li>在路径搜索算法中，可采纳启发式通常用于引导算法朝着更有可能导致最优解的方向搜索</li>
<li>直线距离是可采纳的启发式，两点之间直线最短，所以用直线距离肯定不会高估</li>
</ul></li>
<li>一致性（单调性）：
<ul>
<li>一致启发式是指对于搜索问题的每一对相邻的状态 <span class="math inline">\(n\)</span> 和其后继节点 <span class="math inline">\(n&#39;\)</span>，满足以下不等式：</li>
<li><strong><span class="math inline">\(h(n) ≤ c(n, a, n′) +
h(n′)\)</span></strong>，其中，<span class="math inline">\(c(n, a,
n&#39;)\)</span> 是从状态 <span class="math inline">\(n\)</span>
经过动作 <span class="math inline">\(a\)</span> 到达 <span class="math inline">\(n&#39;\)</span> 的实际代价</li>
<li>简而言之，<strong>一致启发式保证在搜索过程中，从一个状态到达其后继节点的路径代价不会小于启发式函数对该节点的估计</strong></li>
</ul></li>
</ul>
<blockquote>
<p>一致的启发函数都是可容许的，反之不成立。</p>
<p>可采纳启发式是一种特殊的一致启发式，即当 <span class="math inline">\(ℎ(n) = 0\)</span>
时，一致启发式就是可采纳启发式。一致启发式通常用于 A*
等搜索算法，以保证算法的最优性。</p>
</blockquote>
<h3 id="可容许性证明">可容许性证明</h3>
<ul>
<li>假设最佳路径上有 <span class="math inline">\(k\)</span> 个节点，考虑
<span class="math inline">\(k = 1\)</span> 的情况： <span class="math inline">\(n&#39;\)</span> 就是目标节点，则有 <span class="math inline">\(h(n) ≤ c(n, a, n′)\)</span></li>
<li>更一般的情况，假设 <span class="math inline">\(n&#39;\)</span>
在最优路径上，离目标节点还有 <span class="math inline">\(k\)</span>
步，并且 <span class="math inline">\(h(n′)\)</span>
是可容许的，则有</li>
<li><span class="math inline">\(h(n) ≤ c(n, a, n′) + h(n′) ≤ c(n, a, n′)
+ h^*(n′) = h^*(n)\)</span></li>
</ul>
<h3 id="a-算法最优性证明">A* 算法最优性证明</h3>
<blockquote>
<p>A*
算法的最优性证明基于其使用的启发式函数是<strong>可容许的</strong>。</p>
</blockquote>
<p>设 <span class="math inline">\(n\)</span> 是 A* 算法在某个时刻从
fringe 中选择扩展的节点。令 <span class="math inline">\(c(n)\)</span>
为从初始节点到节点 <span class="math inline">\(n\)</span>
的实际路径成本，<span class="math inline">\(h(n)\)</span> 为从节点 <span class="math inline">\(n\)</span> 到目标节点的启发式估计。</p>
<p>假设存在一条路径 <span class="math inline">\(P\)</span>
到达目标节点，其代价为 <span class="math inline">\(C(P)\)</span>。这个路径可以被划分为多个段，每个段由一个节点
<span class="math inline">\(n_i\)</span> 和其后继节点 <span class="math inline">\(n_{i+1}\)</span> 以及对应的动作 <span class="math inline">\(a_i\)</span> 组成。</p>
<ul>
<li><strong>可容许性</strong>：
<ul>
<li>由于启发式函数 <span class="math inline">\(h(n)\)</span>
是可容许的，对于任何节点 <span class="math inline">\(n_i\)</span>，都有
<span class="math inline">\(h(n_i) ≤ C(P) - c(n_i)\)</span></li>
</ul></li>
<li>A* <strong>选择最小代价节点</strong>：
<ul>
<li>A* 算法在选择节点进行扩展时，会选择具有最小的评估函数 <span class="math inline">\(f(n)\)</span> = <span class="math inline">\(g(n)\)</span> + <span class="math inline">\(h(n)\)</span> 值的节点。因此，对于节点 <span class="math inline">\(n_i\)</span>，有 <span class="math inline">\(f(n_i) = c(n_i) + h(n_i) ≤ C(P)\)</span>。</li>
</ul></li>
<li><strong>对于扩展的节点 <span class="math inline">\(n_i\)</span></strong>：
<ul>
<li>当算法扩展节点 <span class="math inline">\(n_i\)</span> 时，A*
会将其后继节点 <span class="math inline">\(n_{i+1}\)</span> 加入到
fringe 中，且 <span class="math inline">\(g(n_{i+1}) = g(n_i) + c(n_i,
a_i, n_{i+1})\)</span>。因此，<span class="math inline">\(g(n_{i+1}) =
c(n_{i+1})\)</span>。</li>
</ul></li>
<li><strong>节点 <span class="math inline">\(n_{i+1}\)</span>
的评估函数值</strong>：
<ul>
<li>对于节点 <span class="math inline">\(n_{i+1}\)</span>，其评估函数值为：<span class="math inline">\(f(n_{i+1}) = g(n_{i+1}) + h(n_{i+1}) = c(n_{i+1})
+ h(n_{i+1}) ≤ C(P)\)</span></li>
</ul></li>
<li><strong>目标节点的情况</strong>：
<ul>
<li>当目标节点 <span class="math inline">\(n_{goal}\)</span>
被扩展时，A* 算法会终止。由于启发式函数的可容许性，<span class="math inline">\(ℎ(n_{goal}) = 0\)</span>，且 <span class="math inline">\(f(n_{goal}) = g(n_{goal}) + h(n_{goal}) =
g(n_{goal}) ≤ C(P)\)</span>。</li>
</ul></li>
</ul>
<blockquote>
<p>由于 A*
算法的选择和扩展节点的规则，以及启发式函数的可容许性，我们可以得出结论：A*
算法在搜索过程中选择和扩展节点的顺序保证了它找到的解决方案具有最小的代价。因此，A*
算法是最优的。</p>
</blockquote>
<h3 id="模拟退火算法simulated-annealing">模拟退火算法（Simulated
Annealing）</h3>
<blockquote>
<p>模拟退火算法是一种启发式优化算法，灵感来源于固体物体的退火过程。在固体物体退火过程中，通过加热和逐渐冷却，物体的分子结构会逐渐趋于平衡状态。类似地，在模拟退火算法中，通过接受一些“差距更大”的解，有助于跳出局部最小值，并在搜索空间中找到全局最优解。</p>
</blockquote>
<ul>
<li>如果该移动视情况改善，则该移动被接收；否则，算法以某个小于 1
的概率接收该移动</li>
<li>如果移动导致状态"变坏"，概率则成指数级下降——评估值 <span class="math inline">\(\Delta E\)</span> 变坏 （接受坏解决方案的概率随 T
减小）</li>
<li>如果让温度 T 下降得足够慢，算法找到全局最优解得概率逼近于 1</li>
</ul>
<h2 id="alpha---beta-剪枝"><span class="math inline">\(\alpha -
\beta\)</span> 剪枝</h2>
<ul>
<li><span class="math inline">\(\alpha\)</span>：到目前为止路径上发现的MAX的最佳</li>
<li><span class="math inline">\(\beta\)</span>：到目前为止路径上发现的MIN的最佳</li>
<li><span class="math inline">\(\alpha\)</span> 剪枝：<span class="math inline">\(\alpha(先辈层) \geq \beta(后继层)\)</span></li>
<li><span class="math inline">\(\beta\)</span> 剪枝：<span class="math inline">\(\alpha(后继层) \geq \beta(先辈层)\)</span></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240118122647769.png" alt="image-20240118122647769" style="zoom:67%;"></p>
<h1 id="连结主义">连结主义</h1>
<h2 id="single-variable-prediction">Single-variable Prediction</h2>
<p>Decision Tree、Regression Tree、Logistic Regression、Adaboost</p>
<p>优化目标函数是什么? 怎么优化？ 怎么去预测</p>
<h3 id="neural-networks">Neural Networks</h3>
<p>前馈神经网络、卷积神经网络、循环神经网络</p>
<p>计算图分别是什么？</p>
<p>如何优化？梯度下降算法</p>
<p>在任意图自动求梯度的算法？（非常重要）反向传播！考试来考一下</p>
<h1 id="沈华伟老师部分">沈华伟老师部分</h1>
<h2 id="三大分支学派">三大分支学派</h2>
<ul>
<li>行为主义（学派）</li>
<li>联结主义（学派）</li>
<li>符号主义（学派）</li>
</ul>
<h2 id="图灵测试">图灵测试</h2>
<p>一个人（C）在<code>完全不接触</code>对方（A和B）的情况下，和
对方进行一系列的问答，如果在相当长时间内，他无法根据这些问题判断对方是人（B）还是计算机（A），
那么，就认为该计算机具有同人相当的智能（即计算机是能思维的）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240112143903167.png" alt="image-20240112143903167" style="zoom:67%;"></p>
<h3 id="在人工智能水平测试中如果某项人工智能通过了图灵测试则表示其智能水平从表现来看难以将其和人区分开来">在人工智能水平测试中，如果某项人工智能通过了图灵测试，则表示其智能水平：<code>从表现来看，难以将其和人区分开来</code></h3>
<h2 id="简答粒子群优化算法pso-particle-swarm-optimization">（简答）粒子群优化算法（PSO:
Particle Swarm Optimization）</h2>
<h3 id="基本原理">基本原理</h3>
<p>一种随机优化方法；通过粒子群在解空间中进行搜索，寻找最优解（适应度最大的解）。</p>
<h3 id="构成要素">构成要素</h3>
<p><strong>粒子群</strong>：</p>
<ul>
<li>每个粒子对应所求解问题的一个可行解</li>
<li>粒子通过其位置和速度表示
<ul>
<li>粒子<span class="math inline">\(i\)</span>在第<span class="math inline">\(n\)</span>轮的位置：<span class="math inline">\(x_{n}^{(i)}\)</span></li>
<li>粒子<span class="math inline">\(i\)</span>在第<span class="math inline">\(n\)</span>轮的速度： <span class="math inline">\(v_{n}^{(i)}\)</span></li>
</ul></li>
</ul>
<p><strong>记录</strong>：</p>
<ul>
<li><span class="math inline">\(p_{best}^{(i)}\)</span>：粒子<span class="math inline">\(i\)</span>的历史最好位置</li>
<li><span class="math inline">\(g_{best}\)</span>：全局历史最好位置</li>
</ul>
<p><strong>计算适应度的函数</strong>：</p>
<ul>
<li>适应度：<span class="math inline">\(f(x)\)</span></li>
</ul>
<h3 id="算法过程">算法过程</h3>
<ul>
<li><strong>初始化</strong>
<ul>
<li>初始化粒子群：每个粒子的位置和速度，即<span class="math inline">\(x_{0}^{(i)}\)</span>和<span class="math inline">\(v_{0}^{(i)}\)</span></li>
<li><span class="math inline">\(p_{best}^{(i)}\)</span>（粒子<span class="math inline">\(i\)</span>的历史最好位置）和<span class="math inline">\(g_{best}\)</span>（全局历史最好位置）</li>
</ul></li>
<li><strong>循环执行如下三步直至满足结束条件</strong>
<ul>
<li>计算每个粒子的适应度：<span class="math inline">\(f(x_{n}^{(i)})\)</span></li>
<li>更新每个粒子<code>历史</code>最好适应度及其相应的位置，更新<code>当前全局</code>最好适应度及其相应位置</li>
<li>更新每个粒子的速度和位置</li>
</ul></li>
</ul>
<p><span class="math display">\[
v_{n+1}^{(i)} = v_{n}^{(i)} + c_1*r_1*(p_{best}^{(i)} - x_{n}^{(i)}) +
c_2*r_2*(g_{best} - x_{n}^{(i)})
\]</span></p>
<p><span class="math display">\[
x_{n+1}^{(i)} = x_{n}^{(i)}+v_{n+1}^{(i)}
\]</span></p>
<h3 id="粒子速度更新公式解读">粒子速度更新公式解读</h3>
<ul>
<li><span class="math inline">\(v_{n}^{(i)}\)</span>：<code>惯性项</code>，保持原速度不变的倾向。</li>
<li><span class="math inline">\((p_{best}^{(i)} -
x_{n}^{(i)})\)</span>：<code>记忆项</code>，回到历史最好位置的倾向。</li>
<li><span class="math inline">\((g_{best} -
x_{n}^{(i)})\)</span>：<code>社会项</code>，走向粒子群全局最好位置
的倾向。</li>
<li><span class="math inline">\(c\)</span>：权重参数，一般取值为2。</li>
<li><span class="math inline">\(r\)</span>：随机参数，0和1之间的随机数。</li>
</ul>
<h3 id="算法终止条件">算法终止条件</h3>
<ul>
<li>迭代的轮数</li>
<li>最佳位置连续未更新的轮数</li>
<li>适应度函数的值到达预期要求</li>
</ul>
<h3 id="适用范围">适用范围</h3>
<p>适用于求解<code>连续解空间的优化问题</code>。</p>
<h2 id="多臂赌博机">多臂赌博机</h2>
<p>一台赌博机有<code>多个摇臂</code>，每个摇臂摇出的<code>奖励 （reward）大小不确定</code>，玩家希望摇<code>固定次数</code>的臂所获得的<code>期望累积奖励最大</code>。</p>
<ul>
<li>多臂赌博机的优化目标是最大化累计期望收益。</li>
<li>贪心策略优化的目标是当前行为的期望收益。</li>
<li>在<span class="math inline">\(\varepsilon\)</span>贪心策略中，有一个探索和利用的权衡。<span class="math inline">\(\varepsilon\)</span>贪心策略以<span class="math inline">\(\varepsilon\)</span>的概率选择进行探索（随机选择一个摇臂），而以<span class="math inline">\(1-\varepsilon\)</span>的概率选择进行利用（选择目前被认为是最好的摇臂）。这意味着，随着摇臂次数的增加，<span class="math inline">\(\varepsilon\)</span>贪心策略不会收敛到贪心策略，而是会一直保持一定程度的探索，以便发现更好的摇臂。</li>
<li><code>UCB(Upper Confidence Bound)</code>策略随着摇臂次数的增加，最终会收敛到贪心策略。</li>
</ul>
<h3 id="利用和探索">利用和探索</h3>
<ul>
<li>利用：<code>Exploitation</code>
<ul>
<li>按照<code>贪心策略</code>进行选择，即选择<span class="math inline">\(Q_t(a)\)</span>最大的行为<span class="math inline">\(a\)</span></li>
<li>优点：<code>最大化即时奖励</code></li>
<li>缺点：由于<span class="math inline">\(Q_t(a)\)</span>只是对<span class="math inline">\(q_*(a)\)</span>的估计，估计的不确定性导致按照贪心策略选择的行为不一定是<span class="math inline">\(q_*(a)\)</span>最大的行为</li>
</ul></li>
<li>探索：<code>Exploration</code>
<ul>
<li>选择<code>贪心策略之外</code>的行为（<code>non-greedy actions</code>）</li>
<li>优点：<code>长期奖励会比较高</code>，通过探索可以找出奖励更大的行为，供后续选择</li>
<li>缺点：短期奖励会比较低</li>
</ul></li>
</ul>
<p><strong>每步选择在“利用”和“探索”中二选一。</strong></p>
<p><strong>如何平衡“利用”和“探索”是关键。</strong></p>
<h2 id="策略学习">策略学习</h2>
<ul>
<li>动态规划方法（<code>Dynamic Programming</code>）</li>
<li>蒙特卡洛方法（<code>Monte Carlo</code>）</li>
<li>时序差分方法（<code>Temporal Difference: TD</code>）</li>
<li>参数近似方法</li>
<li>穷尽搜索方法（<code>Exhaustive search</code>）</li>
</ul>
<p><strong>记住下面四个方法计算状态估值函数时的示意图！</strong>（选择题）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240112170259958.png" alt="image-20240112170259958" style="zoom:67%;"></p>
<h2 id="博弈论">博弈论</h2>
<h3 id="博弈的要素">博弈的要素</h3>
<ul>
<li>局中人（Player）
<ul>
<li>在博弈中有权决定自己行动方案的博弈参加者</li>
<li>局中人不一定是具体的人</li>
<li>博弈中利益完全一致的参与者只能看成一个局中人</li>
</ul></li>
<li>重要假设：<strong>局中人是自私的理性人</strong>
<ul>
<li>不存在侥幸心理</li>
<li>不可能利用其它局中人的失误来扩大自己的利益</li>
<li>以<strong>最大化个人利益</strong>为目的</li>
</ul></li>
</ul>
<h3 id="田忌赛马中田忌的策略集合">田忌赛马中田忌的策略集合</h3>
<p>{上中下、上下中、中上下、中下上、下上中、下中上}</p>
<h3 id="囚徒困境">囚徒困境</h3>
<ul>
<li>局中人
<ul>
<li>两个囚徒</li>
</ul></li>
<li>策略
<ul>
<li>抗拒</li>
<li>坦白</li>
</ul></li>
<li>效用函数矩阵：</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">抗拒</th>
<th style="text-align: center;">坦白</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>抗拒</strong></td>
<td style="text-align: center;"><code>-1, -1</code></td>
<td style="text-align: center;"><code>-10, 0</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>坦白</strong></td>
<td style="text-align: center;"><code>0, -10</code></td>
<td style="text-align: center;"><code>-3, -3</code></td>
</tr>
</tbody>
</table>
<p><strong>纳什均衡</strong>：（坦白，坦白）</p>
<ul>
<li>一方保持策略不变（坦白），另一方如果改变策略（抗拒），
其效用会降低（从-3变成-10）</li>
<li><code>纳什均衡策略组合（坦白，坦白）不是帕累托最优</code></li>
</ul>
<p><strong>帕累托最优</strong>的决策组合一共有3个：</p>
<ul>
<li>（坦白，抗拒）</li>
<li>（抗拒，坦白）</li>
<li>（抗拒，抗拒）</li>
</ul>
<p><code>社会最优</code>策略组合是：（抗拒，抗拒）</p>
<h3 id="纳什均衡">纳什均衡</h3>
<ul>
<li>纳什均衡
<ul>
<li>定义：如果一个局势下，每个局中人的策略都是相对其他局中人<code>当前策略</code>的<code>最佳应对</code>，则称该局势是一个纳什均衡</li>
</ul></li>
<li>纳什均衡就是博弈的一个均衡解</li>
<li>是一个僵局
<ul>
<li>即给定其他人不动，没有人有动的积极性</li>
<li>谁动谁吃亏</li>
</ul></li>
</ul>
<h3 id="帕累托最优">帕累托最优</h3>
<p>对于一组策略选择（局势），若<strong>不存在其他策略选择使所有参与者得到至少和目前一样高的回报</strong>，且<strong>至少一个参与者会得到严格较高的回报</strong>，则这组策略选择为帕累托最优。</p>
<h3 id="社会最优">社会最优</h3>
<ul>
<li>使<strong>参与者的回报之和最大的策略选择</strong>（局势）</li>
<li>社会最优的结果一定也是帕累托最优的结果</li>
<li>帕累托最优不一定是社会最优</li>
</ul>
<h2 id="拍卖">拍卖</h2>
<h3 id="首价密封报价拍卖">首价密封报价拍卖</h3>
<p>纳什均衡：每个<code>竞拍者的报价低于其对商品的估价</code></p>
<ul>
<li><code>最优报价低于估价</code></li>
<li><code>竞拍者越多，报价越接近于估价</code></li>
</ul>
<h3 id="次价密封报价拍卖">次价密封报价拍卖</h3>
<p>纳什均衡：每个竞拍者会倾向于<code>采用其对商品的估价进行报价</code></p>
<h2 id="讨价">讨价</h2>
<ul>
<li>卖家和买家之间的博弈</li>
<li>讨价的对象是<code>双方对商品估价之差</code></li>
</ul>
<h2 id="maxmin策略和minmax策略">maxmin策略和minmax策略</h2>
<ul>
<li>maxmin策略
<ul>
<li><strong>最大化自己最坏情况时的收益</strong></li>
</ul></li>
<li>minmax策略
<ul>
<li><strong>最小化对手的最大收益</strong></li>
</ul></li>
<li>零和博弈情况下
<ul>
<li>minmax和maxmin是对偶的</li>
<li><strong>minmax策略和maxmin策略等价于纳什均衡策略</strong></li>
</ul></li>
</ul>
<h2 id="匹配市场">匹配市场</h2>
<h3 id="最优匹配">最优匹配</h3>
<ul>
<li>匹配的效用：成功匹配的估价之和，称为匹配的效用</li>
<li>最优匹配：效用最大的匹配</li>
<li>最优匹配对于个体而言不一定最优，甚至是最差的</li>
</ul>
<h3 id="价格导向的匹配">价格导向的匹配</h3>
<p>价格导向的匹配问题的形式化表示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240112214018209.png" alt="image-20240112214018209" style="zoom:67%;"></p>
<ul>
<li>估价不低于价格时，买方可以接受
<ul>
<li>如果<span class="math inline">\(v_{x,a}\geq{p_a}\)</span>，则买方<span class="math inline">\(x\)</span>可以接受卖方<span class="math inline">\(𝑎\)</span>的价格，如果成交，买方<span class="math inline">\(𝑥\)</span>获得的效用是<span class="math inline">\(v_{x,a}-{p_a}\)</span></li>
<li>对于买方<span class="math inline">\(𝑥\)</span>，如果使其效用最大的卖方是<span class="math inline">\(𝑎\)</span> ，那么在二部图中添加一条由<span class="math inline">\(𝑥\)</span>指向<span class="math inline">\(𝑎\)</span>的边</li>
<li>对于同一个买方，如果有多个卖方使其效用最大，则添加多条边</li>
<li>最终得到一个“买方偏好图”</li>
</ul></li>
</ul>
<p>示例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240112214553054.png" alt="image-20240112214553054" style="zoom:67%;"></p>
<h2 id="议价权">议价权</h2>
<h3 id="网络中节点位置的重要性">网络中节点位置的重要性</h3>
<p>节点在网络中所处的位置不同，导致其在博弈中的权利不同</p>
<h3 id="结局的稳定性">结局的稳定性</h3>
<ul>
<li>不稳定边
<ul>
<li>对于结局中<code>未参与配对的边</code>，如果边的两个端点获得的<code>收益之和小于1</code>，则称这条边为不稳定边</li>
<li>不稳定边的存在意味着其两个端点可以通过改变报价而改变结局</li>
</ul></li>
<li>稳定结局
<ul>
<li>如果一个结局中<code>不存在不稳定边</code>，则称该结局为<code>稳定结局</code></li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240112222203075.png" alt="image-20240112222203075" style="zoom:67%;"></p>
<h3 id="纳什议价解">纳什议价解</h3>
<ul>
<li>议价的对象
<ul>
<li>如何分配“剩余价值”<span class="math inline">\(s=1-x-y\)</span></li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240112223311171.png" alt="image-20240112223311171" style="zoom: 67%;"></p>
<ul>
<li>纳什议价解
<ul>
<li>A的收益是：<span class="math inline">\(x+\frac{s}{2}=\frac{1+x-y}{2}\)</span></li>
<li>B的收益是：<span class="math inline">\(y+\frac{s}{2}=\frac{1+y-x}{2}\)</span></li>
</ul></li>
<li>均衡结局
<ul>
<li>给定一个结局，如果结局中的任意一个<code>参与配对的边</code>都满足纳什议价解的条件，则称该结局是均衡结局</li>
</ul></li>
<li>注意：<strong>均衡结局一定是稳定结局</strong>
<ul>
<li>因此，在寻找均衡结局时，可以先<strong>寻找稳定结局</strong>，
进而<strong>确定均衡结局</strong></li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240112224514713.png" alt="image-20240112224514713" style="zoom:67%;"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240112231230327.png" alt="image-20240112231230327" style="zoom:67%;"></p>
<h2 id="因果模型图𝒅--分离">因果模型图𝒅 -分离</h2>
<ul>
<li>𝒅 -分离用于确定因果模型图中任意一对节点是否独立</li>
<li><strong>一条路径会被一组节点 𝒁 阻断，当且仅当：</strong>
<ul>
<li>路径 𝑝
包含<strong>链结构</strong><code>𝐴 → 𝐵 → 𝐶</code>或<strong>分叉结构</strong><code>𝐴 ← 𝐵 → 𝐶</code>，
且中间节点 𝐵 在 𝑍 中；或</li>
<li>路径 𝑝
包含一个<strong>对撞结构</strong><code>𝐴 → 𝐵 ← 𝐶</code>，且<strong>对撞节点
𝐵 及其子孙节点都不在 𝑍 中</strong>。</li>
</ul></li>
<li>如果一组节点 𝒁 阻断了 𝑿 和 𝒀 间的<strong>每一条路径</strong>，则 𝑿
和 𝒀 在 𝒁 的条件下是𝒅-分离的，即 𝑿 ⊥ 𝒀 | 𝒁</li>
</ul>
<p>有一个阻断节点就足以阻断整条路径。</p>
<p>以下一组变量是否能形成变量 𝑿 与 𝒀 的 𝒅 -分离：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240113003416442.png" alt="image-20240113003416442" style="zoom:67%;"></p>
<h2 id="后门准则">后门准则</h2>
<p><strong>给定因果模型图中一对有序变量 (𝑿, 𝒀)，若变量集合 𝒁
满足：</strong></p>
<ul>
<li>𝒁 阻断了 𝑿 与 𝒀 之间的每条含有指向 𝑿 的路径（换个理解就是：阻断 𝑿 和
𝒀 之间的后门路径）</li>
<li>𝒁 中没有 𝑿 的后代节点（换个理解就是：保持从 𝑿 到 𝒀
的因果路径不变）</li>
</ul>
<p>则称 𝒁 满足关于(𝑿, 𝒀)的<code>后门准则</code>。</p>
<p><strong>后门路径</strong>：如果一条连接 𝑿 和 𝒀 的路径中，有指向 𝑿
的箭头，则这条路径被称为从 𝑿 到 𝒀 的<code>后门路径</code>。</p>
<h3 id="找出满足变量对-𝑿-𝒀的后门准则的变量集">找出满足变量对 (𝑿,
𝒀)的后门准则的变量集</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20240113010313765.png" alt="image-20240113010313765" style="zoom:67%;"></p>
<h2 id="简答图神经网络gnns--自己总结">（简答）图神经网络（GNNs）--自己总结</h2>
<ul>
<li>图神经网络取得了显著的成功
<ul>
<li>在<strong>节点分类</strong>、<strong>链接预测</strong>和<strong>图分类</strong>方面实现最先进的经验性能</li>
</ul></li>
<li>新型GNNs的设计主要基于
<ul>
<li>经验直觉，启发式和实验试错</li>
</ul></li>
<li>我们缺乏对GNNs的性质和局限性的理论认识
<ul>
<li>一个基本问题是<code>GNNs的表达能力</code></li>
</ul></li>
</ul>
<h3 id="gnns的能力一个经验观点">GNNs的能力：一个经验观点</h3>
<ul>
<li>用于量子化学的GNNs
<ul>
<li>利用GNNs预测分子的量子特性</li>
<li>传统的方法，如DFT（密度泛函理论），是计算昂贵的</li>
</ul></li>
<li>基于GNNs的玻璃系统动力学建模</li>
</ul>
<h3 id="关于表达能力">关于表达能力</h3>
<ul>
<li><strong>可能出现的不同事件的数目</strong>
<ul>
<li><span class="math inline">\(n\)</span> bits的表达能力是<span class="math inline">\(2^n\)</span>
<ul>
<li>例如，5 bits能够区分32种不同的状态</li>
<li>给定不超过32瓶水，其中一瓶是有毒的，最多需要5只老鼠来识别哪一瓶是有毒的</li>
</ul></li>
</ul></li>
<li><strong>近似能力</strong>
<ul>
<li>单层感知器的表达能力
<ul>
<li><strong>单层感知器不是一个通用的近似器</strong></li>
<li>例如，异或不能被单层感知器近似</li>
</ul></li>
<li><strong>多层感知器为我们提供了一个通用的近似器</strong>
<ul>
<li>通用近似定理</li>
<li>随着层数增加，表达能力呈<code>指数级</code>增长。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="gnns的两个典型任务">GNNs的两个典型任务</h3>
<ul>
<li>图的两个典型任务
<ul>
<li>节点分类</li>
<li>图分类</li>
</ul></li>
</ul>
<h4 id="节点分类">节点分类</h4>
<p>给一个小型示例：</p>
<ul>
<li>1层GCN（图卷积网络）
<ul>
<li><strong>1层GCN表达能力有限：不能<code>完全</code>区分所有节点</strong></li>
</ul></li>
<li>2层GCN
<ul>
<li><strong>2层GCN可以完全区分这个小型示例中的所有节点</strong></li>
<li>GNNs的深度很重要</li>
</ul></li>
</ul>
<h4 id="图分类">图分类</h4>
<p>图分类性能：</p>
<ul>
<li>GNNs的高表达能力是否意味着在下游任务（例如，图分类）中会有良好的性能？</li>
<li><strong>高表达能力并不总是带来良好的性能</strong>。</li>
<li>注意：<strong>低表达能力总是意味着较差的性能</strong>。</li>
</ul>
<h3 id="押gnns的表达能力能否通过提高深度而无限提高有界限吗">（押）GNNs的表达能力能否通过提高深度而<code>无限</code>提高？有界限吗？</h3>
<p>GNNs的表达能力无法通过无限增加深度来无限提升。对GNNs的表达能力存在上限。</p>
<ul>
<li>随着GNNs深度的增加，它们确实变得更具表达能力，能够捕捉复杂的图结构。然而，这种提升是有限的。最近的研究表明，具有固定、有限深度的GNNs可能无法表达某些图属性，而且它们的表达能力可能在一定深度之后饱和。</li>
<li>这个限制通常被称为<code>"Weisfeiler-Lehman (WL) Test"</code>或<code>"Graph Isomorphism Network (GIN) Theorem"</code>，它指出具有特定架构（如图同构网络）的GNNs具有<strong>有限的表达能力，无法区分某些非同构图</strong>。
<ul>
<li>WL测试为基于聚合的GNNs的表达能力提供了一个上限</li>
<li>GIN是一种最强大的基于聚合的GNNs
<ul>
<li>1层感知器 -&gt; 多层感知器</li>
<li>均值池、最大池 -&gt; 池总和</li>
</ul></li>
</ul></li>
</ul>
<h2 id="综合题强化学习格子游戏突破5个格子">（综合题）强化学习：格子游戏(突破：5个格子)</h2>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">久朝暮</div><div class="post-copyright__author_desc">紫气东来</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://gaoyubo.cn/blogs/5cd16023.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://gaoyubo.cn/blogs/5cd16023.html')">高级AI复习</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://gaoyubo.cn/blogs/5cd16023.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=高级AI复习&amp;url=https://gaoyubo.cn/blogs/5cd16023.html&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gaoyubo.cn" target="_blank">久朝暮</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/UCAS%E8%AF%BE%E7%A8%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>UCAS课程<span class="tagsPageCount">4</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/blogs/b831931c.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">体系结构总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/blogs/b831931c.html" title="体系结构总结"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-01-15</div><div class="title">体系结构总结</div></div></a></div><div><a href="/blogs/9a8cdc59.html" title="计算机网络复习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-01-05</div><div class="title">计算机网络复习</div></div></a></div><div><a href="/blogs/6fbd99c.html" title="操作系统高级教程思考题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-14</div><div class="title">操作系统高级教程思考题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/7dbc6721bad89.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">开发、算法、课程总结</b>相关的内容，还有<b style="color:#fff">个人生活</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">久朝暮</h1><div class="author-info__desc">紫气东来</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/zy-zy9" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/479202769" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%90%9C%E4%B8%80%E6%90%9C.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%90%9C%E4%B8%80%E6%90%9Cback.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7ai%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">高级AI复习</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%97%E5%B9%B3%E8%80%81%E5%B8%88%E9%83%A8%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">罗平老师部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%80%9D%E8%80%83%E7%9A%84%E7%BB%88%E6%9E%81%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">关于思考的“终极算法”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%A0%94%E7%A9%B6%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.</span> <span class="toc-text">逻辑研究的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%95%B4%E6%B6%B5entailment%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">蕴涵（Entailment）重要概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%AF%8D%E7%9A%84%E5%BC%95%E5%85%A5%E6%98%AF%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E8%BF%9B%E8%A1%8C%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.2.2.</span> <span class="toc-text">连接词的引入：是为了方便进行知识表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%AD%89%E4%BB%B7"><span class="toc-number">2.2.3.</span> <span class="toc-text">逻辑等价（≡）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E4%B8%AD%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93-%F0%9D%90%BE%F0%9D%90%B5"><span class="toc-number">2.2.4.</span> <span class="toc-text">命题逻辑中的知识库 𝐾𝐵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#entailment%E4%B8%8Eimplication%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.5.</span> <span class="toc-text">Entailment与implication的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#implication%E5%92%8Cbiconditional%E9%83%BD%E5%8F%AF%E4%BB%A5%E7%94%A8negation%E5%90%A6-conjunction%E5%90%88%E5%8F%96-disjunction%E6%9E%90%E5%8F%96%E6%9D%A5%E8%A1%A8%E7%A4%BA%E9%82%A3%E4%B9%88%E5%AE%9A%E4%B9%89implication%E5%92%8Cbiconditional%E8%BF%99%E4%B8%A4%E7%A7%8D%E8%BF%9E%E6%8E%A5%E8%AF%8D%E6%9C%89%E4%BD%95%E7%94%A8%E9%80%94%E5%91%A2"><span class="toc-number">2.2.6.</span> <span class="toc-text">implication（⟹）和biconditional（⟺）都可以用negation（否）,
conjunction（合取）,
disjunction（析取）来表示，那么，定义implication和biconditional这两种连接词有何用途呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#validity-%E6%9C%89%E6%95%88%E6%80%A7%E5%92%8Csatisfiability-%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7"><span class="toc-number">2.2.7.</span> <span class="toc-text">Validity
(有效性)和Satisfiability (可满足性)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E6%80%AA%E5%B0%8F%E5%B2%9B%E8%80%83%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.3.</span> <span class="toc-text">奇怪小岛（考知识表示）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E6%80%AA%E5%B0%8F%E5%B2%9B%E4%B8%8A%E7%9A%84%E9%80%BB%E8%BE%91%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">奇怪小岛上的逻辑问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E7%90%86%E9%97%AE%E9%A2%981"><span class="toc-number">2.3.2.</span> <span class="toc-text">推理问题1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E6%98%AF%E9%AA%91%E5%A3%AB%E8%BF%98%E6%98%AF%E6%97%A0%E8%B5%96%E9%AA%91%E5%A3%AB"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">C是骑士还是无赖？——骑士</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E6%80%9D%E8%80%83%E8%BF%87%E7%A8%8B%E6%9C%BA%E6%A2%B0%E5%8C%96"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">把思考过程机械化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E7%BB%93%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">归结原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%8F%A5%E5%9E%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">字句型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">2.4.2.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E7%BB%93%E5%8F%8D%E6%BC%94"><span class="toc-number">2.4.3.</span> <span class="toc-text">归结反演</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E7%BB%93%E5%8E%9F%E7%90%86%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%92%8C%E5%AE%8C%E5%A4%87%E6%80%A7"><span class="toc-number">2.4.4.</span> <span class="toc-text">归结原理的可靠性和完备性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hron%E5%AD%90%E5%8F%A5%E4%B8%8Edefinite%E5%AD%90%E5%8F%A5"><span class="toc-number">2.5.</span> <span class="toc-text">Hron子句与Definite子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#modus-ponens"><span class="toc-number">2.6.</span> <span class="toc-text">Modus Ponens</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prolog"><span class="toc-number">2.7.</span> <span class="toc-text">Prolog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9A%84%E9%98%B6%E4%B9%98"><span class="toc-number">2.7.1.</span> <span class="toc-text">5的阶乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">2.7.2.</span> <span class="toc-text">斐波那契数列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">3.</span> <span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tree-search"><span class="toc-number">3.1.</span> <span class="toc-text">Tree search</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#general-tree-search%E6%A1%86%E6%9E%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">General tree search框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#graph-search%E6%A1%86%E6%9E%B6"><span class="toc-number">3.2.</span> <span class="toc-text">Graph search框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.</span> <span class="toc-text">搜索策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uninformed-search%E9%9D%9E%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2"><span class="toc-number">3.4.</span> <span class="toc-text">Uninformed
Search（非启发式搜索）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#informed-search%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2"><span class="toc-number">3.5.</span> <span class="toc-text">Informed Search（启发式搜索）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">3.5.1.</span> <span class="toc-text">最佳优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E6%90%9C%E7%B4%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text">A* 搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%AE%B9%E8%AE%B8%E6%80%A7%E8%AF%81%E6%98%8E"><span class="toc-number">3.5.3.</span> <span class="toc-text">可容许性证明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E7%AE%97%E6%B3%95%E6%9C%80%E4%BC%98%E6%80%A7%E8%AF%81%E6%98%8E"><span class="toc-number">3.5.4.</span> <span class="toc-text">A* 算法最优性证明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95simulated-annealing"><span class="toc-number">3.5.5.</span> <span class="toc-text">模拟退火算法（Simulated
Annealing）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alpha---beta-%E5%89%AA%E6%9E%9D"><span class="toc-number">3.6.</span> <span class="toc-text">\(\alpha -
\beta\) 剪枝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E7%BB%93%E4%B8%BB%E4%B9%89"><span class="toc-number">4.</span> <span class="toc-text">连结主义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#single-variable-prediction"><span class="toc-number">4.1.</span> <span class="toc-text">Single-variable Prediction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#neural-networks"><span class="toc-number">4.1.1.</span> <span class="toc-text">Neural Networks</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B2%88%E5%8D%8E%E4%BC%9F%E8%80%81%E5%B8%88%E9%83%A8%E5%88%86"><span class="toc-number">5.</span> <span class="toc-text">沈华伟老师部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%88%86%E6%94%AF%E5%AD%A6%E6%B4%BE"><span class="toc-number">5.1.</span> <span class="toc-text">三大分支学派</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%81%B5%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.</span> <span class="toc-text">图灵测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%B0%B4%E5%B9%B3%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9F%90%E9%A1%B9%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E9%80%9A%E8%BF%87%E4%BA%86%E5%9B%BE%E7%81%B5%E6%B5%8B%E8%AF%95%E5%88%99%E8%A1%A8%E7%A4%BA%E5%85%B6%E6%99%BA%E8%83%BD%E6%B0%B4%E5%B9%B3%E4%BB%8E%E8%A1%A8%E7%8E%B0%E6%9D%A5%E7%9C%8B%E9%9A%BE%E4%BB%A5%E5%B0%86%E5%85%B6%E5%92%8C%E4%BA%BA%E5%8C%BA%E5%88%86%E5%BC%80%E6%9D%A5"><span class="toc-number">5.2.1.</span> <span class="toc-text">在人工智能水平测试中，如果某项人工智能通过了图灵测试，则表示其智能水平：从表现来看，难以将其和人区分开来</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E7%AD%94%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95pso-particle-swarm-optimization"><span class="toc-number">5.3.</span> <span class="toc-text">（简答）粒子群优化算法（PSO:
Particle Swarm Optimization）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E6%88%90%E8%A6%81%E7%B4%A0"><span class="toc-number">5.3.2.</span> <span class="toc-text">构成要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-number">5.3.3.</span> <span class="toc-text">算法过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%92%E5%AD%90%E9%80%9F%E5%BA%A6%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F%E8%A7%A3%E8%AF%BB"><span class="toc-number">5.3.4.</span> <span class="toc-text">粒子速度更新公式解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.3.5.</span> <span class="toc-text">算法终止条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">5.3.6.</span> <span class="toc-text">适用范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%87%82%E8%B5%8C%E5%8D%9A%E6%9C%BA"><span class="toc-number">5.4.</span> <span class="toc-text">多臂赌博机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%92%8C%E6%8E%A2%E7%B4%A2"><span class="toc-number">5.4.1.</span> <span class="toc-text">利用和探索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.5.</span> <span class="toc-text">策略学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="toc-number">5.6.</span> <span class="toc-text">博弈论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88%E7%9A%84%E8%A6%81%E7%B4%A0"><span class="toc-number">5.6.1.</span> <span class="toc-text">博弈的要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%AD%E7%94%B0%E5%BF%8C%E7%9A%84%E7%AD%96%E7%95%A5%E9%9B%86%E5%90%88"><span class="toc-number">5.6.2.</span> <span class="toc-text">田忌赛马中田忌的策略集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83"><span class="toc-number">5.6.3.</span> <span class="toc-text">囚徒困境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1"><span class="toc-number">5.6.4.</span> <span class="toc-text">纳什均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%95%E7%B4%AF%E6%89%98%E6%9C%80%E4%BC%98"><span class="toc-number">5.6.5.</span> <span class="toc-text">帕累托最优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BE%E4%BC%9A%E6%9C%80%E4%BC%98"><span class="toc-number">5.6.6.</span> <span class="toc-text">社会最优</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%8D%E5%8D%96"><span class="toc-number">5.7.</span> <span class="toc-text">拍卖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E4%BB%B7%E5%AF%86%E5%B0%81%E6%8A%A5%E4%BB%B7%E6%8B%8D%E5%8D%96"><span class="toc-number">5.7.1.</span> <span class="toc-text">首价密封报价拍卖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A1%E4%BB%B7%E5%AF%86%E5%B0%81%E6%8A%A5%E4%BB%B7%E6%8B%8D%E5%8D%96"><span class="toc-number">5.7.2.</span> <span class="toc-text">次价密封报价拍卖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E4%BB%B7"><span class="toc-number">5.8.</span> <span class="toc-text">讨价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#maxmin%E7%AD%96%E7%95%A5%E5%92%8Cminmax%E7%AD%96%E7%95%A5"><span class="toc-number">5.9.</span> <span class="toc-text">maxmin策略和minmax策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%B8%82%E5%9C%BA"><span class="toc-number">5.10.</span> <span class="toc-text">匹配市场</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%8C%B9%E9%85%8D"><span class="toc-number">5.10.1.</span> <span class="toc-text">最优匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%B7%E6%A0%BC%E5%AF%BC%E5%90%91%E7%9A%84%E5%8C%B9%E9%85%8D"><span class="toc-number">5.10.2.</span> <span class="toc-text">价格导向的匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%AE%E4%BB%B7%E6%9D%83"><span class="toc-number">5.11.</span> <span class="toc-text">议价权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%8A%82%E7%82%B9%E4%BD%8D%E7%BD%AE%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">5.11.1.</span> <span class="toc-text">网络中节点位置的重要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%B1%80%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">5.11.2.</span> <span class="toc-text">结局的稳定性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B3%E4%BB%80%E8%AE%AE%E4%BB%B7%E8%A7%A3"><span class="toc-number">5.11.3.</span> <span class="toc-text">纳什议价解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E6%A8%A1%E5%9E%8B%E5%9B%BE%F0%9D%92%85--%E5%88%86%E7%A6%BB"><span class="toc-number">5.12.</span> <span class="toc-text">因果模型图𝒅 -分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E9%97%A8%E5%87%86%E5%88%99"><span class="toc-number">5.13.</span> <span class="toc-text">后门准则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%BB%A1%E8%B6%B3%E5%8F%98%E9%87%8F%E5%AF%B9-%F0%9D%91%BF-%F0%9D%92%80%E7%9A%84%E5%90%8E%E9%97%A8%E5%87%86%E5%88%99%E7%9A%84%E5%8F%98%E9%87%8F%E9%9B%86"><span class="toc-number">5.13.1.</span> <span class="toc-text">找出满足变量对 (𝑿,
𝒀)的后门准则的变量集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E7%AD%94%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Cgnns--%E8%87%AA%E5%B7%B1%E6%80%BB%E7%BB%93"><span class="toc-number">5.14.</span> <span class="toc-text">（简答）图神经网络（GNNs）--自己总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gnns%E7%9A%84%E8%83%BD%E5%8A%9B%E4%B8%80%E4%B8%AA%E7%BB%8F%E9%AA%8C%E8%A7%82%E7%82%B9"><span class="toc-number">5.14.1.</span> <span class="toc-text">GNNs的能力：一个经验观点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B"><span class="toc-number">5.14.2.</span> <span class="toc-text">关于表达能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gnns%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%B8%E5%9E%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.14.3.</span> <span class="toc-text">GNNs的两个典型任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%88%86%E7%B1%BB"><span class="toc-number">5.14.3.1.</span> <span class="toc-text">节点分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%88%86%E7%B1%BB"><span class="toc-number">5.14.3.2.</span> <span class="toc-text">图分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BCgnns%E7%9A%84%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B%E8%83%BD%E5%90%A6%E9%80%9A%E8%BF%87%E6%8F%90%E9%AB%98%E6%B7%B1%E5%BA%A6%E8%80%8C%E6%97%A0%E9%99%90%E6%8F%90%E9%AB%98%E6%9C%89%E7%95%8C%E9%99%90%E5%90%97"><span class="toc-number">5.14.4.</span> <span class="toc-text">（押）GNNs的表达能力能否通过提高深度而无限提高？有界限吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E9%A2%98%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F%E7%AA%81%E7%A0%B45%E4%B8%AA%E6%A0%BC%E5%AD%90"><span class="toc-number">5.15.</span> <span class="toc-text">（综合题）强化学习：格子游戏(突破：5个格子)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/5cd16023.html" title="高级AI复习">高级AI复习</a><time datetime="2024-01-18T05:41:14.000Z" title="发表于 2024-01-18 13:41:14">2024-01-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/b831931c.html" title="体系结构总结">体系结构总结</a><time datetime="2024-01-15T06:14:11.000Z" title="发表于 2024-01-15 14:14:11">2024-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/9a8cdc59.html" title="计算机网络复习">计算机网络复习</a><time datetime="2024-01-05T13:36:41.000Z" title="发表于 2024-01-05 21:36:41">2024-01-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/6fbd99c.html" title="操作系统高级教程思考题">操作系统高级教程思考题</a><time datetime="2023-12-14T14:46:27.000Z" title="发表于 2023-12-14 22:46:27">2023-12-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2d14aaf0.html" title="Linux常用函数">Linux常用函数</a><time datetime="2023-11-30T05:58:58.000Z" title="发表于 2023-11-30 13:58:58">2023-11-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="/wzy2096@126.com" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/zy-zy9" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/eh.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/479202769" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.douyin.com/user/self" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a></div><div class="copyright">&copy;2020 - 2024 By 久朝暮</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/album/"><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-STL/" style="font-size: 0.88rem;">C++ STL<sup>1</sup></a><a href="/tags/C-2-0/" style="font-size: 0.88rem;">C++2.0<sup>1</sup></a><a href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">C++内存管理<sup>1</sup></a><a href="/tags/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">C++设计模式<sup>1</sup></a><a href="/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">C++面向对象高级编程<sup>1</sup></a><a href="/tags/Effective-C/" style="font-size: 0.88rem;">Effective C++<sup>1</sup></a><a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" style="font-size: 0.88rem;">Linux常用函数<sup>1</sup></a><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/" style="font-size: 0.88rem;">Linux系统命令<sup>1</sup></a><a href="/tags/UCAS%E8%AF%BE%E7%A8%8B/" style="font-size: 0.88rem;">UCAS课程<sup>4</sup></a><a href="/tags/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%BF%9E%E7%BD%91%E6%8A%80%E6%9C%AF/" style="font-size: 0.88rem;">移动互连网技术<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Tt2yKI8TpkxMniyxFfGh8FX6-gzGzoHsz',
      appKey: '5oQifQ5aHzJHGp2AUh22jSe3',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>