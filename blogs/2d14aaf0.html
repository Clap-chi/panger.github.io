<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux常用函数 | zy</title><meta name="author" content="zy"><meta name="copyright" content="zy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux常用函数close函数关闭一个文件描述符， 使它不在指向任何文件。在新的文件操作中该文件描述符可以被再次使用。 使用close函数时传入需要关闭文件的文件描述符（即调用open函数的返回值）即可。若关闭文件成功则返回0；若关闭文件失败则返回-1。 函数原型1int close(int fd);  函数参数fd：文件描述符 函数返回值若关闭文件成功则返回0；若关闭文件失败则返回-1。 op">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux常用函数">
<meta property="og:url" content="http://example.com/blogs/2d14aaf0.html">
<meta property="og:site_name" content="zy">
<meta property="og:description" content="Linux常用函数close函数关闭一个文件描述符， 使它不在指向任何文件。在新的文件操作中该文件描述符可以被再次使用。 使用close函数时传入需要关闭文件的文件描述符（即调用open函数的返回值）即可。若关闭文件成功则返回0；若关闭文件失败则返回-1。 函数原型1int close(int fd);  函数参数fd：文件描述符 函数返回值若关闭文件成功则返回0；若关闭文件失败则返回-1。 op">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-11-30T05:58:58.000Z">
<meta property="article:modified_time" content="2023-11-30T17:44:48.396Z">
<meta property="article:author" content="zy">
<meta property="article:tag" content="Linux常用函数">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/blogs/2d14aaf0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux常用函数',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-01 01:44:48'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="zy" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="zy"><span class="site-name">zy</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux常用函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-11-30T05:58:58.000Z" title="Created 2023-11-30 13:58:58">2023-11-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-11-30T17:44:48.396Z" title="Updated 2023-12-01 01:44:48">2023-12-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux常用函数"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux常用函数"><a href="#Linux常用函数" class="headerlink" title="Linux常用函数"></a>Linux常用函数</h1><h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>关闭一个文件描述符， 使它不在指向任何文件。在新的文件操作中该文件描述符可以被再次使用。</p>
<p>使用close函数时传入需要关闭文件的<strong>文件描述符</strong>（即调用open函数的返回值）即可。若关闭文件成功则返回0；若关闭文件失败则返回-1。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>fd：文件描述符</p>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>若关闭文件成功则返回0；若关闭文件失败则返回-1。</p>
<h2 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h2><p>用来打开或者创建一个文件或者设备。</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span> </span><br></pre></td></tr></table></figure>

<h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="第一个参数"><a href="#第一个参数" class="headerlink" title="第一个参数"></a>第一个参数</h4><p>pathname：指定需要打开的文件的路径。</p>
<ul>
<li>若pathname以<strong>路径</strong>的方式给出，则需要创建该文件时，在pathname路径下进行创建。</li>
<li>若pathname以<strong>文件名</strong>的方式给出，则需要创建该文件时，默认在当前路径下进行创建。</li>
</ul>
<h4 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h4><p>flags：表示打开文件的方式。</p>
<p>flags是通过<code>O_RDONLY</code>, <code>O_WRONLY</code>或<code>O_RDWR</code>（指明文件是以只读 , 只写或读写方式打开的）与下面的零个或多个可选模式<strong>按位或</strong>操作符得到的:</p>
<ul>
<li><code>O_CREATE</code>：如果文件不存在就创建一个新文件。</li>
<li><code>O_EXCL</code>：通过O_CREATE，生成文件，若文件已经存在，则open出错 , 调用失败。这个O_EXCL与O_CREATE一起使用。</li>
<li><code>O_TRUNC</code>：如果文件已经存在，并且该文件是可写的，那么将会设置该文件的长度为0（清空文件的内容）。</li>
<li><code>O_APPEND</code>：文件以追加模式打开，在写之前，文件读写指针被置末尾。</li>
</ul>
<h4 id="第三个参数"><a href="#第三个参数" class="headerlink" title="第三个参数"></a>第三个参数</h4><p>mode：指明文件使用的权限。</p>
<p>传入0666参数进行文件创建，按理应得到-rw-rw-rw-权限的文件，但却得到了下面权限的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--</span><br></pre></td></tr></table></figure>

<p>这是因为权限掩码的存在（默认为0002），可以在代码中设置权限掩码来避免上述情况发生：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    umask(<span class="number">0000</span>);<span class="comment">//设置文件掩码                                                                     </span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./log.txt&quot;</span>,O_RDWR | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置成功后的文件权限如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-rw-</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 当不需创建文件时，可以不用设置第三个参数。</p>
<h3 id="函数返回值-1"><a href="#函数返回值-1" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>返回一个新的文件描述符（若是有错误发生返回-1，并在errno设置错误信息）。</p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p>创建test.c文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">//在指定路径下创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./helloworld1.txt&quot;</span>,O_CREAT | O_RDWR | O_TRUNC,<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fd1);</span><br><span class="line">    <span class="comment">//在指定路径下创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd2 = creat(<span class="string">&quot;./helloworld2.txt&quot;</span>,<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fd2);</span><br><span class="line">    <span class="comment">//在指定路径下创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd3 = open(<span class="string">&quot;./helloworld3.txt&quot;</span>,O_CREAT | O_RDWR | O_TRUNC);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fd3);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc test.c -o test</span><br><span class="line">root@vm:/home/wzy/code# ./test</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130142432496.png" alt="image-20231130142432496"></p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130142340377.png" alt="image-20231130142340377"></p>
<p>这里我们也可以看出文件描述符的取值最小从3开始，0，1，2都已经被使用。</p>
<h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><p>创建文件名test2.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./log&quot;</span>,O_CREAT | O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc test.c -o test</span><br><span class="line">root@vm:/home/wzy/code# ./test</span><br></pre></td></tr></table></figure>

<p>运行成功后查看log文件的内容发现Hello和fd的值写进log文件中。fd的值为1；<strong>并且永远取未用描述符的最小值</strong>。</p>
<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130142819174.png" alt="image-20231130142819174" style="zoom: 67%;" />

<h4 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h4><p>创建my_touch.c文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单实现touch命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;touch: 缺少了文件操作数\nTry &#x27;touch --help&#x27; for more information.\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd = open(args[i], O_RDONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc my_touch -o touch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#这样我们就可以使用touch创建文件，类似于Linux中的touch命令</span></span></span><br><span class="line">root@vm:/home/wzy/code# touch 1.c 2.c 3.c</span><br></pre></td></tr></table></figure>

<h2 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h2><p>Linux系统接口中使用write函数向文件写入信息。</p>
<p> write向文件描述符fd所引用的文件中写入从buf开始的缓冲区中count个字节的数据。POSIX规定，当使用了write()之后再使用read()，那么读取到的应该是更新后的数据。</p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-2"><a href="#函数参数-2" class="headerlink" title="函数参数"></a>函数参数</h3><ol>
<li>fd：文件描述符</li>
<li>buf：缓冲区</li>
<li>count：字节数</li>
</ol>
<h3 id="函数返回值-2"><a href="#函数返回值-2" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>成功时返回所写入的字节数（若为零则表示没有写入数据）。失败时返回-1，并置errno为相应值。若count为零，对于普通文件无任何影响，但对特殊文件将产生不可预料的后果。返回0表示没有数据写入。</p>
<h2 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h2><p>read()从文件描述符fd中读取count字节的数据并放入从buf开始的缓冲区中。如果count为零，read()返回0，不执行其他任何操作。如果 count大于SSIZE_MAX，那么结果将不可预料。</p>
<h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-3"><a href="#函数参数-3" class="headerlink" title="函数参数"></a>函数参数</h3><ol>
<li>fd：文件描述符</li>
<li>buf：缓冲区</li>
<li>count：字节数</li>
</ol>
<h3 id="函数返回值-3"><a href="#函数返回值-3" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>成功时返回读取的字计数；失败时返回-1，并设置errno的值；读到文件末尾的话就返回0。</p>
<h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><p>模拟cat命令实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, args[<span class="number">2</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,args[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        fd = open(args[i], O_RDONLY);</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">        ret = read(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">            write(<span class="number">1</span>, buff, ret);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc cat.c -o cat</span><br><span class="line">root@vm:/home/wzy/code# cat helloworld.txt</span><br><span class="line">This is helloworld.txt.root@vm:/home/wzy/code#</span><br></pre></td></tr></table></figure>

<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130144235599.png" alt="image-20231130144235599" style="zoom: 80%;" />

<p>运行编译生成的可执行程序可以打开存在的小文件。</p>
<h2 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h2><p>lseek()函数将与文件描述符fd相关联的打开文件的偏移量重新定位到参数offset上，如下所示：</p>
<ol>
<li>SEEK_SET：The offset is set to offset bytes. offset为0时表示文件开始位置。</li>
<li>SEEK_CUR：The offset is set to its current location plus offset bytes. offset为0时表示当前位置。</li>
<li>SEEK_END：The offset is set to the size of the file plus offset bytes. offset为0时表示结尾位置。</li>
</ol>
<p>当前文件偏移量：</p>
<ul>
<li><strong>每当打开一个文件，都会有一个叫做“当前文件偏移量”的东西，如果难理解也可以将他理解为指针。</strong> 除非打开文件时指定O_APPEND选项，否则<strong>文件偏移量默认设置为0</strong>。当我们发生了一次读或者写操作时，都会使这个当前文件偏移量发生变化，读&#x2F;写多少字节，当前偏移量就会向后移动多少。</li>
</ul>
<h3 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-4"><a href="#函数参数-4" class="headerlink" title="函数参数"></a>函数参数</h3><ol>
<li>fd：文件描述符</li>
<li>offset：文件的偏移量</li>
<li>whence：位置</li>
</ol>
<h3 id="函数返回值-4"><a href="#函数返回值-4" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功返回当前位置到开始的长度。</li>
<li>失败返回-1并设置errno。</li>
</ul>
<h3 id="使用实例-2"><a href="#使用实例-2" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1-1"><a href="#实例1-1" class="headerlink" title="实例1"></a>实例1</h4><p>移动文件读写位置。</p>
<p>用write()函数写入文件之后，这时候读写位置就指在写完后的那个位置，也就是字符串的后面，这样我们在使用read()函数去读的时候就相当于从写入字符串的后面去读的，所以啥也没读到。这时候，就可以使用lseek()函数来移动读写位置。<strong>新建一个文件并向其中写入数据，然后读取该文件的内容将其写入到屏幕上：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;not fount file name&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//新建一个文件并写入helloLinux,然后读取该文件的内容,将内容输出到屏幕上.</span></span><br><span class="line">    <span class="type">int</span> fd = open(args[<span class="number">1</span>], O_CREAT | O_RDWR);</span><br><span class="line">    write(fd, <span class="string">&quot;helloLinux&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//此时文件指针位置已经到末尾,需要重新将指针移到文件首部.</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">15</span>];</span><br><span class="line">    <span class="type">int</span> ret = read(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(STDOUT_FILENO, buff, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc lseek.c -o lseek</span><br><span class="line">root@vm:/home/wzy/code# ./lseek lseek.txt</span><br></pre></td></tr></table></figure>

<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130160151063.png" alt="image-20231130160151063" style="zoom: 80%;" />

<h4 id="实例2-1"><a href="#实例2-1" class="headerlink" title="实例2"></a>实例2</h4><p>计算文件大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./lseek2.txt&quot;</span>, O_RDONLY | O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成功后第一次运行新建一个原本不存在的文件，所以字节数为0：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130161416525.png" alt="image-20231130161416525"></p>
<p>然后向lseek2.txt写点数据：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130161710271.png" alt="image-20231130161710271"></p>
<p>第二次运行后：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130161618160.png" alt="image-20231130161618160"></p>
<h2 id="getenv-函数"><a href="#getenv-函数" class="headerlink" title="getenv()函数"></a>getenv()函数</h2><p>获取指定的环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br></pre></td></tr></table></figure>

<p>读取环境变量HOME的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;HOME&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130162653378.png" alt="image-20231130162653378" style="zoom:80%;" />

<h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p><strong>fork函数：</strong>：创建子进程。</p>
<p>fork函数是一个系统调用，其作用是创建一个新的进程。在调用fork函数时，操作系统会复制当前进程的所有信息，并将其分配给新的进程。新进程与原进程几乎完全相同，但有一些区别：在新进程中，fork返回值为0；在原进程中，fork返回值为新进程的PID（Process ID）。因此，在程序中可以根据返回值来判断当前代码运行在哪个进程中。</p>
<p><strong>父进程与子进程运行在不同的内存空间，子进程拥有独一无二的task_struct(PCB)，但是内存空间的内容是一样的，除了一些特殊的，比如说进程id不一样。</strong></p>
<p>子进程与父进程的区别：</p>
<p>由于子进程与父进程非常相似，但又有些微小的差别。下面我们列举一些常见的区别：</p>
<p>（1）PID不同：子进程和父进程有不同的PID，可以通过getpid()和getppid()函数获取。</p>
<p>（2）PPID不同：子进程和父进程有不同的PPID（即父亲PID），可以通过getppid()函数获取。</p>
<p>（3）资源占用情况不同：子进程会拷贝父亲所有资源情况（包括打开文件、信号处理等），但是有些资源是共享的，例如内存映射、消息队列等。</p>
<h3 id="函数返回值-5"><a href="#函数返回值-5" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>失败返回-1；<br>fork方法被调用一次，成功就会有两次返回：</p>
<ol>
<li>在父进程中返回一次，返回的是子进程的id（非0）。</li>
<li>在子进程中返回一次，返回值为0。</li>
</ol>
<h3 id="使用实例-3"><a href="#使用实例-3" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin:\n&quot;</span>);</span><br><span class="line">    <span class="comment">//返回值为子进程的id</span></span><br><span class="line">    <span class="type">pid_t</span> child_id = fork();</span><br><span class="line">    <span class="comment">//创建子进程失败</span></span><br><span class="line">    <span class="keyword">if</span> (child_id &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;create child process failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child id:%d parent id:%d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child id:%d self id:%d parent id:%d\n&quot;</span>,child_id, getpid(), getppid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130170512751.png" alt="image-20231130170512751"></p>
<p>子进程中的parent id有些时候运行结果为1，为什么是1呢？</p>
<p>这个涉及到孤儿进程的知识，原因是父进程已经死了，孤儿进程就被init进程领养了，由init进程负责孤儿进程资源的回收。当然了你还可以通过以下命令查看<code>ps aux</code>孤儿进程被哪个进程领养了；或者通过<code>ps ajx</code>查看父子进程之间的信息。</p>
<h2 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a>getpid函数</h2><p>获取当前进程的id。</p>
<h2 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a>getppid函数</h2><p>获取当前进程的父进程的id。</p>
<h2 id="exec族函数"><a href="#exec族函数" class="headerlink" title="exec族函数"></a>exec族函数</h2><p>这些exec族函数的共同特点：</p>
<ol>
<li>只有当错误发生才有返回值，返回值为-1；</li>
<li>这些函数都是可变参数的函数，所以参数列表必须以空指针结束；</li>
</ol>
<h3 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path为环境变量，arg为待执行文件的参数从argv[0]开始</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                       <span class="comment">/* (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file为需要执行的程序名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                       <span class="comment">/* (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h2><p>一个进程被创建出来是为了完成用户要求的任务，而进程完成任务的结果如何是由其父进程查看的，因此在进程退出时，不会立即释放该进程对应的资源，而是保存一段时间，让父进程或者操作系统来读取检查，读取后父进程或者操作系统才会回收该进程的所有资源。<strong>回收后该进程就是死亡状态（X—dead）</strong>了，而<strong>进程退出到还没被回收的期间的状态就是僵尸状态，也称僵尸状态(Z—zombie）</strong>。</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ol>
<li>僵死状态（Zombies）是一个比较特殊的状态。当进程退出并且父进程（使用wait()系统调用）没有读取到子进程退出的返回代码时就会产生僵死（尸）进程。</li>
<li>僵尸进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。</li>
<li>所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入Z状态。</li>
</ol>
<p>僵尸进程实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_id = fork();</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child, child id:%d parent id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process died!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am parent, parent id:%d\n&quot;</span>,getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130174140064.png" alt="image-20231130174140064" style="zoom:80%;" />

<h3 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h3><ul>
<li>维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在**<code>task_struct</code><strong>(即PCB)中，换句话说，</strong><code>Z</code>状态一直不退出，<code>PCB</code>一直都要维护**。</li>
<li>僵尸进程是要求回收的，不回收会占用内存，造成内存泄露。</li>
</ul>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>所谓孤儿进程，故名思义，和现实生活中的孤儿有点类似，当一个进程的父进程结束时，但是它自己还没有结束，那么这个进程将会成为孤儿进程。</p>
<p>当子进程的父进程挂掉之后，子进程会被<code>1</code>号进程领养。该进程也被称为孤儿进程。</p>
<p>那么为什么要进行领养呢：</p>
<ul>
<li>原因是孤儿进程会被init进程（1号进程）领养，当然在子进程结束时也会由init进程完成对它的状态收集工作，因此一般来说，孤儿进程并不会有什么危害。</li>
</ul>
<p>孤儿进程实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_id = fork();</span><br><span class="line">    <span class="comment">//孤儿进程</span></span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程id:%d 父进程id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程id:%d 父进程的父进程id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I will died\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h2><p>等待子进程状态的改变。</p>
<p>它是一个<strong>用于等待子进程结束的函数</strong>。该函数将暂停当前进程的执行，直到一个子进程结束或收到一个信号为止。当一个子进程结束时，wait函数会返回该子进程的PID（进程ID），并在status参数中返回子进程的退出状态信息。</p>
<p>调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）。</p>
<p>如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1。</p>
<h3 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引入的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-5"><a href="#函数参数-5" class="headerlink" title="函数参数"></a>函数参数</h3><p>进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</p>
<h3 id="函数返回值-6"><a href="#函数返回值-6" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回被回收的子进程的id。</li>
<li>失败：-1（所有的子进程都结束，调用函数失败）。</li>
</ul>
<h3 id="退出信息相关宏函数"><a href="#退出信息相关宏函数" class="headerlink" title="退出信息相关宏函数"></a>退出信息相关宏函数</h3><ul>
<li><code>WIFEXITED(status)</code>：非0，进程正常退出。</li>
<li><code>WEXITSTATUS(status)</code>：如果<code>WIFEXITED(status)</code>为真，获取进程退出的状态（exit的参数）。</li>
<li><code>WIFSIGNALED(status)</code>：非0，进程异常终止。</li>
<li><code>WTERMSIG(status)</code>：如果<code>WIFSIGNALED(status)</code>为真，获取使进程终止的信号编号。</li>
<li><code>WIFSTOPPED(status)</code>：非0，进程处于暂停状态。</li>
<li><code>WSTOPSIG(status)</code>：如果<code>WIFSTOPPED(status)</code>为真，获取使进程暂停的信号的编号。</li>
<li><code>WIFCONTINUED(status)</code>非0，进程暂停后已经继续运行。</li>
</ul>
<h3 id="使用实例-4"><a href="#使用实例-4" class="headerlink" title="使用实例"></a>使用实例</h3><p>通过这个函数我们可以避免僵尸进程的出现，等待子进程状态的改变，让系统回收子进程的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process, child id:%d parent id:%d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process, child id:%d\n&quot;</span>, id);</span><br><span class="line">        <span class="comment">//status保留已死子进程的信息</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> child_id = wait(&amp;status);</span><br><span class="line">        <span class="comment">//如果子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process are exited with %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果子进程被信号杀死</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process are killed by %d\n&quot;</span>,WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child_id:%d\n&quot;</span>,child_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130212243327.png" alt="image-20231130212243327"></p>
<h2 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h2><p>waitpid()函数是一个用于等待子进程终止的系统调用。与wait()函数不同，waitpid()函数可以指定等待的进程ID，并且提供了更多的选项。</p>
<p>waitpid函数就是wait函数的增强版。</p>
<p>waitpid函数的使用方式waitpid(-1, NULL, 0)等价wait函数的使用wait(NULL)，两者这样使用使一样的。</p>
<h3 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引入的头文件，与wait函数相同</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，pid参数指定了要等待的子进程的进程ID，status参数是用于获取子进程的终止状态的指针，options参数指定了waitpid()函数的行为。</p>
<h3 id="函数参数-6"><a href="#函数参数-6" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="pid参数"><a href="#pid参数" class="headerlink" title="pid参数"></a>pid参数</h4><ul>
<li><code>pid &gt; 0</code>：等待进程ID为pid的子进程结束。</li>
<li><code>pid == 0</code>：等待与当前进程在同一个进程组中的所有子进程结束。</li>
<li><code>pid == -1</code>：等待任何一个子进程结束，与wait()函数相同。</li>
<li><code>pid &lt; -1</code>：等待进程组ID为pid的所有子进程结束。</li>
</ul>
<h4 id="status参数"><a href="#status参数" class="headerlink" title="status参数"></a>status参数</h4><p>是一个指向整型变量的指针，用于获取子进程的退出状态，这一点与wait函数相同。当waitpid()函数返回时，如果status不为NULL，则子进程的退出状态会被存储在status指向的变量中。如果status为空，则子进程的退出状态会被忽略。</p>
<h4 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h4><p>是一个控制waitpid()函数行为的标志位，它可以取以下值：</p>
<ul>
<li><code>WNOHANG</code>：如果没有子进程结束，则立即返回0，不阻塞。</li>
<li><code>WUNTRACED</code>：如果子进程进入暂停状态，也立即返回。</li>
<li><code>WCONTINUED</code>：如果子进程恢复执行，则立即返回。</li>
<li><code>WSTOPPED</code>：等待任何一个子进程进入暂停状态。</li>
<li><code>WEXITED</code>：等待任何一个子进程结束。</li>
<li><code>WNOWAIT</code>：不删除已经结束子进程的进程表项，用于后续处理。</li>
</ul>
<h3 id="函数返回值-7"><a href="#函数返回值-7" class="headerlink" title="函数返回值"></a>函数返回值</h3><ol>
<li>返回结束子进程的进程ID。</li>
<li>如果<code>WNOHANG</code>标志被设置并且没有子进程结束，则返回0。</li>
<li>如果调用进程没有子进程，则返回-1，并设置errno为ECHILD。</li>
<li>如果调用被一个信号中断，则返回-1，并设置errno为EINTR。</li>
</ol>
<h3 id="使用实例-5"><a href="#使用实例-5" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1-2"><a href="#实例1-2" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;child process:child id:%d parent id:%d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process:parent id:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="keyword">while</span> ((ret = waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG)) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="comment">//此时子进程已经死去被回收那么再次调用waitpid时返回值就一定是-1了</span></span><br><span class="line">        ret = waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="comment">//不让父进程死去</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130221629949.png" alt="image-20231130221629949"></p>
<h4 id="实例2-2"><a href="#实例2-2" class="headerlink" title="实例2"></a>实例2</h4><p>使用waitpid回收多个子进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//创建多个子进程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        id = fork();</span><br><span class="line">        <span class="comment">//子进程退出for循环,让其不具备再生能力</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am child process:child id:%d parent id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret_id = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">            <span class="keyword">if</span> (ret_id == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret_id &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ret_id:%d\n&quot;</span>, ret_id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不让父进程死去</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">        sleep(i);<span class="comment">//为了让创建的子进程顺序死亡</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130223225282.png" alt="image-20231130223225282"></p>
<h2 id="pipe函数-无名管道"><a href="#pipe函数-无名管道" class="headerlink" title="pipe函数(无名管道)"></a>pipe函数(无名管道)</h2><h3 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h3><p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。</p>
<p><strong>什么是有血缘关系的进程：</strong> 就是父子进程、兄弟进程等。</p>
<p><strong>管道的原理：</strong>管道实为内核使用<code>环形队列</code>机制，借助内核缓冲区（4k）实现。</p>
<p><strong>512B是磁盘的最小单位，即半k。</strong></p>
<h3 id="管道特质"><a href="#管道特质" class="headerlink" title="管道特质"></a>管道特质</h3><p>  1. 其本质是一个伪文件（实为内核缓冲区）。<br>  2. 由两个文件描述符引用，一个表示读端，一个表示写端。<br>  3. 规定数据从管道的写端流入管道，从读端流出。</p>
<h3 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h3><ol>
<li>数据自己读不能自己写。</li>
<li>数据一旦被读走，便不在管道中存在，不可反复读取。</li>
<li>由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</li>
<li>只能在有公共祖先的进程间使用管道。</li>
</ol>
<p>在Linux中，pipe() 是一个底层系统调用，用于<code>创建管道</code>（pipe）。管道是用于进程间通信的一种简单机制，通过pipe()函数可以创建一个匿名的、单向的管道，可以在不同的进程之间传递数据。</p>
<h3 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//使用函数需导入此头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-7"><a href="#函数参数-7" class="headerlink" title="函数参数"></a>函数参数</h3><p>pipefd是一个两个元素的整型数组，它是一个传出参数，用于<code>存放</code>管道的读写<code>文件描述符</code>。</p>
<ul>
<li>其中<code>pipefd[0]为管道读端</code>，<code>pipefd[1]为管道写端</code>。这两个文件描述符可以像其他文件描述符一样进行读写操作。</li>
<li>管道默认是阻塞的：如果管道中没有数据，read阻塞；如果管道满了，write阻塞。</li>
<li><code>注意</code>：（匿名）管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）。</li>
</ul>
<h3 id="函数返回值-8"><a href="#函数返回值-8" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回0。</li>
<li>失败：返回-1，会设置errno，通过perror函数来打印错误信息。</li>
</ul>
<p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。</p>
<ol>
<li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。<br>  2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道写端，子进程关闭管道读端。子进程可以向管道中写入数据，父进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li>
</ol>
<h3 id="使用实例-6"><a href="#使用实例-6" class="headerlink" title="使用实例"></a>使用实例</h3><p>使用pipe()函数创建一个管道，并在子进程和父进程之间传递数据：</p>
<h4 id="子进程向父进程传达消息"><a href="#子进程向父进程传达消息" class="headerlink" title="子进程向父进程传达消息"></a>子进程向父进程传达消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> retpipe = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span> (retpipe == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);<span class="comment">//关闭父进程写端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ssize_t</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));<span class="comment">//读取子进程写入的信息</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//确保字符串以null结尾</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程,我的进程号是:%d,正在接收来自子进程的信息...\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);<span class="comment">//关闭子进程读端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;我是子进程,我的进程号是:&quot;</span>, getpid());</span><br><span class="line">        <span class="type">ssize_t</span> len = write(pipefd[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));<span class="comment">//子进程写入信息</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130231415551.png" alt="image-20231130231415551"></p>
<h5 id="使用ulimit-–a-命令可以查看管道缓冲大小命令："><a href="#使用ulimit-–a-命令可以查看管道缓冲大小命令：" class="headerlink" title="使用ulimit –a 命令可以查看管道缓冲大小命令："></a>使用ulimit –a 命令可以查看管道缓冲大小命令：</h5><ul>
<li><code>ulimit</code>是一个用于控制shell进程资源限制的命令，在 Linux 系统中经常用于限制某个用户或进程的资源使用。<code>-a</code>是ulimit命令的一个选项，表示显示所有当前限制值的详细信息。当在终端中输入<code>ulimit -a</code>命令后，将会列出所有的资源限制信息：</li>
</ul>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130232006176.png" alt="image-20231130232006176"></p>
<p><code>pipe size (512 bytes, -p) 8</code>这一行表示<strong>管道（pipe）的大小限制</strong>。管道是一种进程间通信（IPC）机制，允许一个进程的输出成为另一个进程的输入。这里的数字“8”表示的是<strong>管道缓冲区大小限制的倍数</strong>。由于括号内提到了每单位的大小为<code>512</code>字节，所以这里的管道大小限制为<code>8 * 512 = 4096</code>字节。</p>
<p>这意味着在使用管道进行进程间通信时，缓冲区最多可以容纳4096字节的数据。当管道的缓冲区被填满时，写入管道的进程将被阻塞，直到另一个进程从管道中读取数据为止。</p>
<h2 id="mkfifo函数-有名管道"><a href="#mkfifo函数-有名管道" class="headerlink" title="mkfifo函数(有名管道)"></a>mkfifo函数(有名管道)</h2><p>有名管道用于非亲缘关系进程之间的通讯。创建有名管道使用到的库函数是：mkfifo()，这里强调是库函数的原因是，mkfifo同时也是一个用户指令。</p>
<ol>
<li>mkfifo函数：创建一个FIFO有名管道文件。</li>
<li>FIFO：称为有名管道，实现无血缘关系管道通信。</li>
<li>创建管道伪文件命令：<code>mkfifo 文件名。</code></li>
<li>示例：先使用<code>mkfifo 文件名</code>创建一个FIFO有名管道文件，然后多个进程读写。</li>
</ol>
<h3 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-8"><a href="#函数参数-8" class="headerlink" title="函数参数"></a>函数参数</h3><p>mkfifo()生成一个名字叫“pathname”的先入先出的特殊文件。mode指定这个文件的权限，一般情况下，它通过进程的掩码被修改：这个创建的文件的权限是（mode &amp; ~umask）。</p>
<h3 id="函数返回值-9"><a href="#函数返回值-9" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回0。</li>
<li>失败：返回-1，表示创建过程中遇到某种错误，此时会设置errno，用户可以检测errno来取得进一步信息。</li>
</ul>
<h3 id="使用实例-7"><a href="#使用实例-7" class="headerlink" title="使用实例"></a>使用实例</h3><p>编写程序FIFOpipe.c，在该程序内，创建有名管道“FIFO”，然后利用open()打开，open()函数返回一个文件描述符fd，使用read()函数从这个文件描述符fd中读取数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    ret = mkfifo(<span class="string">&quot;FIFO&quot;</span>, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waitting for the data from FIFOpipe:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;FIFO&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFOpipe is %s:\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201002931890.png" alt="image-20231201002931890"></p>
<p> 打印提示信息后，阻塞式读取有名管道中的数据。</p>
<p>在FIFO管道中写入信息“HelloLinux”后运行：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201003151223.png" alt="image-20231201003151223"></p>
<h2 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h2><p><code>mmap</code>是一种内存映射文件的方法，即将<strong>一个文件或者其它对象映射到进程的地址空间</strong>，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read，write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><code>munmap</code>执行相反的操作，删除特定地址区域的对象映射。</p>
<p>采用<strong>共享内存通信</strong>的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：<strong>一次从输入文件到共享内存区</strong>，<strong>另一次从共享内存区到输出文件</strong>。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<h3 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数主要用途有三个：</p>
<ul>
<li>将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I&#x2F;O读写，以获得较高的性能。</li>
<li>将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间。</li>
<li>为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。</li>
</ul>
<h3 id="函数参数-9"><a href="#函数参数-9" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>start</code>：指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</p>
<p><code>length</code>：代表将文件中多大的部分映射到内存。</p>
<p><code>prot</code>：映射区域的保护方式。不能与文件的打开模式冲突。是以下的某个值，可以通过<code>or</code>运算合理地组合在一起：</p>
<ul>
<li><code>PROT_READ</code>：页可以被读取。</li>
<li><code>PROT_WRITE</code>：页可以被写入。</li>
<li><code>PROT_NONE</code>：页不可访问。</li>
<li><code>PROT_EXEC</code>：页可以被执行。</li>
</ul>
<p><code>flags</code>：影响映射区域的各种特性，指定映射对象的类型，映射选项和映射页是否可以共享。在调用mmap()时必须要指定<code>MAP_SHARED</code>或<code>MAP_PRIVATE</code>。</p>
<ul>
<li><code>MAP_SHARED</code>：与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到<code>msync()</code>或者<code>munmap()</code>被调用，文件实际上不会被更新。</li>
<li><code>MAP_PRIVATE</code>：对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。这个标志和以上标志是互斥的，只能使用其中一个。</li>
<li><code>MAP_ANONYMOUS</code>：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</li>
<li><code>MAP_DENYWRITE</code>：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</li>
<li><code>MAP_LOCKED</code>：将映射区域锁定住，这表示该区域不会被置换（swap）。</li>
</ul>
<p><code>fd</code>：要映射到内存中的文件描述符。如果使用匿名内存映射时，即MAP_ANONYMOUS被设定，为了兼容问题，其值为-1。</p>
<p><code>offset</code>：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</p>
<h3 id="函数返回值-10"><a href="#函数返回值-10" class="headerlink" title="函数返回值"></a>函数返回值</h3><ol>
<li>成功时返回映射区的首地址。</li>
<li>失败返回MAP_FAILED。</li>
</ol>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>成功执行时，munmap()返回0。</li>
<li>失败时，munmap返回-1，error返回标志和mmap一致；</li>
</ul>
<p>该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap()后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">zy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/blogs/2d14aaf0.html">http://example.com/blogs/2d14aaf0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">Linux常用函数</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/blogs/b9528813.html" title="Linux系统命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Linux系统命令</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">Linux常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#close%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">close函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.1.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">open函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">第一个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">第二个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">第三个参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">实例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B3"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">实例3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">write函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">1.3.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">read函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-3"><span class="toc-number">1.4.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number">1.4.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lseek%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">lseek函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-4"><span class="toc-number">1.5.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-4"><span class="toc-number">1.5.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">1.5.4.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-1"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-1"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">实例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getenv-%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">getenv()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">fork函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-5"><span class="toc-number">1.7.1.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">1.7.2.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">getpid函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getppid%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">getppid函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E6%97%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">exec族函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execl%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.1.</span> <span class="toc-text">execl函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execlp%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">execlp函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.11.</span> <span class="toc-text">孤儿进程与僵尸进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.11.1.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">1.11.2.</span> <span class="toc-text">僵尸进程的危害</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.11.3.</span> <span class="toc-text">孤儿进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">wait函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-5"><span class="toc-number">1.12.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-5"><span class="toc-number">1.12.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-6"><span class="toc-number">1.12.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%AE%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.4.</span> <span class="toc-text">退出信息相关宏函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-4"><span class="toc-number">1.12.5.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.</span> <span class="toc-text">waitpid函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-6"><span class="toc-number">1.13.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-6"><span class="toc-number">1.13.2.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pid%E5%8F%82%E6%95%B0"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">pid参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#status%E5%8F%82%E6%95%B0"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">status参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#options%E5%8F%82%E6%95%B0"><span class="toc-number">1.13.2.3.</span> <span class="toc-text">options参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-7"><span class="toc-number">1.13.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-5"><span class="toc-number">1.13.4.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-2"><span class="toc-number">1.13.4.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-2"><span class="toc-number">1.13.4.2.</span> <span class="toc-text">实例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipe%E5%87%BD%E6%95%B0-%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.14.</span> <span class="toc-text">pipe函数(无名管道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.14.1.</span> <span class="toc-text">管道的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%89%B9%E8%B4%A8"><span class="toc-number">1.14.2.</span> <span class="toc-text">管道特质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.14.3.</span> <span class="toc-text">管道的局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-7"><span class="toc-number">1.14.4.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-7"><span class="toc-number">1.14.5.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-8"><span class="toc-number">1.14.6.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-6"><span class="toc-number">1.14.7.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%90%91%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%BC%A0%E8%BE%BE%E6%B6%88%E6%81%AF"><span class="toc-number">1.14.7.1.</span> <span class="toc-text">子进程向父进程传达消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ulimit-%E2%80%93a-%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%A4%A7%E5%B0%8F%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">1.14.7.1.1.</span> <span class="toc-text">使用ulimit –a 命令可以查看管道缓冲大小命令：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mkfifo%E5%87%BD%E6%95%B0-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.15.</span> <span class="toc-text">mkfifo函数(有名管道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-8"><span class="toc-number">1.15.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-8"><span class="toc-number">1.15.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-9"><span class="toc-number">1.15.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-7"><span class="toc-number">1.15.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0"><span class="toc-number">1.16.</span> <span class="toc-text">mmap函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-9"><span class="toc-number">1.16.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-9"><span class="toc-number">1.16.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-10"><span class="toc-number">1.16.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.16.4.</span> <span class="toc-text">相关函数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2d14aaf0.html" title="Linux常用函数">Linux常用函数</a><time datetime="2023-11-30T05:58:58.000Z" title="Created 2023-11-30 13:58:58">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/b9528813.html" title="Linux系统命令">Linux系统命令</a><time datetime="2023-11-29T00:27:51.000Z" title="Created 2023-11-29 08:27:51">2023-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/66f88466.html" title="Cpp内存管理">Cpp内存管理</a><time datetime="2023-11-25T06:52:29.000Z" title="Created 2023-11-25 14:52:29">2023-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/81b624c3.html" title="Cpp面向对象高级编程">Cpp面向对象高级编程</a><time datetime="2023-11-25T06:30:53.000Z" title="Created 2023-11-25 14:30:53">2023-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/713c1ac0.html" title="Cpp11">Cpp11</a><time datetime="2023-11-22T16:33:02.000Z" title="Created 2023-11-23 00:33:02">2023-11-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By zy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>