<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Linux常用函数 | 久朝暮</title><meta name="keywords" content="Linux常用函数"><meta name="author" content="久朝暮"><meta name="copyright" content="久朝暮"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Linux常用函数"><meta name="application-name" content="Linux常用函数"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Linux常用函数"><meta property="og:url" content="http://example.com/blogs/2d14aaf0.html"><meta property="og:site_name" content="久朝暮"><meta property="og:description" content="Linux常用函数close函数关闭一个文件描述符， 使它不在指向任何文件。在新的文件操作中该文件描述符可以被再次使用。 使用close函数时传入需要关闭文件的文件描述符（即调用open函数的返回值）即可。若关闭文件成功则返回0；若关闭文件失败则返回-1。 函数原型1int close(int fd"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="久朝暮"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="Linux常用函数close函数关闭一个文件描述符， 使它不在指向任何文件。在新的文件操作中该文件描述符可以被再次使用。 使用close函数时传入需要关闭文件的文件描述符（即调用open函数的返回值）即可。若关闭文件成功则返回0；若关闭文件失败则返回-1。 函数原型1int close(int fd"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/blogs/2d14aaf0"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 久朝暮","link":"链接: ","source":"来源: 久朝暮","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '久朝暮',
  title: 'Linux常用函数',
  postAI: '',
  pageFillDescription: 'Linux常用函数, close函数, 函数原型, 函数参数, 函数返回值, open函数, 函数原型, 函数参数, 第一个参数, 第二个参数, 第三个参数, 函数返回值, 使用实例, 实例1, 实例2, 实例3, write函数, 函数原型, 函数参数, 函数返回值, read函数, 函数原型, 函数参数, 函数返回值, 使用实例, perror函数, 函数原型, 函数参数, lseek函数, 函数原型, 函数参数, 函数返回值, 使用实例, 实例1, 实例2, getenv()函数, fork函数, 函数返回值, 使用实例, getpid函数, getppid函数, exec族函数, execl函数, execlp函数, 孤儿进程与僵尸进程, 僵尸进程, 僵尸进程的危害, 孤儿进程, SIGCHLD信号, wait函数, 函数原型, 函数参数, 函数返回值, 退出信息相关宏函数, 使用实例, waitpid函数, 函数原型, 函数参数, pid参数, status参数, options参数, 函数返回值, 使用实例, 实例1, 实例2, pipe函数(无名管道), 管道的概念, 管道特质, 管道的局限性, 函数原型, 函数参数, 函数返回值, 使用实例, 子进程向父进程传达消息, 使用ulimit –a 命令可以查看管道缓冲大小命令：, mkfifo函数(有名管道), 函数原型, 函数参数, 函数返回值, 使用实例, mmap函数, 函数原型, 函数参数, 函数返回值, 相关函数, 使用实例, 实例1, 实例2, 实例3, kill函数, 函数原型, 函数参数, 函数返回值, 使用实例, raise函数, 函数原型, 函数返回值, 使用实例, alarm函数, 函数原型, 函数参数, 函数返回值, 使用实例, setitimer函数, 函数原型, 函数参数, 函数返回值, 与alarm()的区别, 信号集相关函数, 信号处理函数, signal函数, 函数原型, 函数参数, 函数返回值, sigaction函数, 函数原型, 函数参数, 函数返回值, 使用实例, setsid函数, 函数原型, 注意事项, 守护进程, 守护进程概念, 创建守护进程的步骤, 创建一个守护进程, 线程相关, 流程图, pthread_create函数, 函数原型, 函数参数, 函数返回值, 使用实例, pthread_exit函数, 函数原型, 函数参数, 无返回值, 使用实例, pthread_join函数, 函数原型, 函数参数, 函数返回值, 使用实例, pthread_cancel函数, 函数原型, 取消状态以及类型, 取消点, 使用实例, pthread_detach函数, 函数原型, 使用实例, 互斥锁, 初始化锁pthread_mutex_init, 函数原型, 函数参数, 函数返回值, 加锁pthread_mutex_lock和解锁pthread_mutex_unlock, 函数原型, 销毁锁pthread_mutex_destroy(), 函数原型, 读写锁及相关函数, 读写锁创建和销毁, 函数原型, 函数参数, 函数返回值, 读写锁加锁解锁, 函数原型, 函数返回值, 使用实例, 条件变量相关的函数, 函数原型, 使用实例, 信号量相关的函数, 函数原型, 生产者消费者信号量模型, fcntl函数, 函数原型, 函数参数常用函数函数关闭一个文件描述符使它不在指向任何文件在新的文件操作中该文件描述符可以被再次使用使用函数时传入需要关闭文件的文件描述符即调用函数的返回值即可若关闭文件成功则返回若关闭文件失败则返回函数原型函数参数需要关闭的文件或套接字的文件描述符函数返回值若关闭文件成功则返回若关闭文件失败则返回函数用来打开或者创建一个文件或者设备函数原型函数参数第一个参数指定需要打开的文件的路径若以路径的方式给出则需要创建该文件时在路径下进行创建若以文件名的方式给出则需要创建该文件时默认在当前路径下进行创建第二个参数表示打开文件的方式是通过或指明文件是以只读只写或读写方式打开的与下面的零个或多个可选模式按位或操作符得到的如果文件不存在就创建一个新文件通过生成文件若文件已经存在则出错调用失败这个与一起使用如果文件已经存在并且该文件是可写的那么将会设置该文件的长度为清空文件的内容文件以追加模式打开在写之前文件读写指针被置末尾第三个参数指明文件使用的权限传入参数进行文件创建按理应得到权限的文件但却得到了下面权限的文件这是因为权限掩码的存在默认为可以在代码中设置权限掩码来避免上述情况发生设置文件掩码设置成功后的文件权限如下注意当不需创建文件时可以不用设置第三个参数函数返回值返回一个新的文件描述符若是有错误发生返回并在设置错误信息使用实例实例创建文件在指定路径下创建一个新文件在指定路径下创建一个新文件在指定路径下创建一个新文件运行结果为这里我们也可以看出文件描述符的取值最小从开始因为是分配给标准的描述符实例创建文件名运行成功后查看文件的内容发现和的值写进文件中的值为并且永远取未用描述符的最小值实例创建文件简单实现命令缺少了文件操作数这样我们就可以使用创建文件类似于中的命令函数系统接口中使用函数向文件写入信息向文件描述符所引用的文件中写入从开始的缓冲区中个字节的数据规定当使用了之后再使用那么读取到的应该是更新后的数据函数原型函数参数显示数据传输对象的文件描述符保存要传输数据的缓冲地址值要传输数据的字节数函数返回值成功时返回所写入的字节数若为零则表示没有写入数据失败时返回并置为相应值若为零对于普通文件无任何影响但对特殊文件将产生不可预料的后果返回表示没有数据写入函数从文件描述符中读取字节的数据并放入从开始的缓冲区中如果为零返回不执行其他任何操作如果大于那么结果将不可预料函数原型函数参数显示数据接收对象的文件描述符要保存接收数据的缓冲地址值要接收数据的最大字节数函数返回值成功时返回读取的字计数失败时返回并设置的值读到文件末尾的话就返回使用实例模拟命令实现代码运行编译生成的可执行程序可以打开存在的小文件函数函数是一个错误信息输出函数用于在发生系统调用错误时输出有关错误信息的描述其主要作用是将对应的错误信息输出到标准错误输出中工作原理当一个系统调用或库函数发生错误时通常会将全局变量设置为一个特定的错误码函数读取的值并根据这个值生成相应的错误描述然后将错误描述与传入的字符串参数拼接并输出到标准错误流函数原型使用此函数需引入此头文件函数参数一个指向常量字符的指针用于提供上下文信息在输出错误消息时这个字符串将作为错误消息的前缀也就是说可以手动的去描述这个错误是怎么发生的函数函数将与文件描述符相关联的打开文件的偏移量重新定位到参数上如下所示为时表示文件开始位置为时表示当前位置为时表示结尾位置当前文件偏移量每当打开一个文件都会有一个叫做当前文件偏移量的东西如果难理解也可以将他理解为指针除非打开文件时指定选项否则文件偏移量默认设置为当我们发生了一次读或者写操作时都会使这个当前文件偏移量发生变化读写多少字节当前偏移量就会向后移动多少函数原型函数参数文件描述符文件的偏移量位置函数返回值成功返回当前位置到开始的长度失败返回并设置使用实例实例移动文件读写位置用函数写入文件之后这时候读写位置就指在写完后的那个位置也就是字符串的后面这样我们在使用函数去读的时候就相当于从写入字符串的后面去读的所以啥也没读到这时候就可以使用函数来移动读写位置新建一个文件并向其中写入数据然后读取该文件的内容将其写入到屏幕上新建一个文件并写入然后读取该文件的内容将内容输出到屏幕上此时文件指针位置已经到末尾需要重新将指针移到文件首部实例计算文件大小编译成功后第一次运行新建一个原本不存在的文件所以字节数为然后向写点数据第二次运行后函数获取指定的环境变量读取环境变量的值函数函数创建子进程函数是一个系统调用其作用是创建一个新的进程在调用函数时操作系统会复制当前进程的所有信息并将其分配给新的进程新进程与原进程几乎完全相同但有一些区别在新进程中返回值为在原进程中返回值为新进程的因此在程序中可以根据返回值来判断当前代码运行在哪个进程中父进程与子进程运行在不同的内存空间子进程拥有独一无二的但是内存空间的内容是一样的除了一些特殊的比如说进程不一样子进程与父进程的区别由于子进程与父进程非常相似但又有些微小的差别下面我们列举一些常见的区别不同子进程和父进程有不同的可以通过和函数获取不同子进程和父进程有不同的即父亲可以通过函数获取资源占用情况不同子进程会拷贝父亲所有资源情况包括打开文件信号处理等但是有些资源是共享的例如内存映射消息队列等函数返回值失败返回方法被调用一次成功就会有两次返回在父进程中返回一次返回的是子进程的非在子进程中返回一次返回值为使用实例返回值为子进程的创建子进程失败子进程父进程子进程中的有些时候运行结果为为什么是呢这个涉及到孤儿进程的知识原因是父进程已经死了孤儿进程就被进程领养了由进程负责孤儿进程资源的回收当然了你还可以通过以下命令查看孤儿进程被哪个进程领养了或者通过查看父子进程之间的信息函数获取当前进程的函数获取当前进程的父进程的族函数这些族函数的共同特点只有当错误发生才有返回值返回值为这些函数都是可变参数的函数所以参数列表必须以空指针结束函数为环境变量为待执行文件的参数从开始函数为需要执行的程序名孤儿进程与僵尸进程一个进程被创建出来是为了完成用户要求的任务而进程完成任务的结果如何是由其父进程查看的因此在进程退出时不会立即释放该进程对应的资源而是保存一段时间让父进程或者操作系统来读取检查读取后父进程或者操作系统才会回收该进程的所有资源回收后该进程就是死亡状态了而进程退出到还没被回收的期间的状态就是僵尸状态也称僵尸状态僵尸进程僵死状态是一个比较特殊的状态当进程退出并且父进程使用系统调用没有读取到子进程退出的返回代码时就会产生僵死尸进程僵尸进程会以终止状态保持在进程表中并且会一直在等待父进程读取退出状态代码所以只要子进程退出父进程还在运行但父进程没有读取子进程状态子进程进入状态僵尸进程实例子进程父进程僵尸进程的危害维护退出状态本身就是要用数据维护也属于进程基本信息所以保存在即中换句话说状态一直不退出一直都要维护僵尸进程是要求回收的不回收会占用内存造成内存泄露孤儿进程所谓孤儿进程故名思义和现实生活中的孤儿有点类似当一个进程的父进程结束时但是它自己还没有结束那么这个进程将会成为孤儿进程当子进程的父进程挂掉之后子进程会被号进程领养该进程也被称为孤儿进程那么为什么要进行领养呢原因是孤儿进程会被进程号进程领养当然在子进程结束时也会由进程完成对它的状态收集工作因此一般来说孤儿进程并不会有什么危害孤儿进程实例孤儿进程子进程父进程父进程父进程的父进程信号子进程暂停或退出时会主动向父进程发送号信号而父进程对号信号的默认处理动作是忽略为了避免出现僵尸进程父进程需要使用或函数等待子进程结束父进程可以阻塞等待子进程结束也可以非阻塞地查询的是否有子进程结束等待清理即轮询的方式采用第一种方式父进程阻塞就不能处理自己的工作了采用第二种方式父进程在处理自己的工作的同时还要记得时不时地轮询一下程序实现复杂子进程在终止时会给父进程发生信号该信号的默认处理动作是忽略父进程可以自定义信号的处理动作这样父进程就只需专心处理自己的工作不必关心子进程了子进程终止时会通知父进程父进程在信号处理函数中调用或函数清理子进程即可函数等待子进程状态的改变它是一个用于等待子进程结束的函数该函数将暂停当前进程的执行直到一个子进程结束或收到一个信号为止当一个子进程结束时函数会返回该子进程的进程并在参数中返回子进程的退出状态信息调用函数的进程会被挂起阻塞直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒相当于继续往下执行如果没有子进程了函数立刻返回返回如果子进程都已经结束了也会立即返回返回函数原型需要引入的头文件函数原型函数参数进程退出时的状态信息传入的是一个类型的地址传出参数函数返回值成功返回被回收的子进程的失败所有的子进程都结束调用函数失败退出信息相关宏函数非进程正常退出如果为真获取进程退出的状态的参数非进程异常终止如果为真获取使进程终止的信号编号非进程处于暂停状态如果为真获取使进程暂停的信号的编号非进程暂停后已经继续运行使用实例通过这个函数我们可以避免僵尸进程的出现等待子进程状态的改变让系统回收子进程的资源保留已死子进程的信息如果子进程正常退出如果子进程被信号杀死函数函数是一个用于等待子进程终止的系统调用与函数不同函数可以指定等待的进程并且提供了更多的选项函数就是函数的增强版函数的使用方式等价函数的使用两者这样使用使一样的函数原型需要引入的头文件与函数相同函数原型其中参数指定了要等待的子进程的进程参数是用于获取子进程的终止状态的指针参数指定了函数的行为函数参数参数等待进程为的子进程结束等待与当前进程在同一个进程组中的所有子进程结束等待任何一个子进程结束与函数相同等待进程组为的所有子进程结束参数是一个指向整型变量的指针用于获取子进程的退出状态这一点与函数相同当函数返回时如果不为则子进程的退出状态会被存储在指向的变量中如果为空则子进程的退出状态会被忽略参数是一个控制函数行为的标志位它可以取以下值如果没有子进程结束则立即返回不阻塞如果子进程进入暂停状态也立即返回如果子进程恢复执行则立即返回等待任何一个子进程进入暂停状态等待任何一个子进程结束不删除已经结束子进程的进程表项用于后续处理函数返回值返回结束子进程的进程如果标志被设置并且没有子进程结束则返回如果调用进程没有子进程则返回并设置为如果调用被一个信号中断则返回并设置为使用实例实例此时子进程已经死去被回收那么再次调用时返回值就一定是了不让父进程死去实例使用回收多个子进程创建多个子进程子进程退出循环让其不具备再生能力父进程不让父进程死去子进程为了让创建的子进程顺序死亡函数无名管道管道的概念管道是一种最基本的机制作用于有血缘关系的进程之间完成数据传递调用系统函数即可创建一个管道什么是有血缘关系的进程就是父子进程兄弟进程等管道的原理管道实为内核使用环形队列机制借助内核缓冲区实现是磁盘的最小单位即半管道特质其本质是一个伪文件实为内核缓冲区由两个文件描述符引用一个表示读端一个表示写端规定数据从管道的写端流入管道从读端流出管道的局限性数据自己读不能自己写数据一旦被读走便不在管道中存在不可反复读取由于管道采用半双工通信方式因此数据只能在一个方向上流动只能在有公共祖先的进程间使用管道在中是一个底层系统调用用于创建管道管道是用于进程间通信的一种简单机制通过函数可以创建一个匿名的单向的管道可以在不同的进程之间传递数据函数原型使用函数需导入此头文件函数参数是一个两个元素的整型数组它是一个传出参数用于存放管道的读写文件描述符其中为管道读端为管道写端这两个文件描述符可以像其他文件描述符一样进行读写操作管道默认是阻塞的如果管道中没有数据阻塞如果管道满了阻塞注意匿名管道只能用于具有关系的进程之间的通信父子进程兄弟进程函数返回值成功返回失败返回会设置通过函数来打印错误信息管道创建成功以后创建该管道的进程父进程同时掌握着管道的读端和写端父进程调用函数创建管道得到两个文件描述符指向管道的读端和写端父进程调用创建子进程那么子进程也有两个文件描述符指向同一管道父进程关闭管道写端子进程关闭管道读端子进程可以向管道中写入数据父进程将管道中的数据读出由于管道是利用环形队列实现的数据从写端流入管道从读端流出这样就实现了进程间通信使用实例使用函数创建一个管道并在子进程和父进程之间传递数据子进程向父进程传达消息关闭父进程写端读取子进程写入的信息确保字符串以结尾我是父进程我的进程号是正在接收来自子进程的信息关闭子进程读端我是子进程我的进程号是子进程写入信息使用命令可以查看管道缓冲大小命令是一个用于控制进程资源限制的命令在系统中经常用于限制某个用户或进程的资源使用是命令的一个选项表示显示所有当前限制值的详细信息当在终端中输入命令后将会列出所有的资源限制信息这一行表示管道的大小限制管道是一种进程间通信机制允许一个进程的输出成为另一个进程的输入这里的数字表示的是管道缓冲区大小限制的倍数由于括号内提到了每单位的大小为字节所以这里的管道大小限制为字节这意味着在使用管道进行进程间通信时缓冲区最多可以容纳字节的数据当管道的缓冲区被填满时写入管道的进程将被阻塞直到另一个进程从管道中读取数据为止函数有名管道有名管道用于非亲缘关系进程之间的通讯创建有名管道使用到的库函数是这里强调是库函数的原因是同时也是一个用户指令函数创建一个有名管道文件称为有名管道实现无血缘关系管道通信创建管道伪文件命令文件名示例先使用文件名创建一个有名管道文件然后多个进程读写函数原型函数参数生成一个名字叫的先入先出的特殊文件指定这个文件的权限一般情况下它通过进程的掩码被修改这个创建的文件的权限是函数返回值成功返回失败返回表示创建过程中遇到某种错误此时会设置用户可以检测来取得进一步信息使用实例编写程序在该程序内创建有名管道然后利用打开函数返回一个文件描述符使用函数从这个文件描述符中读取数据打印提示信息后阻塞式读取有名管道中的数据在管道中写入信息后运行函数是一种内存映射文件的方法即将一个文件或者其它对象映射到进程的地址空间实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系实现这样的映射关系后进程就可以采用指针的方式读写操作这一段内存而系统会自动回写脏页面到对应的文件磁盘上即完成了对文件的操作而不必再调用等系统调用函数相反内核空间对这段区域的修改也直接反映用户空间从而可以实现不同进程间的文件共享执行相反的操作删除特定地址区域的对象映射采用共享内存通信的一个显而易见的好处是效率高因为进程可以直接读写内存而不需要任何数据的拷贝对于像管道和消息队列等通信方式则需要在内核和用户空间进行四次的数据拷贝而共享内存则只拷贝两次数据一次从输入文件到共享内存区另一次从共享内存区到输出文件实际上进程之间在共享内存时并不总是读写少量数据后就解除映射有新的通信时再重新建立共享内存区域而是保持共享区域直到通信完毕为止这样数据内容一直保存在共享内存中并没有写回文件共享内存中的内容往往是在解除映射时才写回文件的因此采用共享内存的通信方式效率是非常高的函数原型该函数主要用途有三个将一个普通文件映射到内存中通常在需要对文件进行频繁读写时使用这样用内存读写取代读写以获得较高的性能将特殊文件进行匿名内存映射可以为关联进程提供共享内存空间为无关联的进程提供共享内存空间一般也是将一个普通文件映射到内存中函数参数指向欲映射的内存起始地址通常设为代表让系统自动选定地址映射成功后返回该地址代表将文件中多大的部分映射到内存映射区域的保护方式不能与文件的打开模式冲突是以下的某个值可以通过运算合理地组合在一起页可以被读取页可以被写入页不可访问页可以被执行影响映射区域的各种特性指定映射对象的类型映射选项和映射页是否可以共享在调用时必须要指定或与其它所有映射这个对象的进程共享映射空间对共享区的写入相当于输出到文件直到或者被调用文件实际上不会被更新对映射区域的写入操作会产生一个映射文件的复制即私人的写入时复制对此区域作的任何修改都不会写回原来的文件内容这个标志和以上标志是互斥的只能使用其中一个建立匿名映射此时会忽略参数不涉及文件而且映射区域无法和其他进程共享只允许对映射区域的写入操作其他对文件直接写入的操作将会被拒绝将映射区域锁定住这表示该区域不会被置换要映射到内存中的文件描述符如果使用匿名内存映射时即被设定为了兼容问题其值为文件映射的偏移量通常设置为代表从文件最前方开始对应必须是分页大小的整数倍函数返回值成功时返回映射区的首地址失败返回相关函数成功执行时返回失败时返回返回标志和一致该调用在进程地址空间中解除一个映射关系是调用时返回的地址是映射区的大小当映射关系解除后对原来映射地址的访问将导致段错误发生一般说来进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中往往在调用后才执行该操作可以通过调用实现磁盘上文件内容与共享内存区的内容一致使用实例实例将一个普通文件映射到内存中通常在需要对文件进行频繁读写时使用这样用内存读写取代读写以获得较高的性能将文件映射到内存实例函数创建对已知的文件的映射区实现父子进程间的通信创建一个对已知的文件的映射创建子进程子进程父进程回收子进程实例函数实现无血缘关系的进程之间的通信写进程实现不同进程之间的通信将文件的大小截断为指定大小不管之前文件的大小比大还是小读进程实现不同进程之间的通信函数系统调用允许一个进程向另一个进程发送信号这对于进程间通信进程控制以及进程管理等任务非常有用函数原型使用函数需导入这些头文件函数原型函数参数目标进程或进程组的是一个表示进程的数据类型参数可以是以下几种值信号发送给具有该的单个进程信号发送给与调用进程属于同一进程组内的所有进程也就是调用函数的这个进程组的进程都会接受到这个信号发送信号给除了调用进程和进程为以外的所有进程通常情况下这需要调用进程拥有特定权限例如用户权限信号发送给进程组等于绝对值的所有进程简单理解就是如果是则信号将发送给进程组为的所有进程要发送的信号支持多种信号参数可以是整数信号代码也可以是预定义的信号常量以下是一些常用的信号及其说明编号名称解释挂起信号启动被终止的程序也可以让进程重新读取自己的配置文件类似重新启动中断信号用户通过键盘发送的中断相当于输入来中断一个程序杀死信号强制结束进程进程无法捕获或忽略此信号不会进行资源的清理工作如果该程序进行到一半可能会有半成品产生类似的保留下来终止信号以正常优雅的方式来终止进程由程序自身决定该如何终止进程可以捕获并执行清理工作相当于输入来暂停一个程序函数返回值成功返回失败返回并设置来表示错误使用实例发送信号结束子进程我是子进程我是父进程函数当前进程发送指定信号自己给自己发信号相当于函数原型函数返回值成功的时候返回否则返回非零的值并置如果的值是无效的函数就将置为使用实例函数给自己发送信号不输出线程已死函数是一个系统调用用于设置一个实时闹钟当指定的时间以秒为单位到达时系统会发送一个信号给进程这个信号通常用于限制某个程序或者操作的执行时间当闹钟时间到达时若没有设置信号处理程序进程将被终止如果设置了信号处理程序那么在信号处理程序执行完毕后进程会继续执行函数只能设置一个闹钟如果在一个闹钟到期之前再次调用则之前的闹钟将被新的闹钟替代函数原型使用此函数需导入此头文件函数参数闹钟的延迟时间以秒为单位如果参数为则取消之前设置的闹钟闹钟无效不进行倒计时不发信号函数返回值如果之前没有设置闹钟返回如果之前设置了闹钟返回距离上一个闹钟剩余的时间秒数使用实例四秒后终止程序函数是一个系统调用用于设置一个间隔性定时器与函数相比提供了更高级的功能支持设置多个定时器以及定时器的更精确控制当定时器到期时系统会发送一个信号给进程通常用于限制程序或操作的执行时间定期执行任务等当时钟到期一个作用于调用进程的信号产生具体产生什么信号由参数决定函数原型使用此函数需导入此头文件函数参数指定设置哪种类型的定时器有以下三种类型以实时时间递减当时钟到期后发送信号只有在进程执行时才递减时钟到期后发送信号在进程执行和系统执行内核代码时递减时钟到期后发送信号结构体定义间隔时间初始时间指向一个结构体用于设置定时器的初始值和间隔指向一个结构体如果不为用于保存先前设置的定时器值结构体定义秒数微秒数函数返回值成功时返回出错时返回并设置相应的与的区别支持多个定时器和而只支持一个定时器可以设置定时器的间隔时间使定时器在到期后自动重置而只能在指定的时间后触发一次支持微秒级的时间精度而只支持秒级的精度信号集相关函数以下信号集相关的函数都是对自定义的信号集进行操作功能清空信号集中的数据将信号集中的所有的标志位置为参数传出参数需要操作的信号集指向类型的指针是一个信号集类型表示一个信号集返回成功时返回失败时返回并设置表示错误原因功能将信号集中的所有的标志位置为参数同上返回同上功能该函数允许您将一个指定的信号添加到一个自定义信号集中也就是将该信号的标准位设为表示阻塞这个信号参数同上需要设置阻塞的那个信号需要添加到信号集中的信号编号返回同上功能从一个自定义信号集中删除一个指定的信号也就是将该信号的标准位设为不阻塞这个信号参数同上需要设置不阻塞的那个信号需要从信号集中删除的信号编号返回同上功能检查一个指定的信号是否在给定的信号集中也就是检查该信号是否被阻塞参数同上要检查的信号编号返回指定的信号在信号集中被阻塞指定的信号不在信号集中不阻塞调用失败并设置表示错误原因功能获取当前进程中的未决信号集参数传出参数保存的是当前进程中的未决信号集中的信息功能将自定义信号集中的数据设置到内核中设置阻塞解除阻塞替换参数如何对内核阻塞信号集进行处理假设当前的信号屏蔽字为将用户设置的阻塞信号集添加到内核中内核中原来的数据不变则根据用户设置的数据对内核中的数据进行解除阻塞则覆盖内核中原来的值替代原始屏蔽及的新屏蔽集则若调用解除了对当前若干个信号的阻塞则在返回前至少将其中一个信号递达已经初始化好的用户自定义的信号集保存设置之前的内核中的阻塞信号集的状态可以是返回值成功失败设置错误号信号处理函数函数改变对信号的默认处理设置某一信号的对应动作函数原型针对信号处理函数指针简化将定义为返回值为接受一个形参的函数指针此函数必须在被调用前申明中为这个函数的名字当接收到一个类型为的信号时就执行所指定的函数是传递给它的唯一参数执行了调用后进程只要接收到类型为的信号不管其正在执行程序的哪一部分就立即执行函数当函数执行结束后控制权返回进程被中断的那一点继续执行函数参数指明了所要处理的信号类型它可以取除了和外的任何一种信号描述了与信号关联的动作它可以取以下三种值忽略该信号表示恢复对信号的系统默认处理不写此处理函数默认也是执行系统默认操作指定的函数地址则在信号发生时会调用该函数函数返回值返回先前的信号处理函数指针指向信号的处理程序如果有错误则返回函数信号捕捉用于处理和控制信号相比函数提供了更强大且具有可移植性的信号处理能力可以让你定义捕获信号时的行为包括设置信号处理函数和信号处理选项函数原型使用此函数需导入此系统调用结构体只能对或者其中一个赋值信号处理函数常用带有信号信息的信号处理函数不常用在信号处理函数执行期间阻塞的信号集控制信号处理行为的标志位决定你到底是使用还是处理函数这个值可以是表示使用也可以是表示使用已过时不建议使用是一个临时的阻塞信号集它的作用仅仅是在执行某个信号的时候才会去阻塞信号集中的信号在除了执行某个信号的其他时间里不会阻塞任何信号函数参数指定要处理的信号一个指向结构体的指针该结构体包含信号处理函数和信号处理选项捕捉到信号之后的处理动作如果为则不会改变信号的处理行为一个指向结构体的指针用于存储信号原有的处理行为上一次对信号捕捉相关的设置如果为则不会返回信号原有的处理行为函数返回值成功时返回失败时返回并设置以表示错误原因使用实例使用捕获信号当用户按下时产生并执行自定义处理函数捕获到信号清空临时阻塞信号集等待信号在这个示例中设置了一个自定义的信号处理函数用于在接收到信号时执行使用初始化以防止在信号处理函数执行期间阻塞任何其他信号设置为表示使用默认的信号处理行为最后调用设置信号处理函数函数函数用于创建一个新的会话并使得当前进程成为新会话组的组长函数能够使进程完全独立出来从而脱离所有其他进程的控制查看一个进程的会话可以所在列即为会话进程属于一个进程组进程组号就是进程组长的进程号登录会话可以包含多个进程组这些进程组共享一个控制终端这个控制终端通常是创建进程的登录终端控制终端登录会话和进程组通常是从父进程继承下来的进程组和会话的概念如果一个父进程通过函数产生了好多个子进程那么这些父进程和子进程在同一个组内并且进程组和父进程是相同的父进程称为组长同时子进程和父进程在同一个会话内父进程也成为会长每个进程都属于某个进程组进程组是由一个或多个相互间有关联的进程组成的他的目的是为了进行作业控制进程租的主要特征就是信号可以发给进程组中的所有进程这个信号可以使同一个进程组中的所有进程终止停止或者继续运行调用该函数成功后该调用进程成为新的会话组的组长在会话组中创建新的进程组并担任组长同时脱离终端的控制运行在后台该进程成为新会话组和进程组中唯一的进程函数原型本函数成功的话返回调用进程的会话失败返回设置注意事项父进程不能调用此函数父进程调用函数函数返回设置为如果一个会话中会长所在的那个进程中止那么信号将会发送给控制终端下与会长所在进程在同一个进程组的所有进程守护进程守护进程概念守护进程也称精灵进程是运行在后台的一种特殊进程它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件守护进程是一种很有用的进程的大多数服务器就是用守护进程实现的比如服务器服务器等同时守护进程完成许多系统任务比如作业规划进程等系统启动时会启动很多系统服务进程这些系统服务进程没有控制终端不能直接和用户交互其他进程都是在用户登录或运行程序时创建在运行结束或用户注销时终止但系统服务进程不受用户登录注销的影响它们一直在运行着这种进程有一个名称叫守护进程创建守护进程的步骤创建子进程并通过系统调用复制父进程的文件描述符表和信号处理函数在子进程中调用系统调用创建新的会话并成为会话的首进程修改工作目录为根目录以防止守护进程占用文件系统修改当前工作路径重设文件权限掩码以便守护进程创建文件时具有合适的权限关闭不再需要的文件描述符如标准输入标准输出和标准错误输出等处理信号如等可以选择忽略或自定义处理函数运行守护进程的主要逻辑如服务监听数据处理等退出守护进程创建一个守护进程信号捕捉函数创建一个守护进程实现每隔五秒钟创建一个文件创建子进程父进程死亡子进程调用函数子进程当会长切换家目录设置掩码业务逻辑新建闹钟五秒钟后闹钟响起之后每隔五秒钟注册信号处理函数屏蔽信号集当然如果我们的业务不是很复杂可以通过指令达到与守护进程相同的效果指令为表示不让你要执行的程序收到信号表示在后台运行线程相关多线程开发在平台上已经有成熟的库支持其涉及的多线程开发的最基本概念主要包含三点线程互斥锁条件其中线程操作又分线程的创建退出等待种互斥锁则包括种操作分别是创建销毁加锁和解锁条件操作有种操作创建销毁触发广播和等待其他的一些线程扩展概念如信号灯等都可以通过上面的三个基本元素的基本操作封装出来流程图函数创建一个新线程其作用对应进程中函数编译的时候需要加上参数编译动态库线程类型可理解为本质在下为无符号整数其他系统中可能是结构体实现函数原型返回值成功返回失败返回错误编号函数参数用来保存新的线程的由函数获取类似获取进程使用函数用于定制各种不同的线程属性暂可以把它设置为以创建默认属性的线程线程中执行函数新创建的线程从函数的地址开始运行该函数只有一个无类型指针参数该函数运行结束则线程结束即创建线程的回调函数执行函数中所使用的参数如果需要向函数传递的参数不止一个那么需要把这些参数放到一个结构体中然后把这个结构体的地址作为参数传入函数返回值成功返回失败返回错误号可通过函数打印错误信息线程创建成功新线程就会加入到系统调度队列中获取到之后就会立马从函数开始运行该线程的任务调用函数后通常我们无法确定系统接着会调度哪一个线程来使用资源先调度主线程还是新创建的线程呢而在多核或多系统中多核线程可能会在不同的核心上同时执行如果程序对执行顺序有强制要求那么就必须采用一些同步技术来实现这与前面学习父子进程时也出现了这个问题无法确定父进程子进程谁先被系统调度注意在调用失败时通常会返回错误码它并不像其它库函数或系统调用一样设置每个线程都提供了全局变量的副本这只是为了与使用到的函数进行兼容在线程中从函数中返回错误码更为清晰整洁不需要依赖那些随着函数执行不断变化的全局变量这样可以把错误的范围限制在引起出错的函数中使用实例睡一秒让子线程有机会执行完函数返回调用线程的就像函数返回调用进程一样函数退出当前线程对其他线程没有影响如果想要主线程退出而子线程不退出就用函数线程中禁止使用函数会导致进程内所有线程全部退出在多线程环境中应尽量少用或者不使用函数取而代之使用函数将单个线程退出任何线程里导致进程退出其他线程未工作结束主控线程退出时不能或或者返回的指针所指向的内存单元必须是全局的或者是用分配的不能在线程函数的栈上分配因为当其它线程得到这个返回指针时线程函数已经退出了函数原型函数参数参数的数据类型为指定了线程的返回值也就是线程的退出码通常传该返回值可由另一个线程通过调用来获取参数所指向的内容不应分配于线程栈中因为线程终止后将无法确定线程栈的内容是否有效无返回值使用实例让主线程退出进程不退出函数函数来阻塞等待线程的终止并获取线程的退出码回收线程资源调用该函数的线程将挂起等待直到为的线程终止线程以不同的方法终止通过得到的终止状态是不同的总结如下如果线程通过返回所指向的单元里存放的是线程函数的返回值如果线程被别的线程调用异常终止掉所指向的单元里存放的是常数如果线程是自己调用终止的所指向的单元存放的是传给的参数如果对线程的终止状态不感兴趣可以传给参数函数原型函数参数等待指定线程的终止通过参数线程指定需要等待的线程如果参数不为则将目标线程的退出状态即目标线程通过退出时指定的返回值或者在线程函数中执行语句对应的返回值复制到所指向的内存区域如果目标线程被取消则将放在中如果对目标线程的终止状态不感兴趣则可将参数设置为回收那个线程的退出值根据函数里面的参数类型是对其回收就得是函数返回值成功返回失败将返回错误码使用实例即使让子线程睡秒但函数阻塞等待着主线程没有继续往下执行就是创建的子线程的获取线程的返回值函数发送取消请求给指定的线程杀死某个指定的线程但需要达到一个取消点这个取消点就是进入内核如果线程中没有进入内核的契机该函数就杀不死这个线程可以在程序中手动添加一个取消点取消点取消点是指程序中的某个位置在该位置线程可以被取消常见的取消点包括线程阻塞在操作休眠等待锁等地方有时候在程序设计需求当中需要向一个线程发送一个请求要求它立刻退出我们把这种操作称为取消线程也就是向指定的线程发送一个请求要求其立刻终止退出譬如一组线程正在执行一个运算一旦某个线程检测到错误发生需要其它线程退出取消线程这项功能就派上用场了发出取消请求之后函数立即返回不会等待目标线程的退出默认情况下目标线程也会立刻退出其行为表现为如同调用了参数为退出码为的函数但是线程可以设置自己不被取消或者控制如何被取消所以并不会等待线程终止仅仅只是提出请求函数原型取消状态以及类型默认情况下线程会响应其它线程发送的取消请求的响应请求然后退出线程当然线程可以选择不被取消或者设置取消方式通过和来设置线程的取消性状态和类型参数必须是以下值之一线程可以取消这是新创建的线程取消性状态的默认值所以新建线程以及主线程默认都是可以取消的线程不可被取消如果此类线程接收到取消请求则会将请求挂起直至线程的取消性状态变为参数必须是以下值之一取消请求到来时线程还是继续运行取消请求被挂起直到线程到达某个取消点为止这是所有新建线程包括主线程默认的取消性类型可能会在任何时间点也许是立即取消但不一定取消线程这种取消性类型应用场景很少不再介绍取消点取消点其实就是一系列函数当执行到这些函数的时候才会真正响应取消请求这些函数就是取消点在没有出现取消点时取消请求是无法得到处理的究其原因在于系统认为但没有到达取消点时线程此时正在执行的工作是不能被停止的正在执行关键代码此时终止线程将可能会导致出现意想不到的异常发生使用实例检查取消请求创建线程等待一段时间取消线程执行等待线程退出代码的主要逻辑在函数中我们创建了一个子线程并将其执行函数设置为是子线程的执行函数在该函数中我们使用一个循环来模拟线程的工作每秒打印一次计数值这个循环会一直执行直到收到取消请求在主线程中我们使用等待了秒然后调用来发送取消请求给子线程接着我们使用等待子线程退出这样主线程会阻塞直到子线程执行完毕最后主线程输出表示线程成功被取消使用函数来取消线程需要小心处理确保线程在被取消之前完成必要的清理工作以避免资源泄漏或数据不一致的问题在这个例子中子线程中使用来检查取消请求以确保在取消点处退出线程函数执行线程分离将指定的线程标记为可分离的表示该线程在执行结束后会自动释放资源由资源自动回收机制完成无需等待主线程回收另一方面这也意味这主线程无法获得线程的返回值线程分离状态指定该状态线程主动与主控线程断开关系线程结束后其退出状态不由其他线程获取而直接自己自动释放网络多线程服务器常用不能对一个已经处于状态的线程调用这样的调用将返回错误也就是说如果已经对一个线程调用了就不能再调用了一旦线程处于分离状态就不能再使用来获取其终止状态此过程是不可逆的一旦处于分离状态之后便不能再恢复到之前的状态处于分离状态的线程当其终止后能够自动回收线程资源函数原型一个线程既可以将另一个线程分离同时也可以将自己分离譬如使用实例分离线程让子线程全部执行完尝试互斥锁在线程实际运行过程中我们经常需要多个线程保持同步这时可以用互斥锁来完成任务互斥锁的使用过程中主要有初始化锁销毁锁上锁释放锁互斥锁实现了互相排斥同步的简单形式所以名为互斥锁互斥锁禁止多个进程同时进入受保护的代码临界区因此在任意时刻只有一个进程被允许进入这样的代码保护区的语义相对于信号量要简单轻便一些在锁争用激烈的测试场景下比信号量执行速度更快可扩展性更好另外数据结构的定义比信号量小初始化锁是一个函数在使用线程时它是创建线程锁的第一个步骤互斥锁的初始化线程锁是一种用于多线程编程的同步机制它是用来保护共享资源确保在线程要访问共享变量时只有一个线程进行访问使用线程锁能够有效地避免竞争条件的发生是以动态方式创建互斥锁的参数指定了新建互斥锁的属性如果参数为空则使用默认的互斥锁属性默认属性为快速互斥锁互斥锁的属性在创建锁的时候指定在实现中仅有一个锁类型属性不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同定义了一个宏来静态初始化互斥锁使用函数初始化的线程锁在使用完毕后一定要记得调用函数来销毁线程锁并且需要确保所有线程都已退出该锁函数原型函数参数是一个类型指针指向需要进行初始化操作的互斥锁对象是一个类型指针指向一个类型对象该对象用于定义互斥锁的属性若将参数设置为则表示将互斥锁的属性设置为默认值在这种情况下其实就等价于这种方式初始化而不同之处在于使用宏不进行错误检查在不设置属性时第二个参数可以设置为如果设置了属性则需要使用函数对属性进行初始化并通过函数设置属性值再将属性指针作为参数传递给函数常用的属性包括互斥锁可以在多个进程间共享互斥锁是可重入的同一个线程可以多次获取同一个互斥锁释放时也要相应多次互斥锁是带错误检查的如果同一个线程多次获取同一个互斥锁则返回错误码使用互斥锁函数返回值成功返回失败将返回一个非的错误码加锁和解锁调用函数可以对互斥锁加锁获取互斥锁而调用函数可以对互斥锁解锁释放互斥锁两个函数一般需要搭配使用函数原型返回若成功返回否则返回错误编号语义与类似不同的是在锁已经被占据时返回而不是挂起等待如果线程不希望被阻塞它可以使用尝试对互斥量进行加锁如果调用时互斥量处于未锁住状态那么将锁住互斥量不会出现阻塞并返回否则就会失败不能锁住互斥量而返回调用函数将已经处于锁定状态的互斥锁进行解锁以下行为均属错误对处于未锁定状态的互斥锁进行解锁操作解锁由其它线程锁定的互斥锁销毁锁当不再需要互斥锁时应该将其销毁通过调用函数来销毁互斥锁函数原型在调用成功情况下返回失败返回一个非值的错误码不能销毁还没有解锁的互斥锁否则将会出现错误没有初始化的互斥锁也不能销毁被销毁之后的互斥锁就不能再对它进行上锁和解锁了需要再次调用对互斥锁进行初始化之后才能使用读写锁及相关函数读写锁允许更高的并行性也叫共享互斥锁互斥量要么是加锁状态要么就是解锁状态而且一次只有一个线程可以对其加锁读写锁可以有种状态读模式下加锁状态读锁写模式加锁状态写锁不加锁状态一次只有一个线程可以占有写模式的读写锁但是多个线程可以同时占有读模式的读写锁即允许多个线程读但只允许一个线程写写独占读共享读写锁非常适合于对数据结构读的次数远大于写的情况当读操作较多写操作较少时可用读写锁提高线程读并发性适合使用读写锁的场景缓存在多个线程中读取同一个缓存时使用读写锁可以提高程序的并发性从而提高程序的性能数据库在数据库中读操作通常比写操作频繁使用读写锁可以提高并发性从而提高程序的性能日志在日志系统中写操作的频率通常比读操作高得多使用读写锁可以防止读线程被写线程长时间阻塞从而提高程序的性能配置文件在读取配置文件时使用读写锁可以提高程序的并发性从而提高程序的性能读写锁创建和销毁函数原型初始化一个读写锁对象分配使用读写锁需要的资源销毁一个读写锁对象释放被锁使用的资源函数参数需要初始化的读写锁读写锁属性通常使用默认属性传即可函数返回值成功返回失败返回非读写锁加锁解锁函数原型加读锁非阻塞加读锁加写锁非阻塞加写锁释放锁遵循写锁独占读锁共享的原则如果已经给一把锁加上写锁那么再尝试加读锁或者写锁将会阻塞如果一把锁已经加上写锁再尝试加上读锁或者写锁都将会阻塞那么原来的写锁释放之后尝试加上写锁的优先级更高如果一把锁已经加上读锁那么其他线程或者当前线程尝试加上读锁会成功函数返回值成功返回失败返回非使用实例定义读写锁定义共享资源变量读操作其他线程允许读操作不允许写操作读操作其他线程允许读操作不允许写操作写操作其它线程都不允许读或写操作写操作其它线程都不允许读或写操作创建测试线程等待线程结束回收其资源条件变量相关的函数条件变量是一种同步机制用于在多个线程之间传递信息以便协调它们的行为条件变量通常与锁一起使用以便在共享资源上等待特定条件的出现当一个线程需要等待某个条件成立时它可以调用条件变量的等待函数如将当前线程阻塞并将锁释放以便其他线程能够访问共享资源当条件成立时其他线程会通过条件变量的通知函数如或来通知等待的线程从而唤醒它们并重新获取锁条件变量通常与锁一起使用用于解决多个线程之间的同步问题例如多个线程需要等待某个事件的发生例如生产者消费者模型多个线程需要协调执行某个任务例如线程池多个线程需要按照某种顺序执行例如读写锁使用条件变量的一般流程如下初始化互斥锁和条件变量例如和函数在需要等待条件变量的线程中获取互斥锁并使用函数等待条件变量的信号在需要发送条件变量信号的线程中获取互斥锁并使用或函数发送信号在线程退出前使用和函数销毁互斥锁和条件变量使用条件变量需要注意以下几点使用条件变量前需要先初始化可以使用不再使用时应使用销毁条件变量虽然在等待时会释放互斥锁但在被唤醒并从返回时它会再次获得该锁发送条件变量信号时需要获取互斥锁并在发送信号之后释放互斥锁以便等待线程能够获取互斥锁并检查条件由于存在所谓的虚假唤醒线程在被唤醒后应该再次检查条件是否真的满足这也是为什么通常在循环中检查条件在使用条件变量时需要确保共享变量的一致性避免出现竞态条件函数原型初始化一个条件变量参数条件变量参数条件变量属性通常为默认值传即可也可以使用静态初始化的方法初始化条件变量销毁一个条件变量阻塞等待一个条件变量参数条件变量参数锁变量函数作用阻塞等待条件变量满足释放已掌握的互斥锁解锁互斥量相当于两步为一个原子操作当被唤醒后函数返回时解除阻塞并重新申请获取互斥锁该函数使调用线程在指定的条件变量上等待为了等待条件变量线程必须先获取与条件变量相关联的互斥锁当线程调用后它会自动释放这个并将自己置于条件变量的等待队列中当条件变量被或广播时线程被唤醒并重新尝试获取一旦成功获取返回并且线程可以继续执行注意事项在调用之前线程必须持有互斥锁当返回时线程将重新获得互斥锁因此需要在返回后释放互斥锁由于存在伪唤醒即使没有明确的或调用也可能返回这种行为可能是由于多种原因引起的包括操作系统的干扰系统中断或其他未明确指定的原因因此通常建议在循环中检查等待的条件限时等待一个条件变量参数条件变量锁变量绝对时间唤醒至少一个阻塞在条件变量上的线程该函数唤醒在指定条件变量上等待的一个线程如果有多个线程在等待选择哪个线程被唤醒是不确定的注意事项调用并不意味着与之相关的互斥锁会被自动释放信号仅仅表示等待条件的线程可以被唤醒如果没有线程在条件变量上等待调用不会有任何副作用也就是说没有积累的效应如果之后有线程开始等待它不会因为之前的调用而被立即唤醒的核心目的从等待条件的线程队列中选择一个线程并唤醒它使其可以再次运行如果没有线程正在等待那么基本上不做任何事情唤醒全部阻塞在条件变量上的线程这与不同后者只唤醒一个等待该条件的线程注意事项在调用或任何与条件变量相关的函数之前通常需要持有与该条件变量相关联的互斥锁虽然会唤醒所有等待的线程但这并不意味着所有这些线程都会立即开始执行哪个线程首先获得执行权取决于线程调度和优先级等因素使用而不是可能会导致更高的上下文切换开销因为它可能唤醒多个线程因此只有在确实需要唤醒所有线程的情况下才应使用它使用实例生产者消费者条件变量模型头节点一个结点静态初始化锁生产者生产一个结点上菜到链表唤醒消费者消费者加锁等待被唤醒开始消费释放内存创建生产者线程创建消费者线程等待被唤醒这里为啥要用不能用呢为了解决多消费者出现的逻辑问题比如有两个消费者都阻塞在条件变量上此时生产者生产了一个货物会同时唤醒两个条件变量此时两个消费者共同竞争其中一个消费者竞争到锁开始消费另一个消费者会阻塞在上持有锁的消费者消费完成后释放锁此时阻塞在上的消费者可能会拿到锁进行消费但此时公共区可能并没有货物所以阻塞在上的消费者拿到锁后仍需要判断有货物再消费没货物继续等待条件变量唤醒因为需要用不能用信号量相关的函数信号量相当于进化版的互斥锁由于互斥锁的粒度比较大如果我们希望在多个线程间对某一对象的部分数据进行共享使用互斥锁是没有办法实现的只能将整个数据对象锁住这样虽然达到了多线程操作共享数据时保证数据正确性的目的却无形中导致线程的并发性下降线程从并行执行变成了串行执行与直接使用单进程无异信号量是相对折中的一种处理方式既能保证同步数据不混乱又能提高线程并发信号量用于任务间的同步简单来理解信号量是一个被内核维护的整数这个整数一般是大于等于零的我们对这个信号量的操作一般为将信号量设置一个值发布加上一个信号量消耗减去一个信号量等待信号量的值为在下信号量分为命名信号量与未命名信号量未命名信号量也被称为基于内存的信号量类型为创建未命名信号量使用的函数为函数原型编译时需要跟上后缀初始化一个无名信号量函数参数类型的地址处初始化一个无名信号量创建信号量的表示信号量再一个进程的所有线程之间共享非一般取表示再进程之间共享指定信号量的值一般为一个大于等于的整数函数返回值成功返回失败返回设置以指示错误销毁一个信号量被销毁的信号量是之前使用初始化的未命名信号量锁定信号量调用此函数成功的话信号量将会减如果等于该函数会阻塞调用进程直到信号量的值大于为止信号量值大于时该信号量值被减并且函数返回尝试对信号量加锁和函数类似但是调用这个函数失败的话不阻塞而是返回错误限时尝试锁定信号量函数参数信号量采用的是绝对时间调用此函数成功的话信号量将会减一如果调用前信号量的值为那么本函数将会阻塞一定的时间一定的时间过后还是不能锁定信号量那么此函数调用失败并且设置为给信号量解锁调用此函数成功后信号量将会加一生产者消费者信号量模型使用信号量完成线程间同步模拟生产者消费者问题如果队列中有数据生产者不能生产只能阻塞如果队列中没有数据消费者不能消费只能等待数据全局数组实现环形队列空格子信号量产品信号量生产者生产者将空格子数为则阻塞等待生产一个产品将产品数借助下标实现环形消费者消费者将产品数为则阻塞等待消费一个产品消费掉以后将空格子数初始化空格子信号量为产品数为创建生产者和消费者线程等待线程结束销毁信号量函数函数功能是针对文件描述符提供控制根据不同的对文件描述符可以执行的操作也非常多用的最多的是文件记录锁也就是命令此命令搭配结构体对文件进行加解锁操作例如执行加锁操作如果不解锁本进程或者其他进程再次使用命令访问同一文件则会告知目前此文件已经上锁加锁进程退出正常异常后会自行解锁使用此特性可以实现避免程序多次运行锁定文件防止其他进行访问等操作当使用函数设置文件锁后就只能有一个进程打开文件复制一个现有的描述符获得设置文件描述符标记获得设置文件状态标记获得设置异步所有权获得设置记录锁函数原型参数是被参数操作的描述符针对的值能够接受第三个参数函数参数文件描述符操作命令作用复制文件描述符复制的是第一个参数执行成功返回新复制的文件描述符获得的标志若标志未设置则文件经过函数之后仍保持打开状态设置标志该标志以参数的位决定取得文件描述词状态标志此标志为的参数设置文件描述词状态标志参数为新标志但只允许和位的改变其他位的改变将不受影响根据描述取得文件锁定的状态设置描述的文件锁状态此时结构的值必须是或执行成功返回否则无法建立锁定返回错误码为或的阻塞版本命令名中的表示等待若存在其他锁则调用进程睡眠若捕捉到信号则睡眠中断若在阻塞的过程中被信号中断会立即返回错误码为检索将收到和信号的进程号或进程组号设置进程号或进程组号为结构体设置记录锁的具体状态的结构体的指针锁定的状态以下的三个参数用于分段对文件加锁若对整个文件加锁则决定位置锁定区域的开头位置锁定区域的大小锁定动作的进程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-08 15:35:13',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="久朝暮" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">久朝暮</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 文章总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-images"></use></svg><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fan"></use></svg><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/my-equipment/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-equipment"></use></svg><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-STL/" style="font-size: 1.05rem;">C++ STL<sup>1</sup></a><a href="/tags/C-2-0/" style="font-size: 1.05rem;">C++2.0<sup>1</sup></a><a href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">C++内存管理<sup>1</sup></a><a href="/tags/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">C++设计模式<sup>1</sup></a><a href="/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">C++面向对象高级编程<sup>1</sup></a><a href="/tags/Effective-C/" style="font-size: 1.05rem;">Effective C++<sup>1</sup></a><a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" style="font-size: 1.05rem;">Linux常用函数<sup>1</sup></a><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">Linux系统命令<sup>1</sup></a><a href="/tags/UCAS%E8%AF%BE%E7%A8%8B/" style="font-size: 1.05rem;">UCAS课程<sup>1</sup></a><a href="/tags/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%BF%9E%E7%BD%91%E6%8A%80%E6%9C%AF/" style="font-size: 1.05rem;">移动互连网技术<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Linux常用函数</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Linux常用函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-30T05:58:58.000Z" title="发表于 2023-11-30 13:58:58">2023-11-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-12-08T07:35:13.151Z" title="更新于 2023-12-08 15:35:13">2023-12-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/blogs/2d14aaf0.html"><header><a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" tabindex="-1" itemprop="url">Linux常用函数</a><h1 id="CrawlerTitle" itemprop="name headline">Linux常用函数</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">久朝暮</span><time itemprop="dateCreated datePublished" datetime="2023-11-30T05:58:58.000Z" title="发表于 2023-11-30 13:58:58">2023-11-30</time><time itemprop="dateCreated datePublished" datetime="2023-12-08T07:35:13.151Z" title="更新于 2023-12-08 15:35:13">2023-12-08</time></header><h1 id="Linux常用函数"><a href="#Linux常用函数" class="headerlink" title="Linux常用函数"></a>Linux常用函数</h1><h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>关闭一个文件描述符， 使它不在指向任何文件。在新的文件操作中该文件描述符可以被再次使用。</p>
<p>使用close函数时传入需要关闭文件的<strong>文件描述符</strong>（即调用open函数的返回值）即可。若关闭文件成功则返回0；若关闭文件失败则返回-1。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>fd</code>：需要关闭的文件或套接字的文件描述符。</p>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>若关闭文件成功则返回0；若关闭文件失败则返回-1。</p>
<h2 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h2><p>用来打开或者创建一个文件或者设备。</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span> </span><br></pre></td></tr></table></figure>

<h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="第一个参数"><a href="#第一个参数" class="headerlink" title="第一个参数"></a>第一个参数</h4><p><code>pathname</code>：指定需要打开的文件的路径。</p>
<ul>
<li>若pathname以<strong>路径</strong>的方式给出，则需要创建该文件时，在pathname路径下进行创建。</li>
<li>若pathname以<strong>文件名</strong>的方式给出，则需要创建该文件时，默认在当前路径下进行创建。</li>
</ul>
<h4 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h4><p><code>flags</code>：表示打开文件的方式。</p>
<p>flags是通过<code>O_RDONLY</code>, <code>O_WRONLY</code>或<code>O_RDWR</code>（指明文件是以只读 , 只写或读写方式打开的）与下面的零个或多个可选模式<strong>按位或</strong>操作符得到的:</p>
<ul>
<li><code>O_CREATE</code>：如果文件不存在就创建一个新文件。</li>
<li><code>O_EXCL</code>：通过O_CREATE，生成文件，若文件已经存在，则open出错 , 调用失败。这个O_EXCL与O_CREATE一起使用。</li>
<li><code>O_TRUNC</code>：如果文件已经存在，并且该文件是可写的，那么将会设置该文件的长度为0（清空文件的内容）。</li>
<li><code>O_APPEND</code>：文件以追加模式打开，在写之前，文件读写指针被置末尾。</li>
</ul>
<h4 id="第三个参数"><a href="#第三个参数" class="headerlink" title="第三个参数"></a>第三个参数</h4><p><code>mode</code>：指明文件使用的权限。</p>
<p>传入0666参数进行文件创建，按理应得到-rw-rw-rw-权限的文件，但却得到了下面权限的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--</span><br></pre></td></tr></table></figure>

<p>这是因为权限掩码的存在（默认为0002），可以在代码中设置权限掩码来避免上述情况发生：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    umask(<span class="number">0000</span>);<span class="comment">//设置文件掩码                                                                     </span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./log.txt&quot;</span>,O_RDWR | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置成功后的文件权限如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-rw-</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 当不需创建文件时，可以不用设置第三个参数。</p>
<h3 id="函数返回值-1"><a href="#函数返回值-1" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>返回一个新的文件描述符（若是有错误发生返回-1，并在errno设置错误信息）。</p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p>创建test.c文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">//在指定路径下创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./helloworld1.txt&quot;</span>,O_CREAT | O_RDWR | O_TRUNC,<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fd1);</span><br><span class="line">    <span class="comment">//在指定路径下创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd2 = creat(<span class="string">&quot;./helloworld2.txt&quot;</span>,<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fd2);</span><br><span class="line">    <span class="comment">//在指定路径下创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd3 = open(<span class="string">&quot;./helloworld3.txt&quot;</span>,O_CREAT | O_RDWR | O_TRUNC);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fd3);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc test.c -o test</span><br><span class="line">root@vm:/home/wzy/code# ./test</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130142432496.png" alt="image-20231130142432496"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130142340377.png" alt="image-20231130142340377"></p>
<p>这里我们也可以看出文件描述符的取值最小从3开始，因为0，1，2是分配给标准I&#x2F;O的描述符。</p>
<h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><p>创建文件名test2.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./log&quot;</span>,O_CREAT | O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc test.c -o test</span><br><span class="line">root@vm:/home/wzy/code# ./test</span><br></pre></td></tr></table></figure>

<p>运行成功后查看log文件的内容发现Hello和fd的值写进log文件中。fd的值为1；<strong>并且永远取未用描述符的最小值</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130142819174.png" alt="image-20231130142819174" style="zoom: 67%;" />

<h4 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h4><p>创建my_touch.c文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单实现touch命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;touch: 缺少了文件操作数\nTry &#x27;touch --help&#x27; for more information.\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd = open(args[i], O_RDONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc my_touch -o touch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#这样我们就可以使用touch创建文件，类似于Linux中的touch命令</span></span></span><br><span class="line">root@vm:/home/wzy/code# touch 1.c 2.c 3.c</span><br></pre></td></tr></table></figure>

<h2 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h2><p>Linux系统接口中使用write函数向文件写入信息。</p>
<p> write向文件描述符fd所引用的文件中写入从buf开始的缓冲区中count个字节的数据。POSIX规定，当使用了write()之后再使用read()，那么读取到的应该是更新后的数据。</p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-2"><a href="#函数参数-2" class="headerlink" title="函数参数"></a>函数参数</h3><ol>
<li><code>fd</code>：显示数据传输对象的文件描述符。</li>
<li><code>buf</code>：保存要传输数据的缓冲地址值。</li>
<li><code>count</code>：要传输数据的字节数。</li>
</ol>
<h3 id="函数返回值-2"><a href="#函数返回值-2" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>成功时返回所写入的字节数（若为零则表示没有写入数据）。失败时返回-1，并置errno为相应值。若count为零，对于普通文件无任何影响，但对特殊文件将产生不可预料的后果。返回0表示没有数据写入。</p>
<h2 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h2><p>read()从文件描述符fd中读取count字节的数据并放入从buf开始的缓冲区中。如果count为零，read()返回0，不执行其他任何操作。如果 count大于SSIZE_MAX，那么结果将不可预料。</p>
<h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-3"><a href="#函数参数-3" class="headerlink" title="函数参数"></a>函数参数</h3><ol>
<li><code>fd</code>：显示数据接收对象的文件描述符。</li>
<li><code>buf</code>：要保存接收数据的缓冲地址值。</li>
<li><code>count</code>：要接收数据的最大字节数。</li>
</ol>
<h3 id="函数返回值-3"><a href="#函数返回值-3" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>成功时返回读取的字计数；失败时返回-1，并设置errno的值；读到文件末尾的话就返回0。</p>
<h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><p>模拟cat命令实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, args[<span class="number">2</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,args[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        fd = open(args[i], O_RDONLY);</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">        ret = read(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">            write(<span class="number">1</span>, buff, ret);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc cat.c -o cat</span><br><span class="line">root@vm:/home/wzy/code# cat helloworld.txt</span><br><span class="line">This is helloworld.txt.root@vm:/home/wzy/code#</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130144235599.png" alt="image-20231130144235599" style="zoom: 80%;" />

<p>运行编译生成的可执行程序可以打开存在的小文件。</p>
<h2 id="perror函数"><a href="#perror函数" class="headerlink" title="perror函数"></a>perror函数</h2><p>perror函数是一个错误信息输出函数，用于在发生系统调用错误时输出有关错误信息的描述。其主要作用是将errno对应的错误信息输出到标准错误输出中（<em>stderr</em>）。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li>当一个系统调用或库函数发生错误时，通常会将<strong>全局变量errno</strong>设置为一个特定的错误码。perror函数读取errno的值，并根据这个值生成相应的错误描述。然后，将错误描述与传入的字符串参数拼接，并输出到标准错误流。</li>
</ul>
<h3 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//使用此函数需引入此头文件</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-4"><a href="#函数参数-4" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>str</code>：一个指向常量字符的指针，用于提供上下文信息。<strong>在输出错误消息时，这个字符串将作为错误消息的前缀</strong>（也就是说，可以手动的去描述这个错误是怎么发生的）。</p>
<h2 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h2><p>lseek()函数将与文件描述符fd相关联的打开文件的偏移量重新定位到参数offset上，如下所示：</p>
<ol>
<li>SEEK_SET：The offset is set to offset bytes. offset为0时表示文件开始位置。</li>
<li>SEEK_CUR：The offset is set to its current location plus offset bytes. offset为0时表示当前位置。</li>
<li>SEEK_END：The offset is set to the size of the file plus offset bytes. offset为0时表示结尾位置。</li>
</ol>
<p>当前文件偏移量：</p>
<ul>
<li><strong>每当打开一个文件，都会有一个叫做“当前文件偏移量”的东西，如果难理解也可以将他理解为指针。</strong> 除非打开文件时指定O_APPEND选项，否则<strong>文件偏移量默认设置为0</strong>。当我们发生了一次读或者写操作时，都会使这个当前文件偏移量发生变化，读&#x2F;写多少字节，当前偏移量就会向后移动多少。</li>
</ul>
<h3 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-5"><a href="#函数参数-5" class="headerlink" title="函数参数"></a>函数参数</h3><ol>
<li>fd：文件描述符</li>
<li>offset：文件的偏移量</li>
<li>whence：位置</li>
</ol>
<h3 id="函数返回值-4"><a href="#函数返回值-4" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功返回当前位置到开始的长度。</li>
<li>失败返回-1并设置errno。</li>
</ul>
<h3 id="使用实例-2"><a href="#使用实例-2" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1-1"><a href="#实例1-1" class="headerlink" title="实例1"></a>实例1</h4><p>移动文件读写位置。</p>
<p>用write()函数写入文件之后，这时候读写位置就指在写完后的那个位置，也就是字符串的后面，这样我们在使用read()函数去读的时候就相当于从写入字符串的后面去读的，所以啥也没读到。这时候，就可以使用lseek()函数来移动读写位置。<strong>新建一个文件并向其中写入数据，然后读取该文件的内容将其写入到屏幕上：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;not fount file name&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//新建一个文件并写入helloLinux,然后读取该文件的内容,将内容输出到屏幕上.</span></span><br><span class="line">    <span class="type">int</span> fd = open(args[<span class="number">1</span>], O_CREAT | O_RDWR);</span><br><span class="line">    write(fd, <span class="string">&quot;helloLinux&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//此时文件指针位置已经到末尾,需要重新将指针移到文件首部.</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">15</span>];</span><br><span class="line">    <span class="type">int</span> ret = read(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(STDOUT_FILENO, buff, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc lseek.c -o lseek</span><br><span class="line">root@vm:/home/wzy/code# ./lseek lseek.txt</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130160151063.png" alt="image-20231130160151063" style="zoom: 80%;" />

<h4 id="实例2-1"><a href="#实例2-1" class="headerlink" title="实例2"></a>实例2</h4><p>计算文件大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./lseek2.txt&quot;</span>, O_RDONLY | O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成功后第一次运行新建一个原本不存在的文件，所以字节数为0：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130161416525.png" alt="image-20231130161416525"></p>
<p>然后向lseek2.txt写点数据：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130161710271.png" alt="image-20231130161710271"></p>
<p>第二次运行后：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130161618160.png" alt="image-20231130161618160"></p>
<h2 id="getenv-函数"><a href="#getenv-函数" class="headerlink" title="getenv()函数"></a>getenv()函数</h2><p>获取指定的环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br></pre></td></tr></table></figure>

<p>读取环境变量HOME的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;HOME&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130162653378.png" alt="image-20231130162653378" style="zoom:80%;" />

<h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p><strong>fork函数：</strong>：创建子进程。</p>
<p>fork函数是一个系统调用，其作用是创建一个新的进程。在调用fork函数时，操作系统会复制当前进程的所有信息，并将其分配给新的进程。新进程与原进程几乎完全相同，但有一些区别：在新进程中，fork返回值为0；在原进程中，fork返回值为新进程的PID（Process ID）。因此，在程序中可以根据返回值来判断当前代码运行在哪个进程中。</p>
<p><strong>父进程与子进程运行在不同的内存空间，子进程拥有独一无二的task_struct(PCB)，但是内存空间的内容是一样的，除了一些特殊的，比如说进程id不一样。</strong></p>
<p>子进程与父进程的区别：</p>
<p>由于子进程与父进程非常相似，但又有些微小的差别。下面我们列举一些常见的区别：</p>
<p>（1）PID不同：子进程和父进程有不同的PID，可以通过getpid()和getppid()函数获取。</p>
<p>（2）PPID不同：子进程和父进程有不同的PPID（即父亲PID），可以通过getppid()函数获取。</p>
<p>（3）资源占用情况不同：子进程会拷贝父亲所有资源情况（包括打开文件、信号处理等），但是有些资源是共享的，例如内存映射、消息队列等。</p>
<h3 id="函数返回值-5"><a href="#函数返回值-5" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>失败返回-1；<br>fork方法被调用一次，成功就会有两次返回：</p>
<ol>
<li>在父进程中返回一次，返回的是子进程的id（非0）。</li>
<li>在子进程中返回一次，返回值为0。</li>
</ol>
<h3 id="使用实例-3"><a href="#使用实例-3" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin:\n&quot;</span>);</span><br><span class="line">    <span class="comment">//返回值为子进程的id</span></span><br><span class="line">    <span class="type">pid_t</span> child_id = fork();</span><br><span class="line">    <span class="comment">//创建子进程失败</span></span><br><span class="line">    <span class="keyword">if</span> (child_id &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;create child process failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child id:%d parent id:%d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child id:%d self id:%d parent id:%d\n&quot;</span>,child_id, getpid(), getppid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130170512751.png" alt="image-20231130170512751"></p>
<p>子进程中的parent id有些时候运行结果为1，为什么是1呢？</p>
<p>这个涉及到孤儿进程的知识，原因是父进程已经死了，孤儿进程就被init进程领养了，由init进程负责孤儿进程资源的回收。当然了你还可以通过以下命令查看<code>ps aux</code>孤儿进程被哪个进程领养了；或者通过<code>ps ajx</code>查看父子进程之间的信息。</p>
<h2 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a>getpid函数</h2><p>获取当前进程的id。</p>
<h2 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a>getppid函数</h2><p>获取当前进程的父进程的id。</p>
<h2 id="exec族函数"><a href="#exec族函数" class="headerlink" title="exec族函数"></a>exec族函数</h2><p>这些exec族函数的共同特点：</p>
<ol>
<li>只有当错误发生才有返回值，返回值为-1；</li>
<li>这些函数都是可变参数的函数，所以参数列表必须以空指针结束；</li>
</ol>
<h3 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path为环境变量，arg为待执行文件的参数从argv[0]开始</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                       <span class="comment">/* (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file为需要执行的程序名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                       <span class="comment">/* (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h2><p>一个进程被创建出来是为了完成用户要求的任务，而进程完成任务的结果如何是由其父进程查看的，因此在进程退出时，不会立即释放该进程对应的资源，而是保存一段时间，让父进程或者操作系统来读取检查，读取后父进程或者操作系统才会回收该进程的所有资源。<strong>回收后该进程就是死亡状态（X—dead）</strong>了，而<strong>进程退出到还没被回收的期间的状态就是僵尸状态，也称僵尸状态(Z—zombie）</strong>。</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ol>
<li>僵死状态（Zombies）是一个比较特殊的状态。当进程退出并且父进程（使用wait()系统调用）没有读取到子进程退出的返回代码时就会产生僵死（尸）进程。</li>
<li>僵尸进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。</li>
<li>所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入Z状态。</li>
</ol>
<p>僵尸进程实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_id = fork();</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child, child id:%d parent id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process died!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am parent, parent id:%d\n&quot;</span>,getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130174140064.png" alt="image-20231130174140064" style="zoom:80%;" />

<h4 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h4><ul>
<li>维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在<code>task_struct</code>(即PCB)中，换句话说，<code>Z</code><strong>状态一直不退出</strong>，<code>PCB</code><strong>一直都要维护</strong>。</li>
<li>僵尸进程是要求回收的，不回收会占用内存，造成内存泄露。</li>
</ul>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>所谓孤儿进程，故名思义，和现实生活中的孤儿有点类似，当一个进程的父进程结束时，但是它自己还没有结束，那么这个进程将会成为孤儿进程。</p>
<p>当子进程的父进程挂掉之后，子进程会被<code>1</code>号进程领养。该进程也被称为孤儿进程。</p>
<p>那么为什么要进行领养呢：</p>
<ul>
<li>原因是孤儿进程会被init进程（1号进程）领养，当然在子进程结束时也会由init进程完成对它的状态收集工作，因此一般来说，孤儿进程并不会有什么危害。</li>
</ul>
<p>孤儿进程实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_id = fork();</span><br><span class="line">    <span class="comment">//孤儿进程</span></span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程id:%d 父进程id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程id:%d 父进程的父进程id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I will died\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><p>子进程暂停或退出时会主动向父进程发送SIGCHLD（17号）信号。而父进程对17号信号的默认处理动作是忽略。</p>
<ul>
<li>为了避免出现僵尸进程，父进程需要使用wait或waitpid函数等待子进程结束，父进程可以阻塞等待子进程结束，也可以非阻塞地查询的是否有子进程结束等待清理，即轮询的方式。采用第一种方式，父进程阻塞就不能处理自己的工作了；采用第二种方式，父进程在处理自己的工作的同时还要记得时不时地轮询一下，程序实现复杂。</li>
<li>子进程在终止时会给父进程发生SIGCHLD信号，该信号的默认处理动作是忽略。父进程可以自定义SIGCHLD信号的处理动作，这样父进程就只需专心处理自己的工作，不必关心子进程了。子进程终止时会通知父进程，父进程在信号处理函数中调用wait或waitpid函数清理子进程即可。</li>
</ul>
<h2 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h2><p>等待子进程状态的改变。</p>
<p>它是一个<strong>用于等待子进程结束的函数</strong>。该函数将暂停当前进程的执行，直到一个子进程结束或收到一个信号为止。当一个子进程结束时，wait函数会返回该子进程的PID（进程ID），并在status参数中返回子进程的退出状态信息。</p>
<p>调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）。</p>
<p>如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1。</p>
<h3 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引入的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-6"><a href="#函数参数-6" class="headerlink" title="函数参数"></a>函数参数</h3><p>进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</p>
<h3 id="函数返回值-6"><a href="#函数返回值-6" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回被回收的子进程的id。</li>
<li>失败：-1（所有的子进程都结束，调用函数失败）。</li>
</ul>
<h3 id="退出信息相关宏函数"><a href="#退出信息相关宏函数" class="headerlink" title="退出信息相关宏函数"></a>退出信息相关宏函数</h3><ul>
<li><code>WIFEXITED(status)</code>：非0，进程正常退出。</li>
<li><code>WEXITSTATUS(status)</code>：如果<code>WIFEXITED(status)</code>为真，获取进程退出的状态（exit的参数）。</li>
<li><code>WIFSIGNALED(status)</code>：非0，进程异常终止。</li>
<li><code>WTERMSIG(status)</code>：如果<code>WIFSIGNALED(status)</code>为真，获取使进程终止的信号编号。</li>
<li><code>WIFSTOPPED(status)</code>：非0，进程处于暂停状态。</li>
<li><code>WSTOPSIG(status)</code>：如果<code>WIFSTOPPED(status)</code>为真，获取使进程暂停的信号的编号。</li>
<li><code>WIFCONTINUED(status)</code>非0，进程暂停后已经继续运行。</li>
</ul>
<h3 id="使用实例-4"><a href="#使用实例-4" class="headerlink" title="使用实例"></a>使用实例</h3><p>通过这个函数我们可以避免僵尸进程的出现，等待子进程状态的改变，让系统回收子进程的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process, child id:%d parent id:%d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process, child id:%d\n&quot;</span>, id);</span><br><span class="line">        <span class="comment">//status保留已死子进程的信息</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> child_id = wait(&amp;status);</span><br><span class="line">        <span class="comment">//如果子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process are exited with %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果子进程被信号杀死</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process are killed by %d\n&quot;</span>,WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child_id:%d\n&quot;</span>,child_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130212243327.png" alt="image-20231130212243327"></p>
<h2 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h2><p>waitpid()函数是一个用于等待子进程终止的系统调用。与wait()函数不同，waitpid()函数可以指定等待的进程ID，并且提供了更多的选项。</p>
<p>waitpid函数就是wait函数的增强版。</p>
<p>waitpid函数的使用方式waitpid(-1, NULL, 0)等价wait函数的使用wait(NULL)，两者这样使用使一样的。</p>
<h3 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引入的头文件，与wait函数相同</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，pid参数指定了要等待的子进程的进程ID，status参数是用于获取子进程的终止状态的指针，options参数指定了waitpid()函数的行为。</p>
<h3 id="函数参数-7"><a href="#函数参数-7" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="pid参数"><a href="#pid参数" class="headerlink" title="pid参数"></a>pid参数</h4><ul>
<li><code>pid &gt; 0</code>：等待进程ID为pid的子进程结束。</li>
<li><code>pid == 0</code>：等待与当前进程在同一个进程组中的所有子进程结束。</li>
<li><code>pid == -1</code>：等待任何一个子进程结束，与wait()函数相同。</li>
<li><code>pid &lt; -1</code>：等待进程组ID为pid的所有子进程结束。</li>
</ul>
<h4 id="status参数"><a href="#status参数" class="headerlink" title="status参数"></a>status参数</h4><p>是一个指向整型变量的指针，用于获取子进程的退出状态，这一点与wait函数相同。当waitpid()函数返回时，如果status不为NULL，则子进程的退出状态会被存储在status指向的变量中。如果status为空，则子进程的退出状态会被忽略。</p>
<h4 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h4><p>是一个控制waitpid()函数行为的标志位，它可以取以下值：</p>
<ul>
<li><code>WNOHANG</code>：如果没有子进程结束，则立即返回0，不阻塞。</li>
<li><code>WUNTRACED</code>：如果子进程进入暂停状态，也立即返回。</li>
<li><code>WCONTINUED</code>：如果子进程恢复执行，则立即返回。</li>
<li><code>WSTOPPED</code>：等待任何一个子进程进入暂停状态。</li>
<li><code>WEXITED</code>：等待任何一个子进程结束。</li>
<li><code>WNOWAIT</code>：不删除已经结束子进程的进程表项，用于后续处理。</li>
</ul>
<h3 id="函数返回值-7"><a href="#函数返回值-7" class="headerlink" title="函数返回值"></a>函数返回值</h3><ol>
<li>返回结束子进程的进程ID。</li>
<li>如果<code>WNOHANG</code>标志被设置并且没有子进程结束，则返回0。</li>
<li>如果调用进程没有子进程，则返回-1，并设置errno为ECHILD。</li>
<li>如果调用被一个信号中断，则返回-1，并设置errno为EINTR。</li>
</ol>
<h3 id="使用实例-5"><a href="#使用实例-5" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1-2"><a href="#实例1-2" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;child process:child id:%d parent id:%d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process:parent id:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="keyword">while</span> ((ret = waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG)) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="comment">//此时子进程已经死去被回收那么再次调用waitpid时返回值就一定是-1了</span></span><br><span class="line">        ret = waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="comment">//不让父进程死去</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130221629949.png" alt="image-20231130221629949"></p>
<h4 id="实例2-2"><a href="#实例2-2" class="headerlink" title="实例2"></a>实例2</h4><p>使用waitpid回收多个子进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//创建多个子进程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        id = fork();</span><br><span class="line">        <span class="comment">//子进程退出for循环,让其不具备再生能力</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am child process:child id:%d parent id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret_id = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">            <span class="keyword">if</span> (ret_id == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret_id &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ret_id:%d\n&quot;</span>, ret_id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不让父进程死去</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">        sleep(i);<span class="comment">//为了让创建的子进程顺序死亡</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130223225282.png" alt="image-20231130223225282"></p>
<h2 id="pipe函数-无名管道"><a href="#pipe函数-无名管道" class="headerlink" title="pipe函数(无名管道)"></a>pipe函数(无名管道)</h2><h3 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h3><p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。</p>
<p><strong>什么是有血缘关系的进程：</strong> 就是父子进程、兄弟进程等。</p>
<p><strong>管道的原理：</strong>管道实为内核使用<code>环形队列</code>机制，借助内核缓冲区（4k）实现。</p>
<p><strong>512B是磁盘的最小单位，即半k。</strong></p>
<h3 id="管道特质"><a href="#管道特质" class="headerlink" title="管道特质"></a>管道特质</h3><p>  1. 其本质是一个伪文件（实为内核缓冲区）。<br>  2. 由两个文件描述符引用，一个表示读端，一个表示写端。<br>  3. 规定数据从管道的写端流入管道，从读端流出。</p>
<h3 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h3><ol>
<li>数据自己读不能自己写。</li>
<li>数据一旦被读走，便不在管道中存在，不可反复读取。</li>
<li>由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</li>
<li>只能在有公共祖先的进程间使用管道。</li>
</ol>
<p>在Linux中，pipe() 是一个底层系统调用，用于<code>创建管道</code>（pipe）。管道是用于进程间通信的一种简单机制，通过pipe()函数可以创建一个匿名的、单向的管道，可以在不同的进程之间传递数据。</p>
<h3 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//使用函数需导入此头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-8"><a href="#函数参数-8" class="headerlink" title="函数参数"></a>函数参数</h3><p>pipefd是一个两个元素的整型数组，它是一个传出参数，用于<code>存放</code>管道的读写<code>文件描述符</code>。</p>
<ul>
<li>其中<code>pipefd[0]为管道读端</code>，<code>pipefd[1]为管道写端</code>。这两个文件描述符可以像其他文件描述符一样进行读写操作。</li>
<li>管道默认是阻塞的：如果管道中没有数据，read阻塞；如果管道满了，write阻塞。</li>
<li><code>注意</code>：（匿名）管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）。</li>
</ul>
<h3 id="函数返回值-8"><a href="#函数返回值-8" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回0。</li>
<li>失败：返回-1，会设置errno，通过perror函数来打印错误信息。</li>
</ul>
<p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。</p>
<ol>
<li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。<br>  2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道写端，子进程关闭管道读端。子进程可以向管道中写入数据，父进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li>
</ol>
<h3 id="使用实例-6"><a href="#使用实例-6" class="headerlink" title="使用实例"></a>使用实例</h3><p>使用pipe()函数创建一个管道，并在子进程和父进程之间传递数据：</p>
<h4 id="子进程向父进程传达消息"><a href="#子进程向父进程传达消息" class="headerlink" title="子进程向父进程传达消息"></a>子进程向父进程传达消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> retpipe = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span> (retpipe == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);<span class="comment">//关闭父进程写端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ssize_t</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));<span class="comment">//读取子进程写入的信息</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//确保字符串以null结尾</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程,我的进程号是:%d,正在接收来自子进程的信息...\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);<span class="comment">//关闭子进程读端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;我是子进程,我的进程号是:&quot;</span>, getpid());</span><br><span class="line">        <span class="type">ssize_t</span> len = write(pipefd[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));<span class="comment">//子进程写入信息</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130231415551.png" alt="image-20231130231415551"></p>
<h5 id="使用ulimit-–a-命令可以查看管道缓冲大小命令："><a href="#使用ulimit-–a-命令可以查看管道缓冲大小命令：" class="headerlink" title="使用ulimit –a 命令可以查看管道缓冲大小命令："></a>使用ulimit –a 命令可以查看管道缓冲大小命令：</h5><ul>
<li><code>ulimit</code>是一个用于控制shell进程资源限制的命令，在 Linux 系统中经常用于限制某个用户或进程的资源使用。<code>-a</code>是ulimit命令的一个选项，表示显示所有当前限制值的详细信息。当在终端中输入<code>ulimit -a</code>命令后，将会列出所有的资源限制信息：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130232006176.png" alt="image-20231130232006176"></p>
<p><code>pipe size (512 bytes, -p) 8</code>这一行表示<strong>管道（pipe）的大小限制</strong>。管道是一种进程间通信（IPC）机制，允许一个进程的输出成为另一个进程的输入。这里的数字“8”表示的是<strong>管道缓冲区大小限制的倍数</strong>。由于括号内提到了每单位的大小为<code>512</code>字节，所以这里的管道大小限制为<code>8 * 512 = 4096</code>字节。</p>
<p>这意味着在使用管道进行进程间通信时，缓冲区最多可以容纳4096字节的数据。当管道的缓冲区被填满时，写入管道的进程将被阻塞，直到另一个进程从管道中读取数据为止。</p>
<h2 id="mkfifo函数-有名管道"><a href="#mkfifo函数-有名管道" class="headerlink" title="mkfifo函数(有名管道)"></a>mkfifo函数(有名管道)</h2><p>有名管道用于非亲缘关系进程之间的通讯。创建有名管道使用到的库函数是：mkfifo()，这里强调是库函数的原因是，mkfifo同时也是一个用户指令。</p>
<ol>
<li>mkfifo函数：创建一个FIFO有名管道文件。</li>
<li>FIFO：称为有名管道，实现无血缘关系管道通信。</li>
<li>创建管道伪文件命令：<code>mkfifo 文件名。</code></li>
<li>示例：先使用<code>mkfifo 文件名</code>创建一个FIFO有名管道文件，然后多个进程读写。</li>
</ol>
<h3 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-9"><a href="#函数参数-9" class="headerlink" title="函数参数"></a>函数参数</h3><p>mkfifo()生成一个名字叫“pathname”的先入先出的特殊文件。mode指定这个文件的权限，一般情况下，它通过进程的掩码被修改：这个创建的文件的权限是（mode &amp; ~umask）。</p>
<h3 id="函数返回值-9"><a href="#函数返回值-9" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回0。</li>
<li>失败：返回-1，表示创建过程中遇到某种错误，此时会设置errno，用户可以检测errno来取得进一步信息。</li>
</ul>
<h3 id="使用实例-7"><a href="#使用实例-7" class="headerlink" title="使用实例"></a>使用实例</h3><p>编写程序FIFOpipe.c，在该程序内，创建有名管道“FIFO”，然后利用open()打开，open()函数返回一个文件描述符fd，使用read()函数从这个文件描述符fd中读取数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    ret = mkfifo(<span class="string">&quot;FIFO&quot;</span>, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waitting for the data from FIFOpipe:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;FIFO&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFOpipe is %s:\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201002931890.png" alt="image-20231201002931890"></p>
<p> 打印提示信息后，阻塞式读取有名管道中的数据。</p>
<p>在FIFO管道中写入信息“HelloLinux”后运行：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201003151223.png" alt="image-20231201003151223"></p>
<h2 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h2><p><code>mmap</code>是一种内存映射文件的方法，即将<strong>一个文件或者其它对象映射到进程的地址空间</strong>，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read，write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><code>munmap</code>执行相反的操作，删除特定地址区域的对象映射。</p>
<p>采用<strong>共享内存通信</strong>的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：<strong>一次从输入文件到共享内存区</strong>，<strong>另一次从共享内存区到输出文件</strong>。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<h3 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数主要用途有三个：</p>
<ul>
<li>将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I&#x2F;O读写，以获得较高的性能。</li>
<li>将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间。</li>
<li>为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。</li>
</ul>
<h3 id="函数参数-10"><a href="#函数参数-10" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>start</code>：指向欲映射的内存起始地址，通常设为NULL，代表让系统自动选定地址，映射成功后返回该地址。</p>
<p><code>length</code>：代表将文件中多大的部分映射到内存。</p>
<p><code>prot</code>：映射区域的保护方式。不能与文件的打开模式冲突。是以下的某个值，可以通过<code>or</code>运算合理地组合在一起：</p>
<ul>
<li><code>PROT_READ</code>：页可以被读取。</li>
<li><code>PROT_WRITE</code>：页可以被写入。</li>
<li><code>PROT_NONE</code>：页不可访问。</li>
<li><code>PROT_EXEC</code>：页可以被执行。</li>
</ul>
<p><code>flags</code>：影响映射区域的各种特性，指定映射对象的类型，映射选项和映射页是否可以共享。在调用mmap()时必须要指定<code>MAP_SHARED</code>或<code>MAP_PRIVATE</code>。</p>
<ul>
<li><code>MAP_SHARED</code>：与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到<code>msync()</code>或者<code>munmap()</code>被调用，文件实际上不会被更新。</li>
<li><code>MAP_PRIVATE</code>：对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。这个标志和以上标志是互斥的，只能使用其中一个。</li>
<li><code>MAP_ANONYMOUS</code>：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</li>
<li><code>MAP_DENYWRITE</code>：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</li>
<li><code>MAP_LOCKED</code>：将映射区域锁定住，这表示该区域不会被置换（swap）。</li>
</ul>
<p><code>fd</code>：要映射到内存中的文件描述符。如果使用匿名内存映射时，即MAP_ANONYMOUS被设定，为了兼容问题，其值为-1。</p>
<p><code>offset</code>：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</p>
<h3 id="函数返回值-10"><a href="#函数返回值-10" class="headerlink" title="函数返回值"></a>函数返回值</h3><ol>
<li>成功时返回映射区的首地址。</li>
<li>失败返回MAP_FAILED。</li>
</ol>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>成功执行时，munmap()返回0。</li>
<li>失败时，munmap返回-1，error返回标志和mmap一致；</li>
</ul>
<p>该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap()后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p>
<h3 id="使用实例-8"><a href="#使用实例-8" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1-3"><a href="#实例1-3" class="headerlink" title="实例1"></a>实例1</h4><p>将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I&#x2F;O读写，以获得较高的性能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;mmap.txt&quot;</span>, O_RDWR | O_CREAT);</span><br><span class="line">    <span class="comment">//将文件映射到内存</span></span><br><span class="line">    <span class="type">char</span>* mapArea = mmap(<span class="literal">NULL</span>, <span class="number">8</span>, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mapArea == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span> (mapArea, <span class="string">&quot;HelloLinux&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mapArea);</span><br><span class="line">    <span class="type">int</span> ret = munmap(mapArea, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;munmap error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201135241538.png" alt="image-20231201135241538"></p>
<h4 id="实例2-3"><a href="#实例2-3" class="headerlink" title="实例2"></a>实例2</h4><p>mmap函数创建对已知的文件的映射区，实现父子进程间的通信：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个对已知的文件的映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;mmap.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span>* mapArea = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_WRITE | PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mapArea == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *mapArea = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child mapArea:%d\n&quot;</span>, *mapArea);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child mapArea:%d\n&quot;</span>, *mapArea);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *mapArea = <span class="number">88</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent mapArea:%d\n&quot;</span>, *mapArea);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent mapArea:%d\n&quot;</span>, *mapArea);</span><br><span class="line">        *mapArea = <span class="number">1001</span>;</span><br><span class="line">        <span class="comment">//回收子进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201135056270.png" alt="image-20231201135056270"></p>
<h4 id="实例3-1"><a href="#实例3-1" class="headerlink" title="实例3"></a>实例3</h4><p>mmap函数实现无血缘关系的进程之间的通信：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//写进程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;_student;</span><br><span class="line"><span class="comment">//mmap实现不同进程之间的通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:%s fileName\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(_student);</span><br><span class="line">    <span class="comment">//将文件的大小截断为指定大小,不管之前文件的大小比len大还是小</span></span><br><span class="line">    ftruncate(fd, len);</span><br><span class="line">    _student *stu = mmap(<span class="literal">NULL</span>, len, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (stu == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stu-&gt;id = num;</span><br><span class="line">        <span class="built_in">sprintf</span>(stu-&gt;name, <span class="string">&quot;zyzy-%04d\n&quot;</span>, num ++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(stu, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//读进程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;_student;</span><br><span class="line"><span class="comment">//mmap实现不同进程之间的通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:%s fileName\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(_student);</span><br><span class="line">    _student *stu = mmap(<span class="literal">NULL</span>, len, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (stu == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name:%s id:%d\n&quot;</span>, stu-&gt;name, stu-&gt;id);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(stu, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h2><p>kill() 系统调用允许一个进程向另一个进程发送信号。这对于进程间通信、进程控制以及进程管理等任务非常有用。</p>
<h3 id="函数原型-11"><a href="#函数原型-11" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用kill函数需导入这些头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-11"><a href="#函数参数-11" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>pid_t pid</code>：目标进程或进程组的 ID。<code>pid_t</code>是一个表示进程ID的数据类型。<code>pid</code>参数可以是以下几种值：</p>
<ul>
<li><code>pid &gt; 0</code>：信号发送给具有该 PID 的单个进程。</li>
<li><code>pid = 0</code>：信号发送给与调用进程属于同一进程组内的所有进程。也就是调用kill函数的这个进程组的进程都会接受到这个信号。</li>
<li><code>pid = -1</code>：发送信号给除了调用进程和 init 进程（PID 为 1）以外的所有进程。通常情况下，这需要调用进程拥有特定权限，例如root用户权限。</li>
<li><code>pid &lt; -1</code>：信号发送给进程组ID等于pid绝对值的所有进程。简单理解就是，如果pid是-N（N &gt; 1），则信号将发送给进程组ID为N的所有进程。</li>
</ul>
<p><code>int sig</code>：要发送的信号。Linux 支持多种信号，sig参数可以是整数信号代码，也可以是预定义的信号常量。以下是一些常用的信号及其说明：</p>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">名称</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIGHUP</td>
<td align="left">挂起信号，启动被终止的程序，也可以让进程重新读取自己的配置文件，类似重新启动。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SIGINT</td>
<td align="left">中断信号，用户通过键盘发送的中断，相当于输入<code>Ctrl + c</code>来中断一个程序。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">SIGKILL</td>
<td align="left">杀死信号，强制结束进程，进程无法捕获或忽略此信号，不会进行资源的清理工作。如果该程序进行到一半，可能会有半成品产生，类似vim的.filename.swp保留下来。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">SIGTERM</td>
<td align="left">终止信号，以正常（优雅）的方式来终止进程，由程序自身决定该如何终止。进程可以捕获并执行清理工作。</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">SIGSTOP</td>
<td align="left">相当于输入<code>Ctrl + z</code>来暂停一个程序。</td>
</tr>
</tbody></table>
<h3 id="函数返回值-11"><a href="#函数返回值-11" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功，<code>kill</code>返回0。</li>
<li>失败，返回-1，并设置<code>errno</code>来表示错误。</li>
</ul>
<h3 id="使用实例-9"><a href="#使用实例-9" class="headerlink" title="使用实例"></a>使用实例</h3><p>发送<code>SIGINT</code>信号结束子进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是子进程.\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程.\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kill child process now\n&quot;</span>);</span><br><span class="line">        kill(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201153452068.png" alt="image-20231201153452068"></p>
<h2 id="raise函数"><a href="#raise函数" class="headerlink" title="raise函数"></a>raise函数</h2><p>当前进程发送指定信号（自己给自己发信号），<code>raise(sig)</code>相当于<code>kill(getpid(), sig)</code>。</p>
<h3 id="函数原型-12"><a href="#函数原型-12" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span></span><br></pre></td></tr></table></figure>

<h3 id="函数返回值-12"><a href="#函数返回值-12" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>成功的时候，返回0 ，否则返回非零的值，并置errno。</p>
<p>如果sig的值是无效的，raise函数就将errno置为EINVAL。</p>
<h3 id="使用实例-10"><a href="#使用实例-10" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HelloLinux!\n&quot;</span>);</span><br><span class="line">    <span class="comment">//raise函数给自己发送信号</span></span><br><span class="line">    raise(SIGKILL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不输出，main线程已死</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HelloLinux!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h2><p>alarm()是一个Linux系统调用，用于设置一个实时闹钟，当指定的时间（以秒为单位）到达时，系统会发送一个<code>SIGALRM</code>信号给进程。</p>
<ul>
<li>这个信号通常用于限制某个程序或者操作的执行时间。当闹钟时间到达时，若没有设置信号处理程序，进程将被终止。</li>
<li>如果设置了信号处理程序，那么在信号处理程序执行完毕后，进程会继续执行。</li>
</ul>
<p>alarm()函数只能设置一个闹钟。如果在一个闹钟到期之前再次调用alarm()，则之前的闹钟将被新的闹钟替代。</p>
<h3 id="函数原型-13"><a href="#函数原型-13" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//使用此函数，需导入此头文件</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-12"><a href="#函数参数-12" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>seconds</code>：闹钟的延迟时间，以秒为单位。如果参数为0，则取消之前设置的闹钟（闹钟无效，不进行倒计时，不发信号）。</p>
<h3 id="函数返回值-13"><a href="#函数返回值-13" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>如果之前没有设置闹钟，返回0。</li>
<li>如果之前设置了闹钟，返回距离上一个闹钟剩余的时间（秒数）。</li>
</ul>
<h3 id="使用实例-11"><a href="#使用实例-11" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am happy\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = alarm(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ret); <span class="comment">//0</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    ret = alarm(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ret);<span class="comment">//6</span></span><br><span class="line">    <span class="comment">//四秒后终止程序</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhhh\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201164627586.png" alt="image-20231201164627586"></p>
<h2 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h2><p>setitimer()是一个Linux系统调用，用于设置一个间隔性定时器。与alarm()函数相比，setitimer()提供了更高级的功能，支持设置多个定时器以及定时器的更精确控制。当定时器到期时，系统会发送一个信号给进程，通常用于限制程序或操作的执行时间、定期执行任务等。</p>
<p>当时钟到期，一个作用于调用进程的信号产生，具体产生什么信号，由which参数决定。</p>
<h3 id="函数原型-14"><a href="#函数原型-14" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> <span class="comment">// 使用此函数需导入此头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-13"><a href="#函数参数-13" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>which</code>：指定设置哪种类型的定时器。有以下三种类型：</p>
<ul>
<li><code>ITIMER_REAL</code>：以实时时间递减，当时钟到期后，发送<code>SIGALRM</code>信号。</li>
<li><code>ITIMER_VIRTUAL</code>：只有在进程执行时才递减，时钟到期后，发送<code>SIGVTALRM</code>信号。</li>
<li><code>ITIMER_PROF</code>：在进程执行和系统执行内核代码时递减，时钟到期后，发送<code>SIGPROF</code>信号。</li>
</ul>
<p><code>itimerval</code>结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">//间隔时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">//初始时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>new_value</code>：指向一个<code>itimerval</code>结构体，用于设置定时器的初始值和间隔。</li>
<li><code>old_value</code>：指向一个<code>itimerval</code>结构体，如果不为<code>NULL</code>，用于保存先前设置的定时器值。</li>
</ul>
<p><code>timeval</code>结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> tv_sec;  <span class="comment">//秒数</span></span><br><span class="line">	<span class="type">long</span> tv_usec; <span class="comment">//微秒数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="函数返回值-14"><a href="#函数返回值-14" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功时返回0；</li>
<li>出错时返回-1，并设置相应的errno。</li>
</ul>
<h3 id="与alarm-的区别"><a href="#与alarm-的区别" class="headerlink" title="与alarm()的区别"></a>与alarm()的区别</h3><ul>
<li><code>setitimer()</code>支持多个定时器（<code>ITIMER_REAL</code>、<code>ITIMER_VIRTUAL</code>和<code>ITIMER_PROF</code>），而<code>alarm()</code>只支持一个定时器。</li>
<li><code>setitimer()</code>可以设置定时器的间隔时间，使定时器在到期后自动重置，而<code>alarm()</code>只能在指定的时间后触发一次。</li>
<li><code>setitimer()</code>支持微秒级的时间精度，而<code>alarm()</code>只支持秒级的精度。</li>
</ul>
<h2 id="信号集相关函数"><a href="#信号集相关函数" class="headerlink" title="信号集相关函数"></a>信号集相关函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下信号集相关的函数都是对自定义的信号集进行操作:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*功能: 清空信号集中的数据, 将信号集中的所有的标志位置为0.</span></span><br><span class="line"><span class="comment">  参数: </span></span><br><span class="line"><span class="comment">  	set: 传出参数, 需要操作的信号集.指向sigset_t类型的指针，sigset_t是一个信号集类型，表示一个信号集.</span></span><br><span class="line"><span class="comment">  返回: 成功时返回0; 失败时返回-1, 并设置errno表示错误原因.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*功能: 将信号集中的所有的标志位置为1.</span></span><br><span class="line"><span class="comment">  参数: </span></span><br><span class="line"><span class="comment">  	set: 同上.</span></span><br><span class="line"><span class="comment">  返回: 同上.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*功能: 该函数允许您将一个指定的信号添加到一个自定义信号集中，也就是将该信号的标准位设为1，表示阻塞这个信号.</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">  	set: 同上.</span></span><br><span class="line"><span class="comment">  	signum: 需要设置阻塞的那个信号(需要添加到信号集中的信号编号).</span></span><br><span class="line"><span class="comment">  返回: 同上.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*功能: 从一个自定义信号集中删除一个指定的信号，也就是将该信号的标准位设为0，不阻塞这个信号.</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">  	set: 同上.</span></span><br><span class="line"><span class="comment">  	signum: 需要设置不阻塞的那个信号(需要从信号集中删除的信号编号).</span></span><br><span class="line"><span class="comment">  返回: 同上.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*功能: 检查一个指定的信号是否在给定的信号集中,也就是检查该信号是否被阻塞.</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">  	set: 同上.</span></span><br><span class="line"><span class="comment">  	signum: 要检查的信号编号.</span></span><br><span class="line"><span class="comment">  返回:</span></span><br><span class="line"><span class="comment">  	1: 指定的信号在信号集中,signum被阻塞.</span></span><br><span class="line"><span class="comment">  	0: 指定的信号不在信号集中,signum不阻塞</span></span><br><span class="line"><span class="comment">  	-1: 调用失败,并设置errno表示错误原因.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*功能：获取当前进程中的未决信号集.</span></span><br><span class="line"><span class="comment">  参数：</span></span><br><span class="line"><span class="comment">  	set: 传出参数，保存的是当前进程中的未决信号集中的信息.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">/*功能: 将自定义信号集中的数据设置到内核中(设置阻塞, 解除阻塞, 替换).</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">  	how: 如何对内核阻塞信号集进行处理, 假设当前的信号屏蔽字为mask.</span></span><br><span class="line"><span class="comment">  		SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中, 内核中原来的数据不变.则mask = mask|set.</span></span><br><span class="line"><span class="comment">		SIG_UNBLOCK: 根据用户设置的数据, 对内核中的数据进行解除阻塞.则mask = mask&amp;(~set).</span></span><br><span class="line"><span class="comment">		SIG_SETMASK: 覆盖内核中原来的值(替代原始屏蔽及的新屏蔽集).则mask = set.若调用sigprocmask解除了对当前若干个信号的					     阻塞，则在sigprocmask返回前，至少将其中一个信号递达.</span></span><br><span class="line"><span class="comment">	set: 已经初始化好的用户自定义的信号集.</span></span><br><span class="line"><span class="comment">	oldset: 保存设置之前的内核中的阻塞信号集的状态, 可以是NULL.</span></span><br><span class="line"><span class="comment">  返回值:</span></span><br><span class="line"><span class="comment">	成功: 0</span></span><br><span class="line"><span class="comment">	失败: -1 </span></span><br><span class="line"><span class="comment">		设置错误号:EFAULT / EINVAL.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><p>改变对信号的默认处理（设置某一信号的对应动作）。</p>
<h4 id="函数原型-15"><a href="#函数原型-15" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>针对信号处理函数指针简化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//将sighandler_t定义为返回值为void，接受一个int形参的函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>

<p>此函数必须在signal()被调用前申明，handler中为这个函数的名字。当接收到一个类型为sig的信号时，就执行handler所指定的函数。（int）signum是传递给它的唯一参数。执行了signal()调用后，进程只要接收到类型为sig的信号，不管其正在执行程序的哪一部分，就立即执行func()函数。当func()函数执行结束后，控制权返回进程被中断的那一点继续执行。 </p>
<h4 id="函数参数-14"><a href="#函数参数-14" class="headerlink" title="函数参数"></a>函数参数</h4><p><code>signum</code>：指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。 　 </p>
<p><code>handler</code>：描述了与信号关联的动作，它可以取以下三种值： </p>
<ul>
<li><code>SIG_IGN</code>：忽略该信号。</li>
<li><code>SIG_DFL</code>：表示恢复对信号的系统默认处理。不写此处理函数默认也是执行系统默认操作。 </li>
<li>指定的函数地址，则在信号发生时会调用该函数。</li>
</ul>
<h4 id="函数返回值-15"><a href="#函数返回值-15" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>返回先前的信号处理函数指针，指向sig信号的处理程序，如果有错误则返回SIG_ERR（-1）。</p>
<h3 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h3><p>（信号捕捉）用于处理和控制信号，相比signal()函数，sigaction()提供了更强大且具有可移植性的信号处理能力。sigaction()可以让你定义捕获信号时的行为，包括设置信号处理函数和信号处理选项。</p>
<h4 id="函数原型-16"><a href="#函数原型-16" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> <span class="comment">// 使用此函数，需导入此系统调用</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>sigaction结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="comment">//只能对sa_handler或者sa_sigaction其中一个赋值.</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);        <span class="comment">//信号处理函数，常用.</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">//带有信号信息的信号处理函数，不常用.</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;               <span class="comment">//在信号处理函数执行期间阻塞的信号集.</span></span><br><span class="line">    <span class="type">int</span> sa_flags;                   <span class="comment">//控制信号处理行为的标志位，决定你到底是使用sa_handler还是sa_sigaction处理函数,</span></span><br><span class="line">    								<span class="comment">//这个值可以是0, 表示使用sa_handler, 也可以是SA_SIGINFO表示使用sa_sigaction.</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);      <span class="comment">//已过时，不建议使用.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sa_mask</code>是一个临时的阻塞信号集，它的作用仅仅是在执行某个信号的时候，才会去阻塞信号集中的信号，在除了执行某个信号的其他时间里，不会阻塞任何信号。</p>
<h4 id="函数参数-15"><a href="#函数参数-15" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li><code>int signum</code>：指定要处理的信号。</li>
<li><code>const struct sigaction *act</code>：一个指向sigaction结构体的指针，该结构体包含信号处理函数和信号处理选项（捕捉到信号之后的处理动作）。如果为NULL，则不会改变信号的处理行为。</li>
<li><code>struct sigaction *oldact</code>：一个指向sigaction结构体的指针，用于存储信号原有的处理行为（上一次对信号捕捉相关的设置）。如果为NULL，则不会返回信号原有的处理行为。</li>
</ul>
<h4 id="函数返回值-16"><a href="#函数返回值-16" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul>
<li>成功时，返回0；</li>
<li>失败时，返回-1，并设置errno以表示错误原因。</li>
</ul>
<h4 id="使用实例-12"><a href="#使用实例-12" class="headerlink" title="使用实例"></a>使用实例</h4><p>使用sigaction()捕获SIGINT信号（当用户按下Ctrl+C时产生）并执行自定义处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕获到信号%d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">ss</span>;</span></span><br><span class="line">    ss.sa_handler = sigint_handler;</span><br><span class="line">    sigemptyset(&amp;ss.sa_mask);<span class="comment">//清空临时阻塞信号集</span></span><br><span class="line">    ss.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;ss, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等待信号...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，设置了一个自定义的信号处理函数sigint_handler，用于在接收到SIGINT信号时执行。使用sigemptyset()初始化sa_mask，以防止在信号处理函数执行期间阻塞任何其他信号。sa_flags设置为0，表示使用默认的信号处理行为。最后，调用sigaction()设置信号处理函数。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203003129680.png" alt="image-20231203003129680" style="zoom:67%;" />

<h2 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a>setsid函数</h2><p>setsid函数用于创建一个新的会话，并使得当前进程成为新会话组的组长。setsid函数能够使进程完全独立出来，从而脱离所有其他进程的控制。查看一个进程的会话id可以<code>ps ajx</code>，所在列SID即为会话id。</p>
<p>进程属于一个进程组，进程组号(GID)就是进程组长的进程号(PID)。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端，登录会话和进程组通常是从父进程继承下来的。</p>
<p><strong>进程组和会话的概念：</strong> 如果一个父进程通过fork函数产生了好多个子进程，那么这些父进程和子进程在同一个组内，并且进程组id和父进程id是相同的，父进程称为组长。同时子进程和父进程在同一个会话内，父进程也成为会长。</p>
<p>每个进程都属于某个进程组，进程组是由一个或多个相互间有关联的进程组成的，他的目的是为了进行作业控制。进程租的主要特征就是信号可以发给进程组中的所有进程：这个信号可以使同一个进程组中的所有进程终止，停止或者继续运行。</p>
<p>调用该函数成功后，该调用进程成为新的会话组的组长，在会话组中创建新的进程组并担任组长。同时脱离终端的控制，运行在后台。该进程成为新会话组和进程组中唯一的进程。</p>
<h3 id="函数原型-17"><a href="#函数原型-17" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//本函数成功的话返回调用进程的会话id；失败返回-1，设置errno</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>父进程不能调用此函数</strong>。父进程调用setsid函数，函数返回-1，设置ERROR为EPERM。</li>
<li>如果一个会话中会长所在的那个进程中止，那么SIGHUP信号将会发送给控制终端下与会长所在进程在同一个进程组的所有进程。</li>
</ol>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><h3 id="守护进程概念"><a href="#守护进程概念" class="headerlink" title="守护进程概念"></a>守护进程概念</h3><p>守护进程也称精灵进程（Daemon），是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</p>
<p>守护进程是一种很有用的进程，Linux的大多数服务器就是用守护进程实现的，比如Internet服务器inetd，Web服务器httpd等。同时守护进程完成许多系统任务，比如作业规划进程crond等。</p>
<p>Linux系统启动时会启动很多系统服务进程，这些系统服务进程没有控制终端，不能直接和用户交互。其他进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但系统服务进程不受用户登录注销的影响，它们一直在运行着，这种进程有一个名称叫守护进程（Daemon）。</p>
<h3 id="创建守护进程的步骤"><a href="#创建守护进程的步骤" class="headerlink" title="创建守护进程的步骤"></a>创建守护进程的步骤</h3><ol>
<li>创建子进程，并通过<code>fork</code>系统调用复制父进程的文件描述符表和信号处理函数。</li>
<li>在子进程中调用<code>setsid</code>系统调用创建新的会话，并成为会话的首进程。</li>
<li>修改工作目录为根目录，以防止守护进程占用文件系统。（<code>chdir()</code>：修改当前工作路径）</li>
<li>重设文件权限掩码，以便守护进程创建文件时具有合适的权限。（umask(0)；）</li>
<li>关闭不再需要的文件描述符，如标准输入、标准输出和标准错误输出等。</li>
<li>处理信号，如SIGCHLD、SIGHUP等，可以选择忽略或自定义处理函数。</li>
<li>运行守护进程的主要逻辑，如服务监听、数据处理等。</li>
<li>退出守护进程。</li>
</ol>
<h3 id="创建一个守护进程"><a href="#创建一个守护进程" class="headerlink" title="创建一个守护进程"></a>创建一个守护进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creatFile</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> fileName[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(fileName,<span class="number">0</span>,<span class="keyword">sizeof</span>(fileName));</span><br><span class="line">    <span class="built_in">sprintf</span>(fileName, <span class="string">&quot;%s/example/zy.%ld&quot;</span>, getenv(<span class="string">&quot;HOME&quot;</span>),time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> fd = open(fileName, O_CREAT | O_TRUNC | O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个守护进程，实现每隔五秒钟创建一个文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建子进程，父进程死亡</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程调用setsid函数,子进程当会长</span></span><br><span class="line">    setsid();</span><br><span class="line">    <span class="comment">//切换家目录</span></span><br><span class="line">    chdir(getenv(<span class="string">&quot;HOME&quot;</span>));</span><br><span class="line">    <span class="comment">//设置掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//业务逻辑</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//新建闹钟</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">myit</span> =</span> &#123;&#123;<span class="number">5</span>,<span class="number">0</span>&#125;, &#123;<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;  <span class="comment">//五秒钟后闹钟响起，之后每隔五秒钟</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;myit, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//注册信号处理函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span>;</span></span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sig.sa_handler = creatFile;</span><br><span class="line">    <span class="comment">//屏蔽信号集</span></span><br><span class="line">    sigemptyset(&amp;sig.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果我们的业务不是很复杂，可以通过nohup指令达到与守护进程相同的效果。指令为<code>nohup yourcommand [&gt;xxx.log] &amp;</code>；nohup表示不让你要执行的程序yourcommand收到信号SIGHUP，&amp;表示在后台运行。</p>
<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><p>多线程开发在 Linux 平台上已经有成熟的 pthread 库支持。其涉及的多线程开发的最基本概念主要包含三点：线程，互斥锁，条件。其中，线程操作又分线程的创建，退出，等待 3 种。互斥锁则包括 4 种操作，分别是创建，销毁，加锁和解锁。条件操作有 5 种操作：创建，销毁，触发，广播和等待。其他的一些线程扩展概念，如信号灯等，都可以通过上面的三个基本元素的基本操作封装出来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203202217896.png" alt="image-20231203202217896"></p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203225501899.png" alt="image-20231203225501899"></p>
<h2 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h2><p>创建一个新线程。 其作用，对应进程中fork()函数。</p>
<p>g++&#x2F;gcc编译的时候需要加上参数<code>-pthread</code>，编译pthread动态库。</p>
<p>线程ID：<code>pthread_t</code>类型，可理解为：typedef unsigned long int pthread_t；本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现。</p>
<h3 id="函数原型-18"><a href="#函数原型-18" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回错误编号</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数-16"><a href="#函数参数-16" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>pthread_t *thread</code>：用来保存新的线程的id，由函数<code>pthread_self()</code>获取，类似获取进程pid使用getpid()函数。</p>
<p><code>const pthread_attr_t *attr</code>：用于定制各种不同的线程属性，暂可以把它设置为NULL，以创建默认属性的线程。</p>
<p><code>void *(*start_routine) (void *)</code>：线程中执行函数。新创建的线程从start_rtn函数的地址开始运行，该函数只有一个无类型指针参数arg。该函数运行结束，则线程结束，即创建线程的回调函数。</p>
<p><code>void *arg</code>：执行函数中所使用的参数。如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构体中，然后把这个结构体的地址作为arg参数传入。</p>
<h3 id="函数返回值-17"><a href="#函数返回值-17" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回0；</li>
<li>失败：返回错误号，可通过strerror函数打印错误信息。</li>
</ul>
<p>线程创建成功，新线程就会加入到系统调度队列中，获取到 CPU 之后就会立马从 start_routine()函数开始运行该线程的任务；调用 pthread_create()函数后，通常我们无法确定系统接着会调度哪一个线程来使用 CPU 资源，先调度主线程还是新创建的线程呢（而在多核 CPU 或多 CPU 系统中，多核线程可能会在不同的核心上同时执行）？如果程序对执行顺序有强制要求，那么就必须采用一些同步技术来实现。这与前面学习父、子进程时也出现了这个问题，无法确定父进程、子进程谁先被系统调度。</p>
<p>注意 pthread_create()在调用失败时通常会返回错误码，它并不像其它库函数或系统调用一样设置 errno， 每个线程都提供了全局变量 errno 的副本，这只是为了与使用 errno 到的函数进行兼容，在线程中，从函数中返回错误码更为清晰整洁，不需要依赖那些随着函数执行不断变化的全局变量，这样可以把错误的范围限制在引起出错的函数中。</p>
<h3 id="使用实例-13"><a href="#使用实例-13" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current thread:process id:%d thread id:%lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main process:process id:%d thread id:%lu thread:%lu\n&quot;</span>, getpid(), pthread_self(), thread);</span><br><span class="line">    <span class="comment">//睡一秒让子线程有机会执行完</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203201803667.png" alt="image-20231203201803667"></p>
<p><strong>pthread_self</strong>函数：返回调用线程的id，就像getpid()函数返回调用进程id一样。</p>
<h2 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h2><p>退出当前线程，对其他线程没有影响；如果想要主线程退出而子线程不退出，就用pthread_exit函数。</p>
<p>线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p>
<p>在多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</p>
<p>pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p>
<h3 id="函数原型-19"><a href="#函数原型-19" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-17"><a href="#函数参数-17" class="headerlink" title="函数参数"></a>函数参数</h3><p>参数<code>retval</code>的数据类型为 void *，指定了线程的返回值、也就是线程的退出码，通常传NULL，该返回值可由另一个线程通过调用 pthread_join()来获取。</p>
<p>参数<code>retval</code>所指向的内容不应分配于<strong>线程栈</strong>中，因为线程终止后，将无法确定线程栈的内容是否有效。</p>
<h3 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值"></a>无返回值</h3><h3 id="使用实例-14"><a href="#使用实例-14" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am another thread:tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="comment">//让主线程退出,进程不退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203204936482.png" alt="image-20231203204936482"></p>
<h2 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h2><p>pthread_join()函数来阻塞等待线程的终止， 并获取线程的退出码，回收线程资源。</p>
<p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<ul>
<li>如果<code>thread</code>线程通过<code>return</code>返回，<code>retval</code>所指向的单元里存放的是<code>thread</code>线程函数的返回值。</li>
<li>如果<code>thread</code>线程被别的线程调用<code>pthread_cancel</code>异常终止掉，<code>retval</code>所指向的单元里存放的是常数<code>PTHREAD_CANCELED</code>。</li>
<li>如果<code>thread</code>线程是自己调用<code>pthread_exit</code>终止的，<code>retval</code>所指向的单元存放的是传给<code>pthread_exit</code>的参数。</li>
<li>如果对<code>thread</code>线程的终止状态不感兴趣，可以传<code>NULL</code>给<code>retval</code>参数。</li>
</ul>
<h3 id="函数原型-20"><a href="#函数原型-20" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-18"><a href="#函数参数-18" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>thread</code>：pthread_join()等待指定线程的终止，通过参数thread（线程 ID）指定需要等待的线程。</p>
<p><code>retval</code>：如果参数retval不为NULL，则pthread_join()将目标线程的退出状态（即目标线程通过pthread_exit()退出时指定的返回值或者在线程start函数中执行return语句对应的返回值）复制到retval所指向的内存区域；如果目标线程被pthread_cancel()取消，则将PTHREAD_CANCELED放在<code>*retval</code>中。如果对目标线程的终止状态不感兴趣，则可将参数retval设置为NULL。（回收那个线程的退出值，根据pthread_exit函数里面的参数类型是<code>void*</code>，对其回收就得是<code>void**</code>。）</p>
<h3 id="函数返回值-18"><a href="#函数返回值-18" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功返回0。</li>
<li>失败将返回错误码。</li>
</ul>
<h3 id="使用实例-15"><a href="#使用实例-15" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am subthread\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">4</span>);<span class="comment">//即使让子线程睡4秒,但pthread_join函数阻塞等待着,主线程没有继续往下执行.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//tid就是创建的子线程的id</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">void</span>* ret;</span><br><span class="line">    pthread_join(tid, &amp;ret);</span><br><span class="line">    <span class="comment">//获取线程的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret:%s\n&quot;</span>, (<span class="type">char</span>*)ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am main thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203211755776.png" alt="image-20231203211755776"></p>
<h2 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h2><p>发送取消请求给指定的线程，杀死某个指定的线程。但需要达到一个<strong>取消点</strong>。这个取消点就是进入内核，如果线程中没有进入内核的契机，该函数就杀不死这个线程。可以在程序中手动添加一个取消点<code>pthread_testcancel()</code>；</p>
<p>取消点：取消点是指程序中的某个位置，在该位置线程可以被取消。常见的取消点包括线程阻塞在I&#x2F;O操作、休眠、等待锁等地方。</p>
<p> 有时候，在程序设计需求当中，需要向一个线程发送一个请求，要求它立刻退出，我们把这种操作称为取消线程，也就是向指定的线程发送一个请求，要求其立刻终止、退出。譬如，一组线程正在执行一个运算， 一旦某个线程检测到错误发生，需要其它线程退出，取消线程这项功能就派上用场了。</p>
<p>  发出取消请求之后，函数<code>pthread_cancel()</code>立即返回，不会等待目标线程的退出。默认情况下，目标线程也会立刻退出，其行为表现为如同调用了参数为PTHREAD_CANCELED（退出码为-1）的pthread_exit()函数，但是，线程可以设置自己不被取消或者控制如何被取消，所以 pthread_cancel()并不会等待线程终止，仅仅只是提出请求。</p>
<h3 id="函数原型-21"><a href="#函数原型-21" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="取消状态以及类型"><a href="#取消状态以及类型" class="headerlink" title="取消状态以及类型"></a>取消状态以及类型</h3><p>默认情况下，线程会响应其它线程发送的取消请求的，响应请求然后退出线程。当然，线程可以选择不被取消或者设置取消方式，通过 pthread_setcancelstate()和 pthread_setcanceltype()来设置线程的取消性状态和类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure>

<p>参数<code>state</code>必须是以下值之一：</p>
<ul>
<li><code>PTHREAD_CANCEL_ENABLE</code>：线程可以取消，这是新创建的线程取消性状态的默认值，所以新建线程以及主线程<strong>默认</strong>都是可以取消的。</li>
<li><code>PTHREAD_CANCEL_DISABLE</code>：线程不可被取消，如果此类线程接收到取消请求，则会将请求挂起，直至线程的取消性状态变为 PTHREAD_CANCEL_ENABLE。</li>
</ul>
<p>参数<code>type</code>必须是以下值之一：</p>
<ul>
<li><code>PTHREAD_CANCEL_DEFERRED</code>：取消请求到来时，线程还是继续运行，取消请求被挂起，直到线程到达某个取消点为止，这是所有新建线程包括主线程<strong>默认</strong>的取消性类型。</li>
<li><code>PTHREAD_CANCEL_ASYNCHRONOUS</code>：可能会在任何时间点（也许是立即取消，但不一定） 取消线程，这种取消性类型应用场景很少，不再介绍。</li>
</ul>
<h3 id="取消点"><a href="#取消点" class="headerlink" title="取消点"></a>取消点</h3><p>取消点其实就是一系列函数，当执行到这些函数的时候，才会真正响应取消请求，这些函数就是取消点；在没有出现取消点时，取消请求是无法得到处理的，究其原因在于系统认为，但没有到达取消点时，线程此时正在执行的工作是不能被停止的，正在执行关键代码，此时终止线程将可能会导致出现意想不到的异常发生。</p>
<h3 id="使用实例-16"><a href="#使用实例-16" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running, count: %d\n&quot;</span>, count);</span><br><span class="line">        count ++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查取消请求</span></span><br><span class="line">    pthread_testcancel();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread cancellation requested. Exiting...\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待一段时间</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//取消线程执行</span></span><br><span class="line">    pthread_cancel(thread);</span><br><span class="line">    <span class="comment">//等待线程退出</span></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread cancelling successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203224115465.png" alt="image-20231203224115465"></p>
<p>代码的主要逻辑：</p>
<ol>
<li><p>在<code>main()</code>函数中，我们创建了一个子线程<code>thread</code>，并将其执行函数设置为<code>carryFunc</code>。</p>
</li>
<li><p><code>carryFunc</code>是子线程的执行函数。在该函数中，我们使用一个循环来模拟线程的工作，每秒打印一次计数值<code>count</code>。这个循环会一直执行，直到收到取消请求。</p>
</li>
<li><p>在主线程中，我们使用<code>sleep(3)</code>等待了3秒，然后调用<code>pthread_cancel(thread)</code>来发送取消请求给子线程。</p>
</li>
<li><p>接着，我们使用<code>pthread_join(thread, NULL)</code>等待子线程退出。这样，主线程会阻塞直到子线程执行完毕。</p>
</li>
<li><p>最后，主线程输出<code>&quot;Thread canceled successfully.&quot;</code>表示线程成功被取消。</p>
</li>
</ol>
<p>使用<code>pthread_cancel()</code>函数来取消线程需要小心处理，确保线程在被取消之前完成必要的清理工作，以避免资源泄漏或数据不一致的问题。在这个例子中，子线程中使用<code>pthread_testcancel()</code>来检查取消请求，以确保在取消点处退出线程。</p>
<h2 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h2><p>执行线程分离。将指定的线程标记为 “可分离的“，表示该线程在执行结束后会自动释放资源（由资源自动回收机制完成），无需等待主线程回收。另一方面，这也意味这主线程无法获得线程的返回值。</p>
<ul>
<li><p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p>
</li>
<li><p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
</li>
</ul>
<p>一旦线程处于分离状态，就不能再使用 pthread_join()来获取其终止状态，此过程是不可逆的，一旦处于分离状态之后便不能再恢复到之前的状态。处于分离状态的线程，当其终止后，能够自动回收线程资源。</p>
<h3 id="函数原型-22"><a href="#函数原型-22" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p>一个线程既可以将另一个线程分离，同时也可以将自己分离，譬如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(pthread_self());</span><br></pre></td></tr></table></figure>

<h3 id="使用实例-17"><a href="#使用实例-17" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;subthread:tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">    sleep(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;subthread:tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//分离线程</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    <span class="comment">//让子线程全部执行完</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//尝试pthread_join</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (ret = pthread_join(tid, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret:%d error string:%s\n&quot;</span>, ret, strerror(ret));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203231848423.png" alt="image-20231203231848423"></p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>在线程实际运行过程中，我们经常需要多个线程保持同步。这时可以用互斥锁来完成任务。互斥锁的使用过程中，主要有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init;<span class="comment">//初始化锁</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_destory;<span class="comment">//销毁锁</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_lock;<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock;<span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>

<p>互斥锁实现了“互相排斥”（<em>mutual exclusion</em>）同步的简单形式，所以名为互斥锁。互斥锁禁止多个进程同时进入受保护的代码“临界区”（<em>critical section</em>）。因此，在任意时刻，只有一个进程被允许进入这样的代码保护区。</p>
<p>mutex的语义相对于信号量要简单轻便一些，在锁争用激烈的测试场景下，mutex比信号量执行速度更快，可扩展性更好，另外mutex数据结构的定义比信号量小。</p>
<h2 id="初始化锁pthread-mutex-init"><a href="#初始化锁pthread-mutex-init" class="headerlink" title="初始化锁pthread_mutex_init"></a>初始化锁pthread_mutex_init</h2><p><code>pthread_mutex_init</code>是一个函数，在使用线程时，它是创建线程锁的第一个步骤，互斥锁的初始化。线程锁是一种用于多线程编程的同步机制，它是用来保护共享资源，确保在线程要访问共享变量时，只有一个线程进行访问。使用线程锁能够有效地避免竞争条件的发生。</p>
<p><code>pthread_mutex_init()</code>是以<strong>动态方式</strong>创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空（<em>NULL</em>），则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。</p>
<p>POSIX定义了一个宏<code>PTHREAD_MUTEX_INITIALIZER</code>来静态初始化互斥锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>使用<code>pthread_mutex_init</code>函数初始化的线程锁，在使用完毕后一定要记得调用<code>pthread_mutex_destroy</code>函数来销毁线程锁，并且需要确保所有线程都已退出该锁。</p>
<h3 id="函数原型-23"><a href="#函数原型-23" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* attr)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-19"><a href="#函数参数-19" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>mutex</code>：是一个<code>pthread_mutex_t</code>类型指针，指向需要进行初始化操作的互斥锁对象。</p>
<p><code>attr</code>：是一个<code>pthread_mutexattr_t</code>类型指针，指向一个<code>pthread_mutexattr_t</code>类型对象，该对象<strong>用于定义互斥锁的属性</strong>，若将参数attr设置为NULL，则表示将互斥锁的属性设置为默认值，在这种情况下其实就等价于<code>PTHREAD_MUTEX_INITIALIZER</code>这种方式初始化，而不同之处在于， 使用宏不进行错误检查。</p>
<p>在不设置属性时，第二个参数可以设置为NULL。如果设置了属性，则需要使用<code>pthread_mutexattr_init</code>函数对属性进行初始化，并通过<code>pthread_mutexattr_settype</code>函数设置属性值，再将属性指针作为参数传递给<code>pthread_mutex_init</code>函数。</p>
<p>pthread_mutex_init常用的属性包括：</p>
<ul>
<li><code>PTHREAD_PROCESS_SHARED</code>：互斥锁可以在多个进程间共享。</li>
<li><code>PTHREAD_MUTEX_RECURSIVE</code>：互斥锁是可重入的，同一个线程可以多次获取同一个互斥锁，释放时也要相应多次。</li>
<li><code>PTHREAD_MUTEX_ERRORCHECK</code>：互斥锁是带错误检查的，如果同一个线程多次获取同一个互斥锁，则返回错误码EBUSY。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, &amp;attr);</span><br><span class="line">    <span class="comment">// 使用互斥锁</span></span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数返回值-19"><a href="#函数返回值-19" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功返回0。</li>
<li>失败将返回一个非0的错误码。</li>
</ul>
<h2 id="加锁pthread-mutex-lock和解锁pthread-mutex-unlock"><a href="#加锁pthread-mutex-lock和解锁pthread-mutex-unlock" class="headerlink" title="加锁pthread_mutex_lock和解锁pthread_mutex_unlock"></a>加锁pthread_mutex_lock和解锁pthread_mutex_unlock</h2><p>调用函数 <code>pthread_mutex_lock()</code>可以对互斥锁加锁、获取互斥锁，而调用函数 <code>pthread_mutex_unlock()</code>可以对互斥锁解锁、释放互斥锁。两个函数一般需要搭配使用。</p>
<h3 id="函数原型-24"><a href="#函数原型-24" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p><code>pthread_mutex_trylock()</code>语义与<code>pthread_mutex_lock()</code>类似，不同的是在锁已经被占据时返回EBUSY而不是挂起等待。</p>
<ul>
<li>如果线程不希望被阻塞，它可以使用<code>pthread_mutex_trylock()</code>尝试对互斥量进行加锁。如果调用<code>pthread_mutex_trylock()</code>时互斥量处于未锁住状态，那么<code>pthread_mutex_trylock()</code>将锁住互斥量，不会出现阻塞并返回0，否则<code>pthread_mutex_trylock()</code>就会失败，不能锁住互斥量，而返回EBUSY。</li>
</ul>
<p>调用 pthread_mutex_unlock()函数将已经处于锁定状态的互斥锁进行解锁。以下行为均属错误：</p>
<ul>
<li>对处于未锁定状态的互斥锁进行解锁操作；</li>
<li>解锁由其它线程锁定的互斥锁。</li>
</ul>
<h2 id="销毁锁pthread-mutex-destroy"><a href="#销毁锁pthread-mutex-destroy" class="headerlink" title="销毁锁pthread_mutex_destroy()"></a>销毁锁pthread_mutex_destroy()</h2><p>当不再需要互斥锁时，应该将其销毁，通过调用 <code>pthread_mutex_destroy()</code>函数来销毁互斥锁。</p>
<h3 id="函数原型-25"><a href="#函数原型-25" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>在调用成功情况下返回0，失败返回一个非0值的错误码。</p>
<ul>
<li>不能销毁还没有解锁的互斥锁，否则将会出现错误；</li>
<li>没有初始化的互斥锁也不能销毁。</li>
</ul>
<p>被<code>pthread_mutex_destroy()</code>销毁之后的互斥锁，就不能再对它进行上锁和解锁了，需要再次调用<code>pthread_mutex_init()</code>对互斥锁进行初始化之后才能使用。</p>
<h2 id="读写锁及相关函数"><a href="#读写锁及相关函数" class="headerlink" title="读写锁及相关函数"></a>读写锁及相关函数</h2><p>读写锁允许更高的并行性，也叫共享互斥锁。互斥量要么是加锁状态，要么就是解锁状态，而且一次只有一个线程可以对其加锁。</p>
<p>读写锁可以有3种状态：</p>
<ol>
<li>读模式下加锁状态（读锁）。</li>
<li>写模式加锁状态（写锁）。</li>
<li>不加锁状态。</li>
</ol>
<p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁，即允许多个线程读但只允许一个线程写（写独占，读共享）。</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。当读操作较多，写操作较少时，可用读写锁提高线程读并发性。</p>
<p>适合使用读写锁的场景：</p>
<ul>
<li><strong>缓存</strong>：在多个线程中读取同一个缓存时，使用读写锁可以提高程序的并发性，从而提高程序的性能。</li>
<li><strong>数据库</strong>：在数据库中，读操作通常比写操作频繁。使用读写锁可以提高并发性，从而提高程序的性能。</li>
<li><strong>日志</strong>：在日志系统中，写操作的频率通常比读操作高得多。使用读写锁可以防止读线程被写线程长时间阻塞，从而提高程序的性能。</li>
<li><strong>配置文件</strong>：在读取配置文件时，使用读写锁可以提高程序的并发性，从而提高程序的性能。</li>
</ul>
<h3 id="读写锁创建和销毁"><a href="#读写锁创建和销毁" class="headerlink" title="读写锁创建和销毁"></a>读写锁创建和销毁</h3><h4 id="函数原型-26"><a href="#函数原型-26" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//初始化一个读写锁对象,分配使用读写锁需要的资源.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">phtread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">//销毁一个读写锁对象,释放被锁使用的资源.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="函数参数-20"><a href="#函数参数-20" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li><code>rwlock</code>：需要初始化的读写锁。</li>
<li><code>attr</code>：读写锁属性，通常使用默认属性，传NULL即可。</li>
</ul>
<h4 id="函数返回值-20"><a href="#函数返回值-20" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul>
<li>成功返回0。</li>
<li>失败返回非0。</li>
</ul>
<h3 id="读写锁加锁解锁"><a href="#读写锁加锁解锁" class="headerlink" title="读写锁加锁解锁"></a>读写锁加锁解锁</h3><h4 id="函数原型-27"><a href="#函数原型-27" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 加读锁 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;<span class="comment">//非阻塞加读锁</span></span><br><span class="line"><span class="comment">/* 加写锁 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;<span class="comment">//非阻塞加写锁</span></span><br><span class="line"><span class="comment">/* 释放锁 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<p>遵循写锁独占，读锁共享的原则：</p>
<ul>
<li>如果已经给一把锁加上写锁，那么再尝试加读锁或者写锁将会阻塞。</li>
<li>如果一把锁已经加上写锁，再尝试加上读锁或者写锁都将会阻塞，那么原来的写锁释放之后，尝试加上写锁的优先级更高。</li>
<li>如果一把锁已经加上读锁，那么其他线程或者当前线程尝试加上读锁会成功。</li>
</ul>
<h4 id="函数返回值-21"><a href="#函数返回值-21" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul>
<li>成功返回0。</li>
<li>失败返回非0。</li>
</ul>
<h3 id="使用实例-18"><a href="#使用实例-18" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 定义读写锁 */</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">/* 定义共享资源变量 */</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="comment">/* 读操作 其他线程允许读操作 不允许写操作 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read thread1 %d\n&quot;</span>, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 读操作，其他线程允许读操作，不允许写操作 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read thread2 %d\n&quot;</span>, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 写操作，其它线程都不允许读或写操作 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun3</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write thread1 \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 写操作，其它线程都不允许读或写操作 */</span> </span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun4</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write thread2 \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2, tid3, tid4;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/* 创建测试线程 */</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, fun3, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid4, <span class="literal">NULL</span>, fun4, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待线程结束，回收其资源 */</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid4, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件变量相关的函数"><a href="#条件变量相关的函数" class="headerlink" title="条件变量相关的函数"></a>条件变量相关的函数</h2><p>条件变量是一种同步机制，用于在多个线程之间传递信息，以便协调它们的行为。条件变量通常与锁一起使用，以便在共享资源上等待特定条件的出现。</p>
<p>当一个线程需要等待某个条件成立时，它可以调用条件变量的等待函数（如<code>pthread_cond_wait()</code>），将当前线程阻塞，并将锁释放，以便其他线程能够访问共享资源。当条件成立时，其他线程会通过条件变量的通知函数（如<code>pthread_cond_signal()</code>或<code>pthread_cond_broadcast()</code>）来通知等待的线程，从而唤醒它们并重新获取锁。</p>
<p>条件变量通常与锁一起使用，用于<strong>解决多个线程之间的同步问题</strong>。例如：</p>
<ul>
<li>多个线程需要等待某个事件的发生，例如生产者消费者模型。</li>
<li>多个线程需要协调执行某个任务，例如线程池。</li>
<li>多个线程需要按照某种顺序执行，例如读写锁。</li>
</ul>
<p>使用条件变量的一般<strong>流程</strong>如下：</p>
<p>1、初始化互斥锁和条件变量，例如<code>pthread_mutex_init</code>和<code>pthread_cond_init</code>函数；<br>2、在需要等待条件变量的线程中获取互斥锁，并使用<code>pthread_cond_wait</code>函数等待条件变量的信号；<br>3、在需要发送条件变量信号的线程中获取互斥锁，并使用<code>pthread_cond_signal</code>或<code>pthread_cond_broadcast</code>函数发送信号；<br>4、在线程退出前，使用<code>pthread_mutex_destroy</code>和<code>pthread_cond_destroy</code>函数销毁互斥锁和条件变量。</p>
<p>使用条件变量需要注意以下几点：</p>
<ul>
<li>使用条件变量前，需要先初始化，可以使用<code>pthread_cond_init</code>。</li>
<li>不再使用时，应使用<code>pthread_cond_destroy</code>销毁条件变量。</li>
<li>虽然<code>pthread_cond_wait</code>在等待时会释放互斥锁，但在被唤醒并从<code>pthread_cond_wait</code>返回时，它会再次获得该锁。</li>
<li>发送条件变量信号时需要获取互斥锁，并在发送信号之后释放互斥锁，以便等待线程能够获取互斥锁并检查条件。</li>
<li>由于存在所谓的”虚假唤醒”（<em>spurious wakeup</em>），线程在被唤醒后应该再次检查条件是否真的满足，这也是为什么通常在while循环中检查条件。</li>
<li>在使用条件变量时需要确保共享变量的一致性，避免出现竞态条件。</li>
</ul>
<h3 id="函数原型-28"><a href="#函数原型-28" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//初始化一个条件变量。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">/*参数1: cond条件变量</span></span><br><span class="line"><span class="comment">  参数2: attr条件变量属性，通常为默认值，传 NULL 即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//也可以使用静态初始化的方法，初始化条件变量:</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁一个条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞等待一个条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1:cond条件变量</span></span><br><span class="line"><span class="comment">参数2:mutex锁变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数作用:</span></span><br><span class="line"><span class="comment">1.阻塞等待条件变量cond满足</span></span><br><span class="line"><span class="comment">2.释放已掌握的互斥锁(解锁互斥量)相当于pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line"><span class="comment">1、2两步为一个原子操作.</span></span><br><span class="line"><span class="comment">3.当被唤醒后,pthread_cond_wait函数返回时,解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>该函数使调用线程在指定的条件变量<code>cond</code>上等待。为了等待条件变量，线程必须先获取与条件变量相关联的互斥锁<code>mutex</code>。当线程调用<code>pthread_cond_wait</code>后，它会自动释放这个<code>mutex</code>，并将自己置于条件变量的等待队列中。当条件变量被<code>signal</code>或广播时，线程被唤醒并重新尝试获取<code>mutex</code>。一旦成功获取，<code>pthread_cond_wait</code>返回，并且线程可以继续执行。</p>
<p><strong>注意事项</strong>：</p>
<ul>
<li>在调用<code>pthread_cond_wait</code>之前，线程必须持有互斥锁<code>mutex</code>。</li>
<li>当<code>pthread_cond_wait</code>返回时，线程将重新获得互斥锁，因此需要在返回后释放互斥锁。</li>
<li>由于存在“伪唤醒”，即使没有明确的<code>pthread_cond_signal</code>或<code>pthread_cond_broadcast</code>调用，<code>pthread_cond_wait</code>也可能返回（这种行为可能是由于多种原因引起的，包括操作系统的干扰、系统中断或其他未明确指定的原因）。因此，通常建议在循环中检查等待的条件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限时等待一个条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  cond:条件变量</span></span><br><span class="line"><span class="comment">  mutex:锁变量</span></span><br><span class="line"><span class="comment">  abstime:绝对时间</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒至少一个阻塞在条件变量上的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">//该函数唤醒在指定条件变量cond上等待的一个线程.如果有多个线程在等待,选择哪个线程被唤醒是不确定的.</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li>调用<code>pthread_cond_signal</code>并不意味着与之相关的互斥锁<code>mutex</code>会被自动释放。信号仅仅表示等待条件的线程可以被唤醒。</li>
<li>如果没有线程在条件变量上等待，调用<code>pthread_cond_signal</code>不会有任何副作用。也就是说，没有“积累”的效应；如果之后有线程开始等待，它不会因为之前的<code>pthread_cond_signal</code>调用而被立即唤醒。</li>
</ul>
<p><code>pthread_cond_signal</code>的<strong>核心目的</strong>：从等待条件的线程队列中选择一个线程并唤醒它，使其可以再次运行。如果没有线程正在等待，那么<code>pthread_cond_signal</code>基本上不做任何事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒全部阻塞在条件变量上的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">//这与pthread_cond_signal不同,后者只唤醒一个等待该条件的线程.</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>在调用<code>pthread_cond_broadcast</code>（或任何与条件变量相关的函数）之前，通常需要持有与该条件变量相关联的互斥锁。</li>
<li>虽然<code>pthread_cond_broadcast</code>会唤醒所有等待的线程，但这并不意味着所有这些线程都会立即开始执行。哪个线程首先获得执行权取决于<strong>线程调度</strong>和<strong>优先级</strong>等因素。</li>
<li>使用<code>pthread_cond_broadcast</code>而不是<code>pthread_cond_signal</code>可能会导致更高的上下文切换开销，因为它可能唤醒多个线程。因此，只有在确实需要唤醒所有线程的情况下，才应使用它。</li>
</ul>
<h3 id="使用实例-19"><a href="#使用实例-19" class="headerlink" title="使用实例"></a>使用实例</h3><p>生产者消费者条件变量模型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pc</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;PC;</span><br><span class="line">PC *head = <span class="literal">NULL</span>;<span class="comment">//头节点</span></span><br><span class="line">PC *mp = <span class="literal">NULL</span>;  <span class="comment">//一个结点</span></span><br><span class="line"><span class="comment">//静态初始化锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">productor</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//生产一个结点</span></span><br><span class="line">        mp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PC));</span><br><span class="line">        mp-&gt;num = rand() % <span class="number">400</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---productor---%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        <span class="comment">//上菜到链表</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//唤醒消费者</span></span><br><span class="line">        pthread_cond_signal(&amp;has_product);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等待被唤醒</span></span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始消费</span></span><br><span class="line">        mp = head;</span><br><span class="line">        head = mp-&gt;next;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---consumer---%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        mp = <span class="literal">NULL</span>;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//创建生产者线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, productor, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建消费者线程</span></span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231204235852173.png" alt="image-20231204235852173"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//等待被唤醒</span></span><br><span class="line">	pthread_cond_wait(&amp;has_product, &amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为啥要用<code>while</code>，不能用<code>if</code>呢？</p>
<ul>
<li>为了解决多消费者出现的逻辑问题，比如有两个消费者，都阻塞在条件变量上，此时生产者生产了一个货物，<code>pthread_cond_signal(&amp;has_product);</code>会同时唤醒两个条件变量，此时两个消费者共同竞争<code>mutex</code>，其中一个消费者竞争到锁开始消费，另一个消费者会阻塞在<code>mutex</code>上，持有锁的消费者消费完成后释放锁，此时阻塞在<code>mutex</code>上的消费者可能会拿到锁进行消费，但此时公共区可能并没有货物，所以阻塞在<code>mutex</code>上的消费者拿到锁后仍需要判断<code>head != NULL</code>，有货物再消费，没货物继续等待条件变量唤醒。因为，需要用<code>while</code>，不能用<code>if</code>。</li>
</ul>
<h2 id="信号量相关的函数"><a href="#信号量相关的函数" class="headerlink" title="信号量相关的函数"></a>信号量相关的函数</h2><p>信号量相当于进化版的互斥锁，由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p>
<p>信号量用于任务间的同步！简单来理解，信号量是一个被内核维护的整数，这个整数一般是“大于等于零”的，我们对这个信号量的操作一般为：将信号量设置一个值、发布(加上一个信号量)、消耗(减去一个信号量)、等待信号量的值为0。在POSIX下信号量分为命名信号量与未命名信号量。<strong>未命名信号量</strong>，也被称为<strong>基于内存的信号量</strong>，类型为<code>sem_t</code>，创建未命名信号量使用的函数为<code>sem_init()</code>。</p>
<h3 id="函数原型-29"><a href="#函数原型-29" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span><span class="comment">//编译时需要跟上后缀-pthread</span></span></span><br><span class="line"><span class="comment">//初始化一个无名信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">/*函数参数:</span></span><br><span class="line"><span class="comment">	sem: sem_t类型的地址处初始化一个无名信号量(创建信号量的id)</span></span><br><span class="line"><span class="comment">	pshared: 0表示信号量再一个进程的所有线程之间共享;非0(一般取1)表示再进程之间共享.</span></span><br><span class="line"><span class="comment">	value: 指定信号量的值(一般为一个大于等于0的整数)</span></span><br><span class="line"><span class="comment">函数返回值:</span></span><br><span class="line"><span class="comment">	成功: 返回0;</span></span><br><span class="line"><span class="comment">	失败: 返回-1,设置errno以指示错误.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/* 被销毁的信号量是之前使用sem_init()初始化的未命名信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//锁定信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/* 调用此函数成功的话,信号量value将会减1.如果等于0,该函数会阻塞调用进程,直到信号量的值大于0为止;信号量值大于0时该信号量值被减1并且函数返回. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试对信号量加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/* 和sem_wait函数类似,但是调用这个函数失败的话不阻塞而是返回错误error. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//限时尝试锁定信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"><span class="comment">/*函数参数:</span></span><br><span class="line"><span class="comment">	sem: 信号量</span></span><br><span class="line"><span class="comment">	abs_timeout: 采用的是绝对时间.</span></span><br><span class="line"><span class="comment">调用此函数成功的话信号量value将会减一.</span></span><br><span class="line"><span class="comment">如果调用前信号量的值为0,那么本函数将会阻塞一定的时间,一定的时间过后还是不能锁定信号量,那么此函数调用失败并且设置errno为ETIMEDOUT.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给信号量解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/* 调用此函数成功后信号量value将会加一. */</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者信号量模型"><a href="#生产者消费者信号量模型" class="headerlink" title="生产者消费者信号量模型"></a>生产者消费者信号量模型</h3><p>使用信号量完成线程间同步，模拟生产者，消费者问题：</p>
<ul>
<li>如果队列中有数据，生产者不能生产，只能阻塞。</li>
<li>如果队列中没有数据，消费者不能消费，只能等待数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5               </span></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM];                                     <span class="comment">//全局数组实现环形队列</span></span><br><span class="line"><span class="type">sem_t</span> blank_number, product_number;                 <span class="comment">//空格子信号量, 产品信号量</span></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;blank_number);                    <span class="comment">//生产者将空格子数--,为0则阻塞等待</span></span><br><span class="line">        <span class="built_in">queue</span>[i] = rand() % <span class="number">1000</span> + <span class="number">1</span>;               <span class="comment">//生产一个产品</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---Produce---%d\n&quot;</span>, <span class="built_in">queue</span>[i]);        </span><br><span class="line">        sem_post(&amp;product_number);                  <span class="comment">//将产品数++</span></span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;                            <span class="comment">//借助下标实现环形</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;product_number);                  <span class="comment">//消费者将产品数--,为0则阻塞等待</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---Consume---%d\n&quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="built_in">queue</span>[i] = <span class="number">0</span>;                               <span class="comment">//消费一个产品 </span></span><br><span class="line">        sem_post(&amp;blank_number);                    <span class="comment">//消费掉以后,将空格子数++</span></span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line">    sem_init(&amp;blank_number, <span class="number">0</span>, NUM);                <span class="comment">//初始化空格子信号量为5</span></span><br><span class="line">	sem_init(&amp;product_number, <span class="number">0</span>, <span class="number">0</span>);                <span class="comment">//产品数为0</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建生产者和消费者线程</span></span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//等待线程结束</span></span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>fcntl函数功能是针对<strong>文件描述符</strong>提供控制，根据不同的<code>cmd</code>对文件描述符可以执行的操作也非常多，用的最多的是文件记录锁，也就是<code>F_SETLK</code>命令，此命令搭配<code>flock</code>结构体，对文件进行加解锁操作，例如执行加锁操作，如果不解锁，本进程或者其他进程再次使用<code>F_SETLK</code>命令访问同一文件则会告知目前此文件已经上锁，加锁进程退出（正常、异常）后会自行解锁，使用此特性可以实现避免程序多次运行、锁定文件防止其他进行访问等操作。</p>
<p>当使用fcntl函数设置文件锁（<em>record lock</em>）后就<strong>只能有一个进程</strong>打开文件。</p>
<p>复制一个现有的描述符（<code>cmd = F_DUPFD</code>）。<br>获得&#x2F;设置文件描述符标记（<code>cmd = F_GETFD/F_SETFD</code>）。<br>获得&#x2F;设置文件状态标记（<code>cmd = F_GETFL/F_SETFL</code>）。<br>获得&#x2F;设置异步I&#x2F;O所有权（<code>cmd = F_GETOWN/F_SETOWN</code>）。<br>获得&#x2F;设置记录锁（<code>cmd = F_GETLK , F_SETLK/F_SETLKW</code>）。</p>
<h3 id="函数原型-30"><a href="#函数原型-30" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br></pre></td></tr></table></figure>

<p>参数fd是被参数cmd操作的描述符。针对cmd的值，fcntl能够接受第三个参数。</p>
<h3 id="函数参数-21"><a href="#函数参数-21" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>fd</code>：文件描述符。</p>
<p><code>cmd</code>：操作命令。</p>
<table>
<thead>
<tr>
<th align="left">cmd</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>F_DUPFD</code></td>
<td>复制文件描述符，复制的是第一个参数<code>fd</code>。执行成功返回新复制的文件描述符。</td>
</tr>
<tr>
<td align="left"><code>F_GETFD</code></td>
<td>获得<code>fd</code>的<code>close-on-exec</code>标志。若标志未设置，则文件经过exec函数之后仍保持打开状态。</td>
</tr>
<tr>
<td align="left"><code>F_SETFD</code></td>
<td>设置<code>close-on-exec</code>标志，该标志以参数<code>arg</code>的<code>FD_CLOEXEC</code>位决定。</td>
</tr>
<tr>
<td align="left"><code>F_GETFL</code></td>
<td>取得文件描述词状态标志，此标志为<code>open()</code>的参数<code>flags</code>。</td>
</tr>
<tr>
<td align="left"><code>F_SETFL</code></td>
<td>设置文件描述词状态标志，参数<code>arg</code>为新标志，但只允许<code>O_APPEND</code>、<code>O_NONBLOCK</code>和<code>O_ASYBC</code>位的改变，其他位的改变将不受影响。</td>
</tr>
<tr>
<td align="left"><code>F_GETLK</code></td>
<td>根据<code>lock</code>描述，取得文件锁定的状态。</td>
</tr>
<tr>
<td align="left"><code>F_SETLK</code></td>
<td>设置<code>lock</code>描述的文件锁状态。此时<code>flock</code>结构的<code>l_type</code>值必须是<code>F_RDLCK</code>、<code>F_WRLCK</code>或<code>F_UNLCK</code>。执行成功返回0；否则无法建立锁定，返回-1，错误码为<code>EACCES</code>或<code>EAGAIN</code>。</td>
</tr>
<tr>
<td align="left"><code>F_SETLKW</code></td>
<td><code>F_SETLK</code>的阻塞版本（命令名中的W表示等待wait）。若存在其他锁，则调用进程睡眠；若捕捉到信号则睡眠中断；若在阻塞的过程中被信号中断，会立即返回-1，错误码为<code>EINTR</code>。</td>
</tr>
<tr>
<td align="left"><code>F_GETOWN</code></td>
<td>检索将收到<code>SIGIO</code>和<code>SIGURG</code>信号的进程号或进程组号。</td>
</tr>
<tr>
<td align="left"><code>F_SETOWN</code></td>
<td>设置进程号或进程组号。</td>
</tr>
</tbody></table>
<p><code>Lock</code>：为结构体<code>flock</code>，设置记录锁的具体状态。</p>
<p><code>lock</code>的结构体<code>flock</code>的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flcok</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> l_type;   <span class="comment">//锁定的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下的三个参数用于分段对文件加锁,若对整个文件加锁,则:l_whence = SEEK_SET,l_start = 0,l_len = 0 */</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> l_whence; <span class="comment">//决定l_start位置</span></span><br><span class="line">    <span class="type">off_t</span> l_start;      <span class="comment">//锁定区域的开头位置 </span></span><br><span class="line">    <span class="type">off_t</span> l_len;        <span class="comment">//锁定区域的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> l_pid;        <span class="comment">//锁定动作的进程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">久朝暮</div><div class="post-copyright__author_desc">紫气东来</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/blogs/2d14aaf0.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/blogs/2d14aaf0.html')">Linux常用函数</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/blogs/2d14aaf0.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Linux常用函数&amp;url=http://example.com/blogs/2d14aaf0.html&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">久朝暮</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Linux常用函数<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blogs/b9528813.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux系统命令</div></div></a></div><div class="next-post pull-right"><a href="/blogs/6fbd99c.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统高级教程思考题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">Linux常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#close%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">close函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.1.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">open函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">第一个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">第二个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">第三个参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">实例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B3"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">实例3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">write函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">1.3.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">read函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-3"><span class="toc-number">1.4.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number">1.4.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#perror%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">perror函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-4"><span class="toc-number">1.5.2.</span> <span class="toc-text">函数参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lseek%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">lseek函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-5"><span class="toc-number">1.6.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-5"><span class="toc-number">1.6.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-4"><span class="toc-number">1.6.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">1.6.4.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-1"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-1"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">实例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getenv-%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">getenv()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">fork函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-5"><span class="toc-number">1.8.1.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">1.8.2.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">getpid函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getppid%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">getppid函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E6%97%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">exec族函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execl%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.1.</span> <span class="toc-text">execl函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execlp%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.2.</span> <span class="toc-text">execlp函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.12.</span> <span class="toc-text">孤儿进程与僵尸进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.12.1.</span> <span class="toc-text">僵尸进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">僵尸进程的危害</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.12.2.</span> <span class="toc-text">孤儿进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.13.</span> <span class="toc-text">SIGCHLD信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.</span> <span class="toc-text">wait函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-6"><span class="toc-number">1.14.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-6"><span class="toc-number">1.14.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-6"><span class="toc-number">1.14.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%AE%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.4.</span> <span class="toc-text">退出信息相关宏函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-4"><span class="toc-number">1.14.5.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.15.</span> <span class="toc-text">waitpid函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-7"><span class="toc-number">1.15.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-7"><span class="toc-number">1.15.2.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pid%E5%8F%82%E6%95%B0"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">pid参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#status%E5%8F%82%E6%95%B0"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">status参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#options%E5%8F%82%E6%95%B0"><span class="toc-number">1.15.2.3.</span> <span class="toc-text">options参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-7"><span class="toc-number">1.15.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-5"><span class="toc-number">1.15.4.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-2"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-2"><span class="toc-number">1.15.4.2.</span> <span class="toc-text">实例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipe%E5%87%BD%E6%95%B0-%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.16.</span> <span class="toc-text">pipe函数(无名管道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.16.1.</span> <span class="toc-text">管道的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%89%B9%E8%B4%A8"><span class="toc-number">1.16.2.</span> <span class="toc-text">管道特质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.16.3.</span> <span class="toc-text">管道的局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-8"><span class="toc-number">1.16.4.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-8"><span class="toc-number">1.16.5.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-8"><span class="toc-number">1.16.6.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-6"><span class="toc-number">1.16.7.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%90%91%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%BC%A0%E8%BE%BE%E6%B6%88%E6%81%AF"><span class="toc-number">1.16.7.1.</span> <span class="toc-text">子进程向父进程传达消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ulimit-%E2%80%93a-%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%A4%A7%E5%B0%8F%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">1.16.7.1.1.</span> <span class="toc-text">使用ulimit –a 命令可以查看管道缓冲大小命令：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mkfifo%E5%87%BD%E6%95%B0-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.17.</span> <span class="toc-text">mkfifo函数(有名管道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-9"><span class="toc-number">1.17.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-9"><span class="toc-number">1.17.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-9"><span class="toc-number">1.17.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-7"><span class="toc-number">1.17.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.</span> <span class="toc-text">mmap函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-10"><span class="toc-number">1.18.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-10"><span class="toc-number">1.18.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-10"><span class="toc-number">1.18.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.4.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-8"><span class="toc-number">1.18.5.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-3"><span class="toc-number">1.18.5.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-3"><span class="toc-number">1.18.5.2.</span> <span class="toc-text">实例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B3-1"><span class="toc-number">1.18.5.3.</span> <span class="toc-text">实例3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kill%E5%87%BD%E6%95%B0"><span class="toc-number">1.19.</span> <span class="toc-text">kill函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-11"><span class="toc-number">1.19.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-11"><span class="toc-number">1.19.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-11"><span class="toc-number">1.19.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-9"><span class="toc-number">1.19.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raise%E5%87%BD%E6%95%B0"><span class="toc-number">1.20.</span> <span class="toc-text">raise函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-12"><span class="toc-number">1.20.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-12"><span class="toc-number">1.20.2.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-10"><span class="toc-number">1.20.3.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alarm%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.</span> <span class="toc-text">alarm函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-13"><span class="toc-number">1.21.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-12"><span class="toc-number">1.21.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-13"><span class="toc-number">1.21.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-11"><span class="toc-number">1.21.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setitimer%E5%87%BD%E6%95%B0"><span class="toc-number">1.22.</span> <span class="toc-text">setitimer函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-14"><span class="toc-number">1.22.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-13"><span class="toc-number">1.22.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-14"><span class="toc-number">1.22.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Ealarm-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.22.4.</span> <span class="toc-text">与alarm()的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.23.</span> <span class="toc-text">信号集相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.24.</span> <span class="toc-text">信号处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#signal%E5%87%BD%E6%95%B0"><span class="toc-number">1.24.1.</span> <span class="toc-text">signal函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-15"><span class="toc-number">1.24.1.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-14"><span class="toc-number">1.24.1.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-15"><span class="toc-number">1.24.1.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sigaction%E5%87%BD%E6%95%B0"><span class="toc-number">1.24.2.</span> <span class="toc-text">sigaction函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-16"><span class="toc-number">1.24.2.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-15"><span class="toc-number">1.24.2.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-16"><span class="toc-number">1.24.2.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-12"><span class="toc-number">1.24.2.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setsid%E5%87%BD%E6%95%B0"><span class="toc-number">1.25.</span> <span class="toc-text">setsid函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-17"><span class="toc-number">1.25.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.25.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.26.</span> <span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.26.1.</span> <span class="toc-text">守护进程概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.26.2.</span> <span class="toc-text">创建守护进程的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.26.3.</span> <span class="toc-text">创建一个守护进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="toc-number">1.27.</span> <span class="toc-text">线程相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.27.1.</span> <span class="toc-text">流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-create%E5%87%BD%E6%95%B0"><span class="toc-number">1.28.</span> <span class="toc-text">pthread_create函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-18"><span class="toc-number">1.28.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-16"><span class="toc-number">1.28.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-17"><span class="toc-number">1.28.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-13"><span class="toc-number">1.28.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-exit%E5%87%BD%E6%95%B0"><span class="toc-number">1.29.</span> <span class="toc-text">pthread_exit函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-19"><span class="toc-number">1.29.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-17"><span class="toc-number">1.29.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.29.3.</span> <span class="toc-text">无返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-14"><span class="toc-number">1.29.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-join%E5%87%BD%E6%95%B0"><span class="toc-number">1.30.</span> <span class="toc-text">pthread_join函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-20"><span class="toc-number">1.30.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-18"><span class="toc-number">1.30.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-18"><span class="toc-number">1.30.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-15"><span class="toc-number">1.30.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-cancel%E5%87%BD%E6%95%B0"><span class="toc-number">1.31.</span> <span class="toc-text">pthread_cancel函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-21"><span class="toc-number">1.31.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.31.2.</span> <span class="toc-text">取消状态以及类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E7%82%B9"><span class="toc-number">1.31.3.</span> <span class="toc-text">取消点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-16"><span class="toc-number">1.31.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-detach%E5%87%BD%E6%95%B0"><span class="toc-number">1.32.</span> <span class="toc-text">pthread_detach函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-22"><span class="toc-number">1.32.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-17"><span class="toc-number">1.32.2.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.33.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%94%81pthread-mutex-init"><span class="toc-number">1.34.</span> <span class="toc-text">初始化锁pthread_mutex_init</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-23"><span class="toc-number">1.34.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-19"><span class="toc-number">1.34.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-19"><span class="toc-number">1.34.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E9%94%81pthread-mutex-lock%E5%92%8C%E8%A7%A3%E9%94%81pthread-mutex-unlock"><span class="toc-number">1.35.</span> <span class="toc-text">加锁pthread_mutex_lock和解锁pthread_mutex_unlock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-24"><span class="toc-number">1.35.1.</span> <span class="toc-text">函数原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E9%94%81pthread-mutex-destroy"><span class="toc-number">1.36.</span> <span class="toc-text">销毁锁pthread_mutex_destroy()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-25"><span class="toc-number">1.36.1.</span> <span class="toc-text">函数原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.37.</span> <span class="toc-text">读写锁及相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">1.37.1.</span> <span class="toc-text">读写锁创建和销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-26"><span class="toc-number">1.37.1.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-20"><span class="toc-number">1.37.1.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-20"><span class="toc-number">1.37.1.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81"><span class="toc-number">1.37.2.</span> <span class="toc-text">读写锁加锁解锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-27"><span class="toc-number">1.37.2.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-21"><span class="toc-number">1.37.2.2.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-18"><span class="toc-number">1.37.3.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.38.</span> <span class="toc-text">条件变量相关的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-28"><span class="toc-number">1.38.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-19"><span class="toc-number">1.38.2.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.39.</span> <span class="toc-text">信号量相关的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-29"><span class="toc-number">1.39.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.39.2.</span> <span class="toc-text">生产者消费者信号量模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">1.40.</span> <span class="toc-text">fcntl函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-30"><span class="toc-number">1.40.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-21"><span class="toc-number">1.40.2.</span> <span class="toc-text">函数参数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/6fbd99c.html" title="操作系统高级教程思考题">操作系统高级教程思考题</a><time datetime="2023-12-14T14:46:27.000Z" title="发表于 2023-12-14 22:46:27">2023-12-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2d14aaf0.html" title="Linux常用函数">Linux常用函数</a><time datetime="2023-11-30T05:58:58.000Z" title="发表于 2023-11-30 13:58:58">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/b9528813.html" title="Linux系统命令">Linux系统命令</a><time datetime="2023-11-29T00:27:51.000Z" title="发表于 2023-11-29 08:27:51">2023-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/66f88466.html" title="Cpp内存管理">Cpp内存管理</a><time datetime="2023-11-25T06:52:29.000Z" title="发表于 2023-11-25 14:52:29">2023-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/81b624c3.html" title="Cpp面向对象高级编程">Cpp面向对象高级编程</a><time datetime="2023-11-25T06:30:53.000Z" title="发表于 2023-11-25 14:30:53">2023-11-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="久朝暮" target="_blank">久朝暮</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 文章总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-images"></use></svg><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fan"></use></svg><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/my-equipment/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-equipment"></use></svg><span> 我的装备</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-STL/" style="font-size: 0.88rem;">C++ STL<sup>1</sup></a><a href="/tags/C-2-0/" style="font-size: 0.88rem;">C++2.0<sup>1</sup></a><a href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">C++内存管理<sup>1</sup></a><a href="/tags/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">C++设计模式<sup>1</sup></a><a href="/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">C++面向对象高级编程<sup>1</sup></a><a href="/tags/Effective-C/" style="font-size: 0.88rem;">Effective C++<sup>1</sup></a><a href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" style="font-size: 0.88rem;">Linux常用函数<sup>1</sup></a><a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/" style="font-size: 0.88rem;">Linux系统命令<sup>1</sup></a><a href="/tags/UCAS%E8%AF%BE%E7%A8%8B/" style="font-size: 0.88rem;">UCAS课程<sup>1</sup></a><a href="/tags/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%BF%9E%E7%BD%91%E6%8A%80%E6%9C%AF/" style="font-size: 0.88rem;">移动互连网技术<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 久朝暮 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>