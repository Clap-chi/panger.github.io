<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux常用函数 | zy</title><meta name="author" content="zy"><meta name="copyright" content="zy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux常用函数close函数关闭一个文件描述符， 使它不在指向任何文件。在新的文件操作中该文件描述符可以被再次使用。 使用close函数时传入需要关闭文件的文件描述符（即调用open函数的返回值）即可。若关闭文件成功则返回0；若关闭文件失败则返回-1。 函数原型1int close(int fd);  函数参数fd：需要关闭的文件或套接字的文件描述符。 函数返回值若关闭文件成功则返回0；若关闭">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux常用函数">
<meta property="og:url" content="http://example.com/blogs/2d14aaf0.html">
<meta property="og:site_name" content="zy">
<meta property="og:description" content="Linux常用函数close函数关闭一个文件描述符， 使它不在指向任何文件。在新的文件操作中该文件描述符可以被再次使用。 使用close函数时传入需要关闭文件的文件描述符（即调用open函数的返回值）即可。若关闭文件成功则返回0；若关闭文件失败则返回-1。 函数原型1int close(int fd);  函数参数fd：需要关闭的文件或套接字的文件描述符。 函数返回值若关闭文件成功则返回0；若关闭">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-11-30T05:58:58.000Z">
<meta property="article:modified_time" content="2023-12-08T07:35:13.151Z">
<meta property="article:author" content="zy">
<meta property="article:tag" content="Linux常用函数">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/blogs/2d14aaf0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux常用函数',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-08 15:35:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="zy" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="zy"><span class="site-name">zy</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux常用函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-11-30T05:58:58.000Z" title="Created 2023-11-30 13:58:58">2023-11-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-12-08T07:35:13.151Z" title="Updated 2023-12-08 15:35:13">2023-12-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux常用函数"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux常用函数"><a href="#Linux常用函数" class="headerlink" title="Linux常用函数"></a>Linux常用函数</h1><h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>关闭一个文件描述符， 使它不在指向任何文件。在新的文件操作中该文件描述符可以被再次使用。</p>
<p>使用close函数时传入需要关闭文件的<strong>文件描述符</strong>（即调用open函数的返回值）即可。若关闭文件成功则返回0；若关闭文件失败则返回-1。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>fd</code>：需要关闭的文件或套接字的文件描述符。</p>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>若关闭文件成功则返回0；若关闭文件失败则返回-1。</p>
<h2 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h2><p>用来打开或者创建一个文件或者设备。</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span> </span><br></pre></td></tr></table></figure>

<h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="第一个参数"><a href="#第一个参数" class="headerlink" title="第一个参数"></a>第一个参数</h4><p><code>pathname</code>：指定需要打开的文件的路径。</p>
<ul>
<li>若pathname以<strong>路径</strong>的方式给出，则需要创建该文件时，在pathname路径下进行创建。</li>
<li>若pathname以<strong>文件名</strong>的方式给出，则需要创建该文件时，默认在当前路径下进行创建。</li>
</ul>
<h4 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h4><p><code>flags</code>：表示打开文件的方式。</p>
<p>flags是通过<code>O_RDONLY</code>, <code>O_WRONLY</code>或<code>O_RDWR</code>（指明文件是以只读 , 只写或读写方式打开的）与下面的零个或多个可选模式<strong>按位或</strong>操作符得到的:</p>
<ul>
<li><code>O_CREATE</code>：如果文件不存在就创建一个新文件。</li>
<li><code>O_EXCL</code>：通过O_CREATE，生成文件，若文件已经存在，则open出错 , 调用失败。这个O_EXCL与O_CREATE一起使用。</li>
<li><code>O_TRUNC</code>：如果文件已经存在，并且该文件是可写的，那么将会设置该文件的长度为0（清空文件的内容）。</li>
<li><code>O_APPEND</code>：文件以追加模式打开，在写之前，文件读写指针被置末尾。</li>
</ul>
<h4 id="第三个参数"><a href="#第三个参数" class="headerlink" title="第三个参数"></a>第三个参数</h4><p><code>mode</code>：指明文件使用的权限。</p>
<p>传入0666参数进行文件创建，按理应得到-rw-rw-rw-权限的文件，但却得到了下面权限的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r--</span><br></pre></td></tr></table></figure>

<p>这是因为权限掩码的存在（默认为0002），可以在代码中设置权限掩码来避免上述情况发生：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    umask(<span class="number">0000</span>);<span class="comment">//设置文件掩码                                                                     </span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./log.txt&quot;</span>,O_RDWR | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置成功后的文件权限如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-rw-</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 当不需创建文件时，可以不用设置第三个参数。</p>
<h3 id="函数返回值-1"><a href="#函数返回值-1" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>返回一个新的文件描述符（若是有错误发生返回-1，并在errno设置错误信息）。</p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p>创建test.c文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="comment">//在指定路径下创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;./helloworld1.txt&quot;</span>,O_CREAT | O_RDWR | O_TRUNC,<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fd1);</span><br><span class="line">    <span class="comment">//在指定路径下创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd2 = creat(<span class="string">&quot;./helloworld2.txt&quot;</span>,<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fd2);</span><br><span class="line">    <span class="comment">//在指定路径下创建一个新文件</span></span><br><span class="line">    <span class="type">int</span> fd3 = open(<span class="string">&quot;./helloworld3.txt&quot;</span>,O_CREAT | O_RDWR | O_TRUNC);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fd3);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    close(fd3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc test.c -o test</span><br><span class="line">root@vm:/home/wzy/code# ./test</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130142432496.png" alt="image-20231130142432496"></p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130142340377.png" alt="image-20231130142340377"></p>
<p>这里我们也可以看出文件描述符的取值最小从3开始，因为0，1，2是分配给标准I&#x2F;O的描述符。</p>
<h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><p>创建文件名test2.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./log&quot;</span>,O_CREAT | O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc test.c -o test</span><br><span class="line">root@vm:/home/wzy/code# ./test</span><br></pre></td></tr></table></figure>

<p>运行成功后查看log文件的内容发现Hello和fd的值写进log文件中。fd的值为1；<strong>并且永远取未用描述符的最小值</strong>。</p>
<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130142819174.png" alt="image-20231130142819174" style="zoom: 67%;" />

<h4 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h4><p>创建my_touch.c文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单实现touch命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;touch: 缺少了文件操作数\nTry &#x27;touch --help&#x27; for more information.\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd = open(args[i], O_RDONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc my_touch -o touch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#这样我们就可以使用touch创建文件，类似于Linux中的touch命令</span></span></span><br><span class="line">root@vm:/home/wzy/code# touch 1.c 2.c 3.c</span><br></pre></td></tr></table></figure>

<h2 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h2><p>Linux系统接口中使用write函数向文件写入信息。</p>
<p> write向文件描述符fd所引用的文件中写入从buf开始的缓冲区中count个字节的数据。POSIX规定，当使用了write()之后再使用read()，那么读取到的应该是更新后的数据。</p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-2"><a href="#函数参数-2" class="headerlink" title="函数参数"></a>函数参数</h3><ol>
<li><code>fd</code>：显示数据传输对象的文件描述符。</li>
<li><code>buf</code>：保存要传输数据的缓冲地址值。</li>
<li><code>count</code>：要传输数据的字节数。</li>
</ol>
<h3 id="函数返回值-2"><a href="#函数返回值-2" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>成功时返回所写入的字节数（若为零则表示没有写入数据）。失败时返回-1，并置errno为相应值。若count为零，对于普通文件无任何影响，但对特殊文件将产生不可预料的后果。返回0表示没有数据写入。</p>
<h2 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h2><p>read()从文件描述符fd中读取count字节的数据并放入从buf开始的缓冲区中。如果count为零，read()返回0，不执行其他任何操作。如果 count大于SSIZE_MAX，那么结果将不可预料。</p>
<h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-3"><a href="#函数参数-3" class="headerlink" title="函数参数"></a>函数参数</h3><ol>
<li><code>fd</code>：显示数据接收对象的文件描述符。</li>
<li><code>buf</code>：要保存接收数据的缓冲地址值。</li>
<li><code>count</code>：要接收数据的最大字节数。</li>
</ol>
<h3 id="函数返回值-3"><a href="#函数返回值-3" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>成功时返回读取的字计数；失败时返回-1，并设置errno的值；读到文件末尾的话就返回0。</p>
<h3 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h3><p>模拟cat命令实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, args[<span class="number">2</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,args[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        fd = open(args[i], O_RDONLY);</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">        ret = read(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">            write(<span class="number">1</span>, buff, ret);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc cat.c -o cat</span><br><span class="line">root@vm:/home/wzy/code# cat helloworld.txt</span><br><span class="line">This is helloworld.txt.root@vm:/home/wzy/code#</span><br></pre></td></tr></table></figure>

<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130144235599.png" alt="image-20231130144235599" style="zoom: 80%;" />

<p>运行编译生成的可执行程序可以打开存在的小文件。</p>
<h2 id="perror函数"><a href="#perror函数" class="headerlink" title="perror函数"></a>perror函数</h2><p>perror函数是一个错误信息输出函数，用于在发生系统调用错误时输出有关错误信息的描述。其主要作用是将errno对应的错误信息输出到标准错误输出中（<em>stderr</em>）。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li>当一个系统调用或库函数发生错误时，通常会将<strong>全局变量errno</strong>设置为一个特定的错误码。perror函数读取errno的值，并根据这个值生成相应的错误描述。然后，将错误描述与传入的字符串参数拼接，并输出到标准错误流。</li>
</ul>
<h3 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//使用此函数需引入此头文件</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-4"><a href="#函数参数-4" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>str</code>：一个指向常量字符的指针，用于提供上下文信息。<strong>在输出错误消息时，这个字符串将作为错误消息的前缀</strong>（也就是说，可以手动的去描述这个错误是怎么发生的）。</p>
<h2 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h2><p>lseek()函数将与文件描述符fd相关联的打开文件的偏移量重新定位到参数offset上，如下所示：</p>
<ol>
<li>SEEK_SET：The offset is set to offset bytes. offset为0时表示文件开始位置。</li>
<li>SEEK_CUR：The offset is set to its current location plus offset bytes. offset为0时表示当前位置。</li>
<li>SEEK_END：The offset is set to the size of the file plus offset bytes. offset为0时表示结尾位置。</li>
</ol>
<p>当前文件偏移量：</p>
<ul>
<li><strong>每当打开一个文件，都会有一个叫做“当前文件偏移量”的东西，如果难理解也可以将他理解为指针。</strong> 除非打开文件时指定O_APPEND选项，否则<strong>文件偏移量默认设置为0</strong>。当我们发生了一次读或者写操作时，都会使这个当前文件偏移量发生变化，读&#x2F;写多少字节，当前偏移量就会向后移动多少。</li>
</ul>
<h3 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-5"><a href="#函数参数-5" class="headerlink" title="函数参数"></a>函数参数</h3><ol>
<li>fd：文件描述符</li>
<li>offset：文件的偏移量</li>
<li>whence：位置</li>
</ol>
<h3 id="函数返回值-4"><a href="#函数返回值-4" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功返回当前位置到开始的长度。</li>
<li>失败返回-1并设置errno。</li>
</ul>
<h3 id="使用实例-2"><a href="#使用实例-2" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1-1"><a href="#实例1-1" class="headerlink" title="实例1"></a>实例1</h4><p>移动文件读写位置。</p>
<p>用write()函数写入文件之后，这时候读写位置就指在写完后的那个位置，也就是字符串的后面，这样我们在使用read()函数去读的时候就相当于从写入字符串的后面去读的，所以啥也没读到。这时候，就可以使用lseek()函数来移动读写位置。<strong>新建一个文件并向其中写入数据，然后读取该文件的内容将其写入到屏幕上：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;not fount file name&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//新建一个文件并写入helloLinux,然后读取该文件的内容,将内容输出到屏幕上.</span></span><br><span class="line">    <span class="type">int</span> fd = open(args[<span class="number">1</span>], O_CREAT | O_RDWR);</span><br><span class="line">    write(fd, <span class="string">&quot;helloLinux&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//此时文件指针位置已经到末尾,需要重新将指针移到文件首部.</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">15</span>];</span><br><span class="line">    <span class="type">int</span> ret = read(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(STDOUT_FILENO, buff, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@vm:/home/wzy/code# gcc lseek.c -o lseek</span><br><span class="line">root@vm:/home/wzy/code# ./lseek lseek.txt</span><br></pre></td></tr></table></figure>

<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130160151063.png" alt="image-20231130160151063" style="zoom: 80%;" />

<h4 id="实例2-1"><a href="#实例2-1" class="headerlink" title="实例2"></a>实例2</h4><p>计算文件大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./lseek2.txt&quot;</span>, O_RDONLY | O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成功后第一次运行新建一个原本不存在的文件，所以字节数为0：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130161416525.png" alt="image-20231130161416525"></p>
<p>然后向lseek2.txt写点数据：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130161710271.png" alt="image-20231130161710271"></p>
<p>第二次运行后：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130161618160.png" alt="image-20231130161618160"></p>
<h2 id="getenv-函数"><a href="#getenv-函数" class="headerlink" title="getenv()函数"></a>getenv()函数</h2><p>获取指定的环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br></pre></td></tr></table></figure>

<p>读取环境变量HOME的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,getenv(<span class="string">&quot;HOME&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130162653378.png" alt="image-20231130162653378" style="zoom:80%;" />

<h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p><strong>fork函数：</strong>：创建子进程。</p>
<p>fork函数是一个系统调用，其作用是创建一个新的进程。在调用fork函数时，操作系统会复制当前进程的所有信息，并将其分配给新的进程。新进程与原进程几乎完全相同，但有一些区别：在新进程中，fork返回值为0；在原进程中，fork返回值为新进程的PID（Process ID）。因此，在程序中可以根据返回值来判断当前代码运行在哪个进程中。</p>
<p><strong>父进程与子进程运行在不同的内存空间，子进程拥有独一无二的task_struct(PCB)，但是内存空间的内容是一样的，除了一些特殊的，比如说进程id不一样。</strong></p>
<p>子进程与父进程的区别：</p>
<p>由于子进程与父进程非常相似，但又有些微小的差别。下面我们列举一些常见的区别：</p>
<p>（1）PID不同：子进程和父进程有不同的PID，可以通过getpid()和getppid()函数获取。</p>
<p>（2）PPID不同：子进程和父进程有不同的PPID（即父亲PID），可以通过getppid()函数获取。</p>
<p>（3）资源占用情况不同：子进程会拷贝父亲所有资源情况（包括打开文件、信号处理等），但是有些资源是共享的，例如内存映射、消息队列等。</p>
<h3 id="函数返回值-5"><a href="#函数返回值-5" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>失败返回-1；<br>fork方法被调用一次，成功就会有两次返回：</p>
<ol>
<li>在父进程中返回一次，返回的是子进程的id（非0）。</li>
<li>在子进程中返回一次，返回值为0。</li>
</ol>
<h3 id="使用实例-3"><a href="#使用实例-3" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin:\n&quot;</span>);</span><br><span class="line">    <span class="comment">//返回值为子进程的id</span></span><br><span class="line">    <span class="type">pid_t</span> child_id = fork();</span><br><span class="line">    <span class="comment">//创建子进程失败</span></span><br><span class="line">    <span class="keyword">if</span> (child_id &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;create child process failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child id:%d parent id:%d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child id:%d self id:%d parent id:%d\n&quot;</span>,child_id, getpid(), getppid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130170512751.png" alt="image-20231130170512751"></p>
<p>子进程中的parent id有些时候运行结果为1，为什么是1呢？</p>
<p>这个涉及到孤儿进程的知识，原因是父进程已经死了，孤儿进程就被init进程领养了，由init进程负责孤儿进程资源的回收。当然了你还可以通过以下命令查看<code>ps aux</code>孤儿进程被哪个进程领养了；或者通过<code>ps ajx</code>查看父子进程之间的信息。</p>
<h2 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a>getpid函数</h2><p>获取当前进程的id。</p>
<h2 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a>getppid函数</h2><p>获取当前进程的父进程的id。</p>
<h2 id="exec族函数"><a href="#exec族函数" class="headerlink" title="exec族函数"></a>exec族函数</h2><p>这些exec族函数的共同特点：</p>
<ol>
<li>只有当错误发生才有返回值，返回值为-1；</li>
<li>这些函数都是可变参数的函数，所以参数列表必须以空指针结束；</li>
</ol>
<h3 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//path为环境变量，arg为待执行文件的参数从argv[0]开始</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                       <span class="comment">/* (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file为需要执行的程序名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                       <span class="comment">/* (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h2><p>一个进程被创建出来是为了完成用户要求的任务，而进程完成任务的结果如何是由其父进程查看的，因此在进程退出时，不会立即释放该进程对应的资源，而是保存一段时间，让父进程或者操作系统来读取检查，读取后父进程或者操作系统才会回收该进程的所有资源。<strong>回收后该进程就是死亡状态（X—dead）</strong>了，而<strong>进程退出到还没被回收的期间的状态就是僵尸状态，也称僵尸状态(Z—zombie）</strong>。</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ol>
<li>僵死状态（Zombies）是一个比较特殊的状态。当进程退出并且父进程（使用wait()系统调用）没有读取到子进程退出的返回代码时就会产生僵死（尸）进程。</li>
<li>僵尸进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。</li>
<li>所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入Z状态。</li>
</ol>
<p>僵尸进程实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_id = fork();</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child, child id:%d parent id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process died!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am parent, parent id:%d\n&quot;</span>,getpid());</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130174140064.png" alt="image-20231130174140064" style="zoom:80%;" />

<h4 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h4><ul>
<li>维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在<code>task_struct</code>(即PCB)中，换句话说，<code>Z</code><strong>状态一直不退出</strong>，<code>PCB</code><strong>一直都要维护</strong>。</li>
<li>僵尸进程是要求回收的，不回收会占用内存，造成内存泄露。</li>
</ul>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>所谓孤儿进程，故名思义，和现实生活中的孤儿有点类似，当一个进程的父进程结束时，但是它自己还没有结束，那么这个进程将会成为孤儿进程。</p>
<p>当子进程的父进程挂掉之后，子进程会被<code>1</code>号进程领养。该进程也被称为孤儿进程。</p>
<p>那么为什么要进行领养呢：</p>
<ul>
<li>原因是孤儿进程会被init进程（1号进程）领养，当然在子进程结束时也会由init进程完成对它的状态收集工作，因此一般来说，孤儿进程并不会有什么危害。</li>
</ul>
<p>孤儿进程实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_id = fork();</span><br><span class="line">    <span class="comment">//孤儿进程</span></span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程id:%d 父进程id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程id:%d 父进程的父进程id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I will died\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><p>子进程暂停或退出时会主动向父进程发送SIGCHLD（17号）信号。而父进程对17号信号的默认处理动作是忽略。</p>
<ul>
<li>为了避免出现僵尸进程，父进程需要使用wait或waitpid函数等待子进程结束，父进程可以阻塞等待子进程结束，也可以非阻塞地查询的是否有子进程结束等待清理，即轮询的方式。采用第一种方式，父进程阻塞就不能处理自己的工作了；采用第二种方式，父进程在处理自己的工作的同时还要记得时不时地轮询一下，程序实现复杂。</li>
<li>子进程在终止时会给父进程发生SIGCHLD信号，该信号的默认处理动作是忽略。父进程可以自定义SIGCHLD信号的处理动作，这样父进程就只需专心处理自己的工作，不必关心子进程了。子进程终止时会通知父进程，父进程在信号处理函数中调用wait或waitpid函数清理子进程即可。</li>
</ul>
<h2 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h2><p>等待子进程状态的改变。</p>
<p>它是一个<strong>用于等待子进程结束的函数</strong>。该函数将暂停当前进程的执行，直到一个子进程结束或收到一个信号为止。当一个子进程结束时，wait函数会返回该子进程的PID（进程ID），并在status参数中返回子进程的退出状态信息。</p>
<p>调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）。</p>
<p>如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1。</p>
<h3 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引入的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-6"><a href="#函数参数-6" class="headerlink" title="函数参数"></a>函数参数</h3><p>进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</p>
<h3 id="函数返回值-6"><a href="#函数返回值-6" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回被回收的子进程的id。</li>
<li>失败：-1（所有的子进程都结束，调用函数失败）。</li>
</ul>
<h3 id="退出信息相关宏函数"><a href="#退出信息相关宏函数" class="headerlink" title="退出信息相关宏函数"></a>退出信息相关宏函数</h3><ul>
<li><code>WIFEXITED(status)</code>：非0，进程正常退出。</li>
<li><code>WEXITSTATUS(status)</code>：如果<code>WIFEXITED(status)</code>为真，获取进程退出的状态（exit的参数）。</li>
<li><code>WIFSIGNALED(status)</code>：非0，进程异常终止。</li>
<li><code>WTERMSIG(status)</code>：如果<code>WIFSIGNALED(status)</code>为真，获取使进程终止的信号编号。</li>
<li><code>WIFSTOPPED(status)</code>：非0，进程处于暂停状态。</li>
<li><code>WSTOPSIG(status)</code>：如果<code>WIFSTOPPED(status)</code>为真，获取使进程暂停的信号的编号。</li>
<li><code>WIFCONTINUED(status)</code>非0，进程暂停后已经继续运行。</li>
</ul>
<h3 id="使用实例-4"><a href="#使用实例-4" class="headerlink" title="使用实例"></a>使用实例</h3><p>通过这个函数我们可以避免僵尸进程的出现，等待子进程状态的改变，让系统回收子进程的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process, child id:%d parent id:%d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process, child id:%d\n&quot;</span>, id);</span><br><span class="line">        <span class="comment">//status保留已死子进程的信息</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> child_id = wait(&amp;status);</span><br><span class="line">        <span class="comment">//如果子进程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process are exited with %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果子进程被信号杀死</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process are killed by %d\n&quot;</span>,WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child_id:%d\n&quot;</span>,child_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130212243327.png" alt="image-20231130212243327"></p>
<h2 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h2><p>waitpid()函数是一个用于等待子进程终止的系统调用。与wait()函数不同，waitpid()函数可以指定等待的进程ID，并且提供了更多的选项。</p>
<p>waitpid函数就是wait函数的增强版。</p>
<p>waitpid函数的使用方式waitpid(-1, NULL, 0)等价wait函数的使用wait(NULL)，两者这样使用使一样的。</p>
<h3 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引入的头文件，与wait函数相同</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，pid参数指定了要等待的子进程的进程ID，status参数是用于获取子进程的终止状态的指针，options参数指定了waitpid()函数的行为。</p>
<h3 id="函数参数-7"><a href="#函数参数-7" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="pid参数"><a href="#pid参数" class="headerlink" title="pid参数"></a>pid参数</h4><ul>
<li><code>pid &gt; 0</code>：等待进程ID为pid的子进程结束。</li>
<li><code>pid == 0</code>：等待与当前进程在同一个进程组中的所有子进程结束。</li>
<li><code>pid == -1</code>：等待任何一个子进程结束，与wait()函数相同。</li>
<li><code>pid &lt; -1</code>：等待进程组ID为pid的所有子进程结束。</li>
</ul>
<h4 id="status参数"><a href="#status参数" class="headerlink" title="status参数"></a>status参数</h4><p>是一个指向整型变量的指针，用于获取子进程的退出状态，这一点与wait函数相同。当waitpid()函数返回时，如果status不为NULL，则子进程的退出状态会被存储在status指向的变量中。如果status为空，则子进程的退出状态会被忽略。</p>
<h4 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h4><p>是一个控制waitpid()函数行为的标志位，它可以取以下值：</p>
<ul>
<li><code>WNOHANG</code>：如果没有子进程结束，则立即返回0，不阻塞。</li>
<li><code>WUNTRACED</code>：如果子进程进入暂停状态，也立即返回。</li>
<li><code>WCONTINUED</code>：如果子进程恢复执行，则立即返回。</li>
<li><code>WSTOPPED</code>：等待任何一个子进程进入暂停状态。</li>
<li><code>WEXITED</code>：等待任何一个子进程结束。</li>
<li><code>WNOWAIT</code>：不删除已经结束子进程的进程表项，用于后续处理。</li>
</ul>
<h3 id="函数返回值-7"><a href="#函数返回值-7" class="headerlink" title="函数返回值"></a>函数返回值</h3><ol>
<li>返回结束子进程的进程ID。</li>
<li>如果<code>WNOHANG</code>标志被设置并且没有子进程结束，则返回0。</li>
<li>如果调用进程没有子进程，则返回-1，并设置errno为ECHILD。</li>
<li>如果调用被一个信号中断，则返回-1，并设置errno为EINTR。</li>
</ol>
<h3 id="使用实例-5"><a href="#使用实例-5" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1-2"><a href="#实例1-2" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;child process:child id:%d parent id:%d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process:parent id:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="keyword">while</span> ((ret = waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG)) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="comment">//此时子进程已经死去被回收那么再次调用waitpid时返回值就一定是-1了</span></span><br><span class="line">        ret = waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="comment">//不让父进程死去</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130221629949.png" alt="image-20231130221629949"></p>
<h4 id="实例2-2"><a href="#实例2-2" class="headerlink" title="实例2"></a>实例2</h4><p>使用waitpid回收多个子进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> id;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//创建多个子进程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        id = fork();</span><br><span class="line">        <span class="comment">//子进程退出for循环,让其不具备再生能力</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am child process:child id:%d parent id:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ret_id = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">            <span class="keyword">if</span> (ret_id == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret_id &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ret_id:%d\n&quot;</span>, ret_id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不让父进程死去</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">        sleep(i);<span class="comment">//为了让创建的子进程顺序死亡</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130223225282.png" alt="image-20231130223225282"></p>
<h2 id="pipe函数-无名管道"><a href="#pipe函数-无名管道" class="headerlink" title="pipe函数(无名管道)"></a>pipe函数(无名管道)</h2><h3 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h3><p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。</p>
<p><strong>什么是有血缘关系的进程：</strong> 就是父子进程、兄弟进程等。</p>
<p><strong>管道的原理：</strong>管道实为内核使用<code>环形队列</code>机制，借助内核缓冲区（4k）实现。</p>
<p><strong>512B是磁盘的最小单位，即半k。</strong></p>
<h3 id="管道特质"><a href="#管道特质" class="headerlink" title="管道特质"></a>管道特质</h3><p>  1. 其本质是一个伪文件（实为内核缓冲区）。<br>  2. 由两个文件描述符引用，一个表示读端，一个表示写端。<br>  3. 规定数据从管道的写端流入管道，从读端流出。</p>
<h3 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h3><ol>
<li>数据自己读不能自己写。</li>
<li>数据一旦被读走，便不在管道中存在，不可反复读取。</li>
<li>由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</li>
<li>只能在有公共祖先的进程间使用管道。</li>
</ol>
<p>在Linux中，pipe() 是一个底层系统调用，用于<code>创建管道</code>（pipe）。管道是用于进程间通信的一种简单机制，通过pipe()函数可以创建一个匿名的、单向的管道，可以在不同的进程之间传递数据。</p>
<h3 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//使用函数需导入此头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-8"><a href="#函数参数-8" class="headerlink" title="函数参数"></a>函数参数</h3><p>pipefd是一个两个元素的整型数组，它是一个传出参数，用于<code>存放</code>管道的读写<code>文件描述符</code>。</p>
<ul>
<li>其中<code>pipefd[0]为管道读端</code>，<code>pipefd[1]为管道写端</code>。这两个文件描述符可以像其他文件描述符一样进行读写操作。</li>
<li>管道默认是阻塞的：如果管道中没有数据，read阻塞；如果管道满了，write阻塞。</li>
<li><code>注意</code>：（匿名）管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）。</li>
</ul>
<h3 id="函数返回值-8"><a href="#函数返回值-8" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回0。</li>
<li>失败：返回-1，会设置errno，通过perror函数来打印错误信息。</li>
</ul>
<p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。</p>
<ol>
<li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。<br>  2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道写端，子进程关闭管道读端。子进程可以向管道中写入数据，父进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li>
</ol>
<h3 id="使用实例-6"><a href="#使用实例-6" class="headerlink" title="使用实例"></a>使用实例</h3><p>使用pipe()函数创建一个管道，并在子进程和父进程之间传递数据：</p>
<h4 id="子进程向父进程传达消息"><a href="#子进程向父进程传达消息" class="headerlink" title="子进程向父进程传达消息"></a>子进程向父进程传达消息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> retpipe = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span> (retpipe == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);<span class="comment">//关闭父进程写端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ssize_t</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));<span class="comment">//读取子进程写入的信息</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//确保字符串以null结尾</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程,我的进程号是:%d,正在接收来自子进程的信息...\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);<span class="comment">//关闭子进程读端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;我是子进程,我的进程号是:&quot;</span>, getpid());</span><br><span class="line">        <span class="type">ssize_t</span> len = write(pipefd[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));<span class="comment">//子进程写入信息</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130231415551.png" alt="image-20231130231415551"></p>
<h5 id="使用ulimit-–a-命令可以查看管道缓冲大小命令："><a href="#使用ulimit-–a-命令可以查看管道缓冲大小命令：" class="headerlink" title="使用ulimit –a 命令可以查看管道缓冲大小命令："></a>使用ulimit –a 命令可以查看管道缓冲大小命令：</h5><ul>
<li><code>ulimit</code>是一个用于控制shell进程资源限制的命令，在 Linux 系统中经常用于限制某个用户或进程的资源使用。<code>-a</code>是ulimit命令的一个选项，表示显示所有当前限制值的详细信息。当在终端中输入<code>ulimit -a</code>命令后，将会列出所有的资源限制信息：</li>
</ul>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231130232006176.png" alt="image-20231130232006176"></p>
<p><code>pipe size (512 bytes, -p) 8</code>这一行表示<strong>管道（pipe）的大小限制</strong>。管道是一种进程间通信（IPC）机制，允许一个进程的输出成为另一个进程的输入。这里的数字“8”表示的是<strong>管道缓冲区大小限制的倍数</strong>。由于括号内提到了每单位的大小为<code>512</code>字节，所以这里的管道大小限制为<code>8 * 512 = 4096</code>字节。</p>
<p>这意味着在使用管道进行进程间通信时，缓冲区最多可以容纳4096字节的数据。当管道的缓冲区被填满时，写入管道的进程将被阻塞，直到另一个进程从管道中读取数据为止。</p>
<h2 id="mkfifo函数-有名管道"><a href="#mkfifo函数-有名管道" class="headerlink" title="mkfifo函数(有名管道)"></a>mkfifo函数(有名管道)</h2><p>有名管道用于非亲缘关系进程之间的通讯。创建有名管道使用到的库函数是：mkfifo()，这里强调是库函数的原因是，mkfifo同时也是一个用户指令。</p>
<ol>
<li>mkfifo函数：创建一个FIFO有名管道文件。</li>
<li>FIFO：称为有名管道，实现无血缘关系管道通信。</li>
<li>创建管道伪文件命令：<code>mkfifo 文件名。</code></li>
<li>示例：先使用<code>mkfifo 文件名</code>创建一个FIFO有名管道文件，然后多个进程读写。</li>
</ol>
<h3 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-9"><a href="#函数参数-9" class="headerlink" title="函数参数"></a>函数参数</h3><p>mkfifo()生成一个名字叫“pathname”的先入先出的特殊文件。mode指定这个文件的权限，一般情况下，它通过进程的掩码被修改：这个创建的文件的权限是（mode &amp; ~umask）。</p>
<h3 id="函数返回值-9"><a href="#函数返回值-9" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回0。</li>
<li>失败：返回-1，表示创建过程中遇到某种错误，此时会设置errno，用户可以检测errno来取得进一步信息。</li>
</ul>
<h3 id="使用实例-7"><a href="#使用实例-7" class="headerlink" title="使用实例"></a>使用实例</h3><p>编写程序FIFOpipe.c，在该程序内，创建有名管道“FIFO”，然后利用open()打开，open()函数返回一个文件描述符fd，使用read()函数从这个文件描述符fd中读取数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    ret = mkfifo(<span class="string">&quot;FIFO&quot;</span>, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waitting for the data from FIFOpipe:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;FIFO&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFOpipe is %s:\n&quot;</span>, buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201002931890.png" alt="image-20231201002931890"></p>
<p> 打印提示信息后，阻塞式读取有名管道中的数据。</p>
<p>在FIFO管道中写入信息“HelloLinux”后运行：</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201003151223.png" alt="image-20231201003151223"></p>
<h2 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h2><p><code>mmap</code>是一种内存映射文件的方法，即将<strong>一个文件或者其它对象映射到进程的地址空间</strong>，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read，write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><code>munmap</code>执行相反的操作，删除特定地址区域的对象映射。</p>
<p>采用<strong>共享内存通信</strong>的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：<strong>一次从输入文件到共享内存区</strong>，<strong>另一次从共享内存区到输出文件</strong>。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<h3 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数主要用途有三个：</p>
<ul>
<li>将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I&#x2F;O读写，以获得较高的性能。</li>
<li>将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间。</li>
<li>为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。</li>
</ul>
<h3 id="函数参数-10"><a href="#函数参数-10" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>start</code>：指向欲映射的内存起始地址，通常设为NULL，代表让系统自动选定地址，映射成功后返回该地址。</p>
<p><code>length</code>：代表将文件中多大的部分映射到内存。</p>
<p><code>prot</code>：映射区域的保护方式。不能与文件的打开模式冲突。是以下的某个值，可以通过<code>or</code>运算合理地组合在一起：</p>
<ul>
<li><code>PROT_READ</code>：页可以被读取。</li>
<li><code>PROT_WRITE</code>：页可以被写入。</li>
<li><code>PROT_NONE</code>：页不可访问。</li>
<li><code>PROT_EXEC</code>：页可以被执行。</li>
</ul>
<p><code>flags</code>：影响映射区域的各种特性，指定映射对象的类型，映射选项和映射页是否可以共享。在调用mmap()时必须要指定<code>MAP_SHARED</code>或<code>MAP_PRIVATE</code>。</p>
<ul>
<li><code>MAP_SHARED</code>：与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到<code>msync()</code>或者<code>munmap()</code>被调用，文件实际上不会被更新。</li>
<li><code>MAP_PRIVATE</code>：对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。这个标志和以上标志是互斥的，只能使用其中一个。</li>
<li><code>MAP_ANONYMOUS</code>：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</li>
<li><code>MAP_DENYWRITE</code>：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</li>
<li><code>MAP_LOCKED</code>：将映射区域锁定住，这表示该区域不会被置换（swap）。</li>
</ul>
<p><code>fd</code>：要映射到内存中的文件描述符。如果使用匿名内存映射时，即MAP_ANONYMOUS被设定，为了兼容问题，其值为-1。</p>
<p><code>offset</code>：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</p>
<h3 id="函数返回值-10"><a href="#函数返回值-10" class="headerlink" title="函数返回值"></a>函数返回值</h3><ol>
<li>成功时返回映射区的首地址。</li>
<li>失败返回MAP_FAILED。</li>
</ol>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>成功执行时，munmap()返回0。</li>
<li>失败时，munmap返回-1，error返回标志和mmap一致；</li>
</ul>
<p>该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap()后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p>
<h3 id="使用实例-8"><a href="#使用实例-8" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1-3"><a href="#实例1-3" class="headerlink" title="实例1"></a>实例1</h4><p>将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I&#x2F;O读写，以获得较高的性能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;mmap.txt&quot;</span>, O_RDWR | O_CREAT);</span><br><span class="line">    <span class="comment">//将文件映射到内存</span></span><br><span class="line">    <span class="type">char</span>* mapArea = mmap(<span class="literal">NULL</span>, <span class="number">8</span>, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mapArea == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span> (mapArea, <span class="string">&quot;HelloLinux&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mapArea);</span><br><span class="line">    <span class="type">int</span> ret = munmap(mapArea, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;munmap error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201135241538.png" alt="image-20231201135241538"></p>
<h4 id="实例2-3"><a href="#实例2-3" class="headerlink" title="实例2"></a>实例2</h4><p>mmap函数创建对已知的文件的映射区，实现父子进程间的通信：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个对已知的文件的映射</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;mmap.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span>* mapArea = mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_WRITE | PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mapArea == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *mapArea = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child mapArea:%d\n&quot;</span>, *mapArea);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child mapArea:%d\n&quot;</span>, *mapArea);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *mapArea = <span class="number">88</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent mapArea:%d\n&quot;</span>, *mapArea);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent mapArea:%d\n&quot;</span>, *mapArea);</span><br><span class="line">        *mapArea = <span class="number">1001</span>;</span><br><span class="line">        <span class="comment">//回收子进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201135056270.png" alt="image-20231201135056270"></p>
<h4 id="实例3-1"><a href="#实例3-1" class="headerlink" title="实例3"></a>实例3</h4><p>mmap函数实现无血缘关系的进程之间的通信：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//写进程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;_student;</span><br><span class="line"><span class="comment">//mmap实现不同进程之间的通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:%s fileName\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(_student);</span><br><span class="line">    <span class="comment">//将文件的大小截断为指定大小,不管之前文件的大小比len大还是小</span></span><br><span class="line">    ftruncate(fd, len);</span><br><span class="line">    _student *stu = mmap(<span class="literal">NULL</span>, len, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (stu == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stu-&gt;id = num;</span><br><span class="line">        <span class="built_in">sprintf</span>(stu-&gt;name, <span class="string">&quot;zyzy-%04d\n&quot;</span>, num ++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(stu, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//读进程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;_student;</span><br><span class="line"><span class="comment">//mmap实现不同进程之间的通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:%s fileName\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(_student);</span><br><span class="line">    _student *stu = mmap(<span class="literal">NULL</span>, len, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (stu == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name:%s id:%d\n&quot;</span>, stu-&gt;name, stu-&gt;id);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(stu, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h2><p>kill() 系统调用允许一个进程向另一个进程发送信号。这对于进程间通信、进程控制以及进程管理等任务非常有用。</p>
<h3 id="函数原型-11"><a href="#函数原型-11" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用kill函数需导入这些头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-11"><a href="#函数参数-11" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>pid_t pid</code>：目标进程或进程组的 ID。<code>pid_t</code>是一个表示进程ID的数据类型。<code>pid</code>参数可以是以下几种值：</p>
<ul>
<li><code>pid &gt; 0</code>：信号发送给具有该 PID 的单个进程。</li>
<li><code>pid = 0</code>：信号发送给与调用进程属于同一进程组内的所有进程。也就是调用kill函数的这个进程组的进程都会接受到这个信号。</li>
<li><code>pid = -1</code>：发送信号给除了调用进程和 init 进程（PID 为 1）以外的所有进程。通常情况下，这需要调用进程拥有特定权限，例如root用户权限。</li>
<li><code>pid &lt; -1</code>：信号发送给进程组ID等于pid绝对值的所有进程。简单理解就是，如果pid是-N（N &gt; 1），则信号将发送给进程组ID为N的所有进程。</li>
</ul>
<p><code>int sig</code>：要发送的信号。Linux 支持多种信号，sig参数可以是整数信号代码，也可以是预定义的信号常量。以下是一些常用的信号及其说明：</p>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">名称</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIGHUP</td>
<td align="left">挂起信号，启动被终止的程序，也可以让进程重新读取自己的配置文件，类似重新启动。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SIGINT</td>
<td align="left">中断信号，用户通过键盘发送的中断，相当于输入<code>Ctrl + c</code>来中断一个程序。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">SIGKILL</td>
<td align="left">杀死信号，强制结束进程，进程无法捕获或忽略此信号，不会进行资源的清理工作。如果该程序进行到一半，可能会有半成品产生，类似vim的.filename.swp保留下来。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">SIGTERM</td>
<td align="left">终止信号，以正常（优雅）的方式来终止进程，由程序自身决定该如何终止。进程可以捕获并执行清理工作。</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">SIGSTOP</td>
<td align="left">相当于输入<code>Ctrl + z</code>来暂停一个程序。</td>
</tr>
</tbody></table>
<h3 id="函数返回值-11"><a href="#函数返回值-11" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功，<code>kill</code>返回0。</li>
<li>失败，返回-1，并设置<code>errno</code>来表示错误。</li>
</ul>
<h3 id="使用实例-9"><a href="#使用实例-9" class="headerlink" title="使用实例"></a>使用实例</h3><p>发送<code>SIGINT</code>信号结束子进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是子进程.\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程.\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kill child process now\n&quot;</span>);</span><br><span class="line">        kill(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201153452068.png" alt="image-20231201153452068"></p>
<h2 id="raise函数"><a href="#raise函数" class="headerlink" title="raise函数"></a>raise函数</h2><p>当前进程发送指定信号（自己给自己发信号），<code>raise(sig)</code>相当于<code>kill(getpid(), sig)</code>。</p>
<h3 id="函数原型-12"><a href="#函数原型-12" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span></span><br></pre></td></tr></table></figure>

<h3 id="函数返回值-12"><a href="#函数返回值-12" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>成功的时候，返回0 ，否则返回非零的值，并置errno。</p>
<p>如果sig的值是无效的，raise函数就将errno置为EINVAL。</p>
<h3 id="使用实例-10"><a href="#使用实例-10" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HelloLinux!\n&quot;</span>);</span><br><span class="line">    <span class="comment">//raise函数给自己发送信号</span></span><br><span class="line">    raise(SIGKILL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不输出，main线程已死</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HelloLinux!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h2><p>alarm()是一个Linux系统调用，用于设置一个实时闹钟，当指定的时间（以秒为单位）到达时，系统会发送一个<code>SIGALRM</code>信号给进程。</p>
<ul>
<li>这个信号通常用于限制某个程序或者操作的执行时间。当闹钟时间到达时，若没有设置信号处理程序，进程将被终止。</li>
<li>如果设置了信号处理程序，那么在信号处理程序执行完毕后，进程会继续执行。</li>
</ul>
<p>alarm()函数只能设置一个闹钟。如果在一个闹钟到期之前再次调用alarm()，则之前的闹钟将被新的闹钟替代。</p>
<h3 id="函数原型-13"><a href="#函数原型-13" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//使用此函数，需导入此头文件</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-12"><a href="#函数参数-12" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>seconds</code>：闹钟的延迟时间，以秒为单位。如果参数为0，则取消之前设置的闹钟（闹钟无效，不进行倒计时，不发信号）。</p>
<h3 id="函数返回值-13"><a href="#函数返回值-13" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>如果之前没有设置闹钟，返回0。</li>
<li>如果之前设置了闹钟，返回距离上一个闹钟剩余的时间（秒数）。</li>
</ul>
<h3 id="使用实例-11"><a href="#使用实例-11" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am happy\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = alarm(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ret); <span class="comment">//0</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    ret = alarm(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ret);<span class="comment">//6</span></span><br><span class="line">    <span class="comment">//四秒后终止程序</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhhh\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231201164627586.png" alt="image-20231201164627586"></p>
<h2 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h2><p>setitimer()是一个Linux系统调用，用于设置一个间隔性定时器。与alarm()函数相比，setitimer()提供了更高级的功能，支持设置多个定时器以及定时器的更精确控制。当定时器到期时，系统会发送一个信号给进程，通常用于限制程序或操作的执行时间、定期执行任务等。</p>
<p>当时钟到期，一个作用于调用进程的信号产生，具体产生什么信号，由which参数决定。</p>
<h3 id="函数原型-14"><a href="#函数原型-14" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> <span class="comment">// 使用此函数需导入此头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-13"><a href="#函数参数-13" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>which</code>：指定设置哪种类型的定时器。有以下三种类型：</p>
<ul>
<li><code>ITIMER_REAL</code>：以实时时间递减，当时钟到期后，发送<code>SIGALRM</code>信号。</li>
<li><code>ITIMER_VIRTUAL</code>：只有在进程执行时才递减，时钟到期后，发送<code>SIGVTALRM</code>信号。</li>
<li><code>ITIMER_PROF</code>：在进程执行和系统执行内核代码时递减，时钟到期后，发送<code>SIGPROF</code>信号。</li>
</ul>
<p><code>itimerval</code>结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">//间隔时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">//初始时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>new_value</code>：指向一个<code>itimerval</code>结构体，用于设置定时器的初始值和间隔。</li>
<li><code>old_value</code>：指向一个<code>itimerval</code>结构体，如果不为<code>NULL</code>，用于保存先前设置的定时器值。</li>
</ul>
<p><code>timeval</code>结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> tv_sec;  <span class="comment">//秒数</span></span><br><span class="line">	<span class="type">long</span> tv_usec; <span class="comment">//微秒数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="函数返回值-14"><a href="#函数返回值-14" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功时返回0；</li>
<li>出错时返回-1，并设置相应的errno。</li>
</ul>
<h3 id="与alarm-的区别"><a href="#与alarm-的区别" class="headerlink" title="与alarm()的区别"></a>与alarm()的区别</h3><ul>
<li><code>setitimer()</code>支持多个定时器（<code>ITIMER_REAL</code>、<code>ITIMER_VIRTUAL</code>和<code>ITIMER_PROF</code>），而<code>alarm()</code>只支持一个定时器。</li>
<li><code>setitimer()</code>可以设置定时器的间隔时间，使定时器在到期后自动重置，而<code>alarm()</code>只能在指定的时间后触发一次。</li>
<li><code>setitimer()</code>支持微秒级的时间精度，而<code>alarm()</code>只支持秒级的精度。</li>
</ul>
<h2 id="信号集相关函数"><a href="#信号集相关函数" class="headerlink" title="信号集相关函数"></a>信号集相关函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下信号集相关的函数都是对自定义的信号集进行操作:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*功能: 清空信号集中的数据, 将信号集中的所有的标志位置为0.</span></span><br><span class="line"><span class="comment">  参数: </span></span><br><span class="line"><span class="comment">  	set: 传出参数, 需要操作的信号集.指向sigset_t类型的指针，sigset_t是一个信号集类型，表示一个信号集.</span></span><br><span class="line"><span class="comment">  返回: 成功时返回0; 失败时返回-1, 并设置errno表示错误原因.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*功能: 将信号集中的所有的标志位置为1.</span></span><br><span class="line"><span class="comment">  参数: </span></span><br><span class="line"><span class="comment">  	set: 同上.</span></span><br><span class="line"><span class="comment">  返回: 同上.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*功能: 该函数允许您将一个指定的信号添加到一个自定义信号集中，也就是将该信号的标准位设为1，表示阻塞这个信号.</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">  	set: 同上.</span></span><br><span class="line"><span class="comment">  	signum: 需要设置阻塞的那个信号(需要添加到信号集中的信号编号).</span></span><br><span class="line"><span class="comment">  返回: 同上.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*功能: 从一个自定义信号集中删除一个指定的信号，也就是将该信号的标准位设为0，不阻塞这个信号.</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">  	set: 同上.</span></span><br><span class="line"><span class="comment">  	signum: 需要设置不阻塞的那个信号(需要从信号集中删除的信号编号).</span></span><br><span class="line"><span class="comment">  返回: 同上.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*功能: 检查一个指定的信号是否在给定的信号集中,也就是检查该信号是否被阻塞.</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">  	set: 同上.</span></span><br><span class="line"><span class="comment">  	signum: 要检查的信号编号.</span></span><br><span class="line"><span class="comment">  返回:</span></span><br><span class="line"><span class="comment">  	1: 指定的信号在信号集中,signum被阻塞.</span></span><br><span class="line"><span class="comment">  	0: 指定的信号不在信号集中,signum不阻塞</span></span><br><span class="line"><span class="comment">  	-1: 调用失败,并设置errno表示错误原因.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*功能：获取当前进程中的未决信号集.</span></span><br><span class="line"><span class="comment">  参数：</span></span><br><span class="line"><span class="comment">  	set: 传出参数，保存的是当前进程中的未决信号集中的信息.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">/*功能: 将自定义信号集中的数据设置到内核中(设置阻塞, 解除阻塞, 替换).</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">  	how: 如何对内核阻塞信号集进行处理, 假设当前的信号屏蔽字为mask.</span></span><br><span class="line"><span class="comment">  		SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中, 内核中原来的数据不变.则mask = mask|set.</span></span><br><span class="line"><span class="comment">		SIG_UNBLOCK: 根据用户设置的数据, 对内核中的数据进行解除阻塞.则mask = mask&amp;(~set).</span></span><br><span class="line"><span class="comment">		SIG_SETMASK: 覆盖内核中原来的值(替代原始屏蔽及的新屏蔽集).则mask = set.若调用sigprocmask解除了对当前若干个信号的					     阻塞，则在sigprocmask返回前，至少将其中一个信号递达.</span></span><br><span class="line"><span class="comment">	set: 已经初始化好的用户自定义的信号集.</span></span><br><span class="line"><span class="comment">	oldset: 保存设置之前的内核中的阻塞信号集的状态, 可以是NULL.</span></span><br><span class="line"><span class="comment">  返回值:</span></span><br><span class="line"><span class="comment">	成功: 0</span></span><br><span class="line"><span class="comment">	失败: -1 </span></span><br><span class="line"><span class="comment">		设置错误号:EFAULT / EINVAL.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><p>改变对信号的默认处理（设置某一信号的对应动作）。</p>
<h4 id="函数原型-15"><a href="#函数原型-15" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>针对信号处理函数指针简化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//将sighandler_t定义为返回值为void，接受一个int形参的函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>

<p>此函数必须在signal()被调用前申明，handler中为这个函数的名字。当接收到一个类型为sig的信号时，就执行handler所指定的函数。（int）signum是传递给它的唯一参数。执行了signal()调用后，进程只要接收到类型为sig的信号，不管其正在执行程序的哪一部分，就立即执行func()函数。当func()函数执行结束后，控制权返回进程被中断的那一点继续执行。 </p>
<h4 id="函数参数-14"><a href="#函数参数-14" class="headerlink" title="函数参数"></a>函数参数</h4><p><code>signum</code>：指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。 　 </p>
<p><code>handler</code>：描述了与信号关联的动作，它可以取以下三种值： </p>
<ul>
<li><code>SIG_IGN</code>：忽略该信号。</li>
<li><code>SIG_DFL</code>：表示恢复对信号的系统默认处理。不写此处理函数默认也是执行系统默认操作。 </li>
<li>指定的函数地址，则在信号发生时会调用该函数。</li>
</ul>
<h4 id="函数返回值-15"><a href="#函数返回值-15" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>返回先前的信号处理函数指针，指向sig信号的处理程序，如果有错误则返回SIG_ERR（-1）。</p>
<h3 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h3><p>（信号捕捉）用于处理和控制信号，相比signal()函数，sigaction()提供了更强大且具有可移植性的信号处理能力。sigaction()可以让你定义捕获信号时的行为，包括设置信号处理函数和信号处理选项。</p>
<h4 id="函数原型-16"><a href="#函数原型-16" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> <span class="comment">// 使用此函数，需导入此系统调用</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>sigaction结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="comment">//只能对sa_handler或者sa_sigaction其中一个赋值.</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);        <span class="comment">//信号处理函数，常用.</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">//带有信号信息的信号处理函数，不常用.</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;               <span class="comment">//在信号处理函数执行期间阻塞的信号集.</span></span><br><span class="line">    <span class="type">int</span> sa_flags;                   <span class="comment">//控制信号处理行为的标志位，决定你到底是使用sa_handler还是sa_sigaction处理函数,</span></span><br><span class="line">    								<span class="comment">//这个值可以是0, 表示使用sa_handler, 也可以是SA_SIGINFO表示使用sa_sigaction.</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);      <span class="comment">//已过时，不建议使用.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sa_mask</code>是一个临时的阻塞信号集，它的作用仅仅是在执行某个信号的时候，才会去阻塞信号集中的信号，在除了执行某个信号的其他时间里，不会阻塞任何信号。</p>
<h4 id="函数参数-15"><a href="#函数参数-15" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li><code>int signum</code>：指定要处理的信号。</li>
<li><code>const struct sigaction *act</code>：一个指向sigaction结构体的指针，该结构体包含信号处理函数和信号处理选项（捕捉到信号之后的处理动作）。如果为NULL，则不会改变信号的处理行为。</li>
<li><code>struct sigaction *oldact</code>：一个指向sigaction结构体的指针，用于存储信号原有的处理行为（上一次对信号捕捉相关的设置）。如果为NULL，则不会返回信号原有的处理行为。</li>
</ul>
<h4 id="函数返回值-16"><a href="#函数返回值-16" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul>
<li>成功时，返回0；</li>
<li>失败时，返回-1，并设置errno以表示错误原因。</li>
</ul>
<h4 id="使用实例-12"><a href="#使用实例-12" class="headerlink" title="使用实例"></a>使用实例</h4><p>使用sigaction()捕获SIGINT信号（当用户按下Ctrl+C时产生）并执行自定义处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕获到信号%d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">ss</span>;</span></span><br><span class="line">    ss.sa_handler = sigint_handler;</span><br><span class="line">    sigemptyset(&amp;ss.sa_mask);<span class="comment">//清空临时阻塞信号集</span></span><br><span class="line">    ss.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;ss, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等待信号...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，设置了一个自定义的信号处理函数sigint_handler，用于在接收到SIGINT信号时执行。使用sigemptyset()初始化sa_mask，以防止在信号处理函数执行期间阻塞任何其他信号。sa_flags设置为0，表示使用默认的信号处理行为。最后，调用sigaction()设置信号处理函数。</p>
<img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203003129680.png" alt="image-20231203003129680" style="zoom:67%;" />

<h2 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a>setsid函数</h2><p>setsid函数用于创建一个新的会话，并使得当前进程成为新会话组的组长。setsid函数能够使进程完全独立出来，从而脱离所有其他进程的控制。查看一个进程的会话id可以<code>ps ajx</code>，所在列SID即为会话id。</p>
<p>进程属于一个进程组，进程组号(GID)就是进程组长的进程号(PID)。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端，登录会话和进程组通常是从父进程继承下来的。</p>
<p><strong>进程组和会话的概念：</strong> 如果一个父进程通过fork函数产生了好多个子进程，那么这些父进程和子进程在同一个组内，并且进程组id和父进程id是相同的，父进程称为组长。同时子进程和父进程在同一个会话内，父进程也成为会长。</p>
<p>每个进程都属于某个进程组，进程组是由一个或多个相互间有关联的进程组成的，他的目的是为了进行作业控制。进程租的主要特征就是信号可以发给进程组中的所有进程：这个信号可以使同一个进程组中的所有进程终止，停止或者继续运行。</p>
<p>调用该函数成功后，该调用进程成为新的会话组的组长，在会话组中创建新的进程组并担任组长。同时脱离终端的控制，运行在后台。该进程成为新会话组和进程组中唯一的进程。</p>
<h3 id="函数原型-17"><a href="#函数原型-17" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//本函数成功的话返回调用进程的会话id；失败返回-1，设置errno</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>父进程不能调用此函数</strong>。父进程调用setsid函数，函数返回-1，设置ERROR为EPERM。</li>
<li>如果一个会话中会长所在的那个进程中止，那么SIGHUP信号将会发送给控制终端下与会长所在进程在同一个进程组的所有进程。</li>
</ol>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><h3 id="守护进程概念"><a href="#守护进程概念" class="headerlink" title="守护进程概念"></a>守护进程概念</h3><p>守护进程也称精灵进程（Daemon），是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</p>
<p>守护进程是一种很有用的进程，Linux的大多数服务器就是用守护进程实现的，比如Internet服务器inetd，Web服务器httpd等。同时守护进程完成许多系统任务，比如作业规划进程crond等。</p>
<p>Linux系统启动时会启动很多系统服务进程，这些系统服务进程没有控制终端，不能直接和用户交互。其他进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但系统服务进程不受用户登录注销的影响，它们一直在运行着，这种进程有一个名称叫守护进程（Daemon）。</p>
<h3 id="创建守护进程的步骤"><a href="#创建守护进程的步骤" class="headerlink" title="创建守护进程的步骤"></a>创建守护进程的步骤</h3><ol>
<li>创建子进程，并通过<code>fork</code>系统调用复制父进程的文件描述符表和信号处理函数。</li>
<li>在子进程中调用<code>setsid</code>系统调用创建新的会话，并成为会话的首进程。</li>
<li>修改工作目录为根目录，以防止守护进程占用文件系统。（<code>chdir()</code>：修改当前工作路径）</li>
<li>重设文件权限掩码，以便守护进程创建文件时具有合适的权限。（umask(0)；）</li>
<li>关闭不再需要的文件描述符，如标准输入、标准输出和标准错误输出等。</li>
<li>处理信号，如SIGCHLD、SIGHUP等，可以选择忽略或自定义处理函数。</li>
<li>运行守护进程的主要逻辑，如服务监听、数据处理等。</li>
<li>退出守护进程。</li>
</ol>
<h3 id="创建一个守护进程"><a href="#创建一个守护进程" class="headerlink" title="创建一个守护进程"></a>创建一个守护进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creatFile</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> fileName[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(fileName,<span class="number">0</span>,<span class="keyword">sizeof</span>(fileName));</span><br><span class="line">    <span class="built_in">sprintf</span>(fileName, <span class="string">&quot;%s/example/zy.%ld&quot;</span>, getenv(<span class="string">&quot;HOME&quot;</span>),time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> fd = open(fileName, O_CREAT | O_TRUNC | O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个守护进程，实现每隔五秒钟创建一个文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建子进程，父进程死亡</span></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span>(id &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程调用setsid函数,子进程当会长</span></span><br><span class="line">    setsid();</span><br><span class="line">    <span class="comment">//切换家目录</span></span><br><span class="line">    chdir(getenv(<span class="string">&quot;HOME&quot;</span>));</span><br><span class="line">    <span class="comment">//设置掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//业务逻辑</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//新建闹钟</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">myit</span> =</span> &#123;&#123;<span class="number">5</span>,<span class="number">0</span>&#125;, &#123;<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;  <span class="comment">//五秒钟后闹钟响起，之后每隔五秒钟</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;myit, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//注册信号处理函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span>;</span></span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sig.sa_handler = creatFile;</span><br><span class="line">    <span class="comment">//屏蔽信号集</span></span><br><span class="line">    sigemptyset(&amp;sig.sa_mask);</span><br><span class="line">    sigaction(SIGALRM, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果我们的业务不是很复杂，可以通过nohup指令达到与守护进程相同的效果。指令为<code>nohup yourcommand [&gt;xxx.log] &amp;</code>；nohup表示不让你要执行的程序yourcommand收到信号SIGHUP，&amp;表示在后台运行。</p>
<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><p>多线程开发在 Linux 平台上已经有成熟的 pthread 库支持。其涉及的多线程开发的最基本概念主要包含三点：线程，互斥锁，条件。其中，线程操作又分线程的创建，退出，等待 3 种。互斥锁则包括 4 种操作，分别是创建，销毁，加锁和解锁。条件操作有 5 种操作：创建，销毁，触发，广播和等待。其他的一些线程扩展概念，如信号灯等，都可以通过上面的三个基本元素的基本操作封装出来。</p>
<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203202217896.png" alt="image-20231203202217896"></p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203225501899.png" alt="image-20231203225501899"></p>
<h2 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h2><p>创建一个新线程。 其作用，对应进程中fork()函数。</p>
<p>g++&#x2F;gcc编译的时候需要加上参数<code>-pthread</code>，编译pthread动态库。</p>
<p>线程ID：<code>pthread_t</code>类型，可理解为：typedef unsigned long int pthread_t；本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现。</p>
<h3 id="函数原型-18"><a href="#函数原型-18" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回错误编号</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数-16"><a href="#函数参数-16" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>pthread_t *thread</code>：用来保存新的线程的id，由函数<code>pthread_self()</code>获取，类似获取进程pid使用getpid()函数。</p>
<p><code>const pthread_attr_t *attr</code>：用于定制各种不同的线程属性，暂可以把它设置为NULL，以创建默认属性的线程。</p>
<p><code>void *(*start_routine) (void *)</code>：线程中执行函数。新创建的线程从start_rtn函数的地址开始运行，该函数只有一个无类型指针参数arg。该函数运行结束，则线程结束，即创建线程的回调函数。</p>
<p><code>void *arg</code>：执行函数中所使用的参数。如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构体中，然后把这个结构体的地址作为arg参数传入。</p>
<h3 id="函数返回值-17"><a href="#函数返回值-17" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功：返回0；</li>
<li>失败：返回错误号，可通过strerror函数打印错误信息。</li>
</ul>
<p>线程创建成功，新线程就会加入到系统调度队列中，获取到 CPU 之后就会立马从 start_routine()函数开始运行该线程的任务；调用 pthread_create()函数后，通常我们无法确定系统接着会调度哪一个线程来使用 CPU 资源，先调度主线程还是新创建的线程呢（而在多核 CPU 或多 CPU 系统中，多核线程可能会在不同的核心上同时执行）？如果程序对执行顺序有强制要求，那么就必须采用一些同步技术来实现。这与前面学习父、子进程时也出现了这个问题，无法确定父进程、子进程谁先被系统调度。</p>
<p>注意 pthread_create()在调用失败时通常会返回错误码，它并不像其它库函数或系统调用一样设置 errno， 每个线程都提供了全局变量 errno 的副本，这只是为了与使用 errno 到的函数进行兼容，在线程中，从函数中返回错误码更为清晰整洁，不需要依赖那些随着函数执行不断变化的全局变量，这样可以把错误的范围限制在引起出错的函数中。</p>
<h3 id="使用实例-13"><a href="#使用实例-13" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current thread:process id:%d thread id:%lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main process:process id:%d thread id:%lu thread:%lu\n&quot;</span>, getpid(), pthread_self(), thread);</span><br><span class="line">    <span class="comment">//睡一秒让子线程有机会执行完</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203201803667.png" alt="image-20231203201803667"></p>
<p><strong>pthread_self</strong>函数：返回调用线程的id，就像getpid()函数返回调用进程id一样。</p>
<h2 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h2><p>退出当前线程，对其他线程没有影响；如果想要主线程退出而子线程不退出，就用pthread_exit函数。</p>
<p>线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p>
<p>在多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</p>
<p>pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p>
<h3 id="函数原型-19"><a href="#函数原型-19" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-17"><a href="#函数参数-17" class="headerlink" title="函数参数"></a>函数参数</h3><p>参数<code>retval</code>的数据类型为 void *，指定了线程的返回值、也就是线程的退出码，通常传NULL，该返回值可由另一个线程通过调用 pthread_join()来获取。</p>
<p>参数<code>retval</code>所指向的内容不应分配于<strong>线程栈</strong>中，因为线程终止后，将无法确定线程栈的内容是否有效。</p>
<h3 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值"></a>无返回值</h3><h3 id="使用实例-14"><a href="#使用实例-14" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am another thread:tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="comment">//让主线程退出,进程不退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203204936482.png" alt="image-20231203204936482"></p>
<h2 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h2><p>pthread_join()函数来阻塞等待线程的终止， 并获取线程的退出码，回收线程资源。</p>
<p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<ul>
<li>如果<code>thread</code>线程通过<code>return</code>返回，<code>retval</code>所指向的单元里存放的是<code>thread</code>线程函数的返回值。</li>
<li>如果<code>thread</code>线程被别的线程调用<code>pthread_cancel</code>异常终止掉，<code>retval</code>所指向的单元里存放的是常数<code>PTHREAD_CANCELED</code>。</li>
<li>如果<code>thread</code>线程是自己调用<code>pthread_exit</code>终止的，<code>retval</code>所指向的单元存放的是传给<code>pthread_exit</code>的参数。</li>
<li>如果对<code>thread</code>线程的终止状态不感兴趣，可以传<code>NULL</code>给<code>retval</code>参数。</li>
</ul>
<h3 id="函数原型-20"><a href="#函数原型-20" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-18"><a href="#函数参数-18" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>thread</code>：pthread_join()等待指定线程的终止，通过参数thread（线程 ID）指定需要等待的线程。</p>
<p><code>retval</code>：如果参数retval不为NULL，则pthread_join()将目标线程的退出状态（即目标线程通过pthread_exit()退出时指定的返回值或者在线程start函数中执行return语句对应的返回值）复制到retval所指向的内存区域；如果目标线程被pthread_cancel()取消，则将PTHREAD_CANCELED放在<code>*retval</code>中。如果对目标线程的终止状态不感兴趣，则可将参数retval设置为NULL。（回收那个线程的退出值，根据pthread_exit函数里面的参数类型是<code>void*</code>，对其回收就得是<code>void**</code>。）</p>
<h3 id="函数返回值-18"><a href="#函数返回值-18" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功返回0。</li>
<li>失败将返回错误码。</li>
</ul>
<h3 id="使用实例-15"><a href="#使用实例-15" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am subthread\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">4</span>);<span class="comment">//即使让子线程睡4秒,但pthread_join函数阻塞等待着,主线程没有继续往下执行.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//tid就是创建的子线程的id</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">void</span>* ret;</span><br><span class="line">    pthread_join(tid, &amp;ret);</span><br><span class="line">    <span class="comment">//获取线程的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret:%s\n&quot;</span>, (<span class="type">char</span>*)ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am main thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203211755776.png" alt="image-20231203211755776"></p>
<h2 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h2><p>发送取消请求给指定的线程，杀死某个指定的线程。但需要达到一个<strong>取消点</strong>。这个取消点就是进入内核，如果线程中没有进入内核的契机，该函数就杀不死这个线程。可以在程序中手动添加一个取消点<code>pthread_testcancel()</code>；</p>
<p>取消点：取消点是指程序中的某个位置，在该位置线程可以被取消。常见的取消点包括线程阻塞在I&#x2F;O操作、休眠、等待锁等地方。</p>
<p> 有时候，在程序设计需求当中，需要向一个线程发送一个请求，要求它立刻退出，我们把这种操作称为取消线程，也就是向指定的线程发送一个请求，要求其立刻终止、退出。譬如，一组线程正在执行一个运算， 一旦某个线程检测到错误发生，需要其它线程退出，取消线程这项功能就派上用场了。</p>
<p>  发出取消请求之后，函数<code>pthread_cancel()</code>立即返回，不会等待目标线程的退出。默认情况下，目标线程也会立刻退出，其行为表现为如同调用了参数为PTHREAD_CANCELED（退出码为-1）的pthread_exit()函数，但是，线程可以设置自己不被取消或者控制如何被取消，所以 pthread_cancel()并不会等待线程终止，仅仅只是提出请求。</p>
<h3 id="函数原型-21"><a href="#函数原型-21" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="取消状态以及类型"><a href="#取消状态以及类型" class="headerlink" title="取消状态以及类型"></a>取消状态以及类型</h3><p>默认情况下，线程会响应其它线程发送的取消请求的，响应请求然后退出线程。当然，线程可以选择不被取消或者设置取消方式，通过 pthread_setcancelstate()和 pthread_setcanceltype()来设置线程的取消性状态和类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure>

<p>参数<code>state</code>必须是以下值之一：</p>
<ul>
<li><code>PTHREAD_CANCEL_ENABLE</code>：线程可以取消，这是新创建的线程取消性状态的默认值，所以新建线程以及主线程<strong>默认</strong>都是可以取消的。</li>
<li><code>PTHREAD_CANCEL_DISABLE</code>：线程不可被取消，如果此类线程接收到取消请求，则会将请求挂起，直至线程的取消性状态变为 PTHREAD_CANCEL_ENABLE。</li>
</ul>
<p>参数<code>type</code>必须是以下值之一：</p>
<ul>
<li><code>PTHREAD_CANCEL_DEFERRED</code>：取消请求到来时，线程还是继续运行，取消请求被挂起，直到线程到达某个取消点为止，这是所有新建线程包括主线程<strong>默认</strong>的取消性类型。</li>
<li><code>PTHREAD_CANCEL_ASYNCHRONOUS</code>：可能会在任何时间点（也许是立即取消，但不一定） 取消线程，这种取消性类型应用场景很少，不再介绍。</li>
</ul>
<h3 id="取消点"><a href="#取消点" class="headerlink" title="取消点"></a>取消点</h3><p>取消点其实就是一系列函数，当执行到这些函数的时候，才会真正响应取消请求，这些函数就是取消点；在没有出现取消点时，取消请求是无法得到处理的，究其原因在于系统认为，但没有到达取消点时，线程此时正在执行的工作是不能被停止的，正在执行关键代码，此时终止线程将可能会导致出现意想不到的异常发生。</p>
<h3 id="使用实例-16"><a href="#使用实例-16" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running, count: %d\n&quot;</span>, count);</span><br><span class="line">        count ++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查取消请求</span></span><br><span class="line">    pthread_testcancel();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread cancellation requested. Exiting...\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待一段时间</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//取消线程执行</span></span><br><span class="line">    pthread_cancel(thread);</span><br><span class="line">    <span class="comment">//等待线程退出</span></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread cancelling successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203224115465.png" alt="image-20231203224115465"></p>
<p>代码的主要逻辑：</p>
<ol>
<li><p>在<code>main()</code>函数中，我们创建了一个子线程<code>thread</code>，并将其执行函数设置为<code>carryFunc</code>。</p>
</li>
<li><p><code>carryFunc</code>是子线程的执行函数。在该函数中，我们使用一个循环来模拟线程的工作，每秒打印一次计数值<code>count</code>。这个循环会一直执行，直到收到取消请求。</p>
</li>
<li><p>在主线程中，我们使用<code>sleep(3)</code>等待了3秒，然后调用<code>pthread_cancel(thread)</code>来发送取消请求给子线程。</p>
</li>
<li><p>接着，我们使用<code>pthread_join(thread, NULL)</code>等待子线程退出。这样，主线程会阻塞直到子线程执行完毕。</p>
</li>
<li><p>最后，主线程输出<code>&quot;Thread canceled successfully.&quot;</code>表示线程成功被取消。</p>
</li>
</ol>
<p>使用<code>pthread_cancel()</code>函数来取消线程需要小心处理，确保线程在被取消之前完成必要的清理工作，以避免资源泄漏或数据不一致的问题。在这个例子中，子线程中使用<code>pthread_testcancel()</code>来检查取消请求，以确保在取消点处退出线程。</p>
<h2 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h2><p>执行线程分离。将指定的线程标记为 “可分离的“，表示该线程在执行结束后会自动释放资源（由资源自动回收机制完成），无需等待主线程回收。另一方面，这也意味这主线程无法获得线程的返回值。</p>
<ul>
<li><p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p>
</li>
<li><p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
</li>
</ul>
<p>一旦线程处于分离状态，就不能再使用 pthread_join()来获取其终止状态，此过程是不可逆的，一旦处于分离状态之后便不能再恢复到之前的状态。处于分离状态的线程，当其终止后，能够自动回收线程资源。</p>
<h3 id="函数原型-22"><a href="#函数原型-22" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p>一个线程既可以将另一个线程分离，同时也可以将自己分离，譬如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(pthread_self());</span><br></pre></td></tr></table></figure>

<h3 id="使用实例-17"><a href="#使用实例-17" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">carryFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;subthread:tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">    sleep(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;subthread:tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, carryFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//分离线程</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    <span class="comment">//让子线程全部执行完</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//尝试pthread_join</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (ret = pthread_join(tid, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret:%d error string:%s\n&quot;</span>, ret, strerror(ret));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231203231848423.png" alt="image-20231203231848423"></p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>在线程实际运行过程中，我们经常需要多个线程保持同步。这时可以用互斥锁来完成任务。互斥锁的使用过程中，主要有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init;<span class="comment">//初始化锁</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_destory;<span class="comment">//销毁锁</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_lock;<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock;<span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>

<p>互斥锁实现了“互相排斥”（<em>mutual exclusion</em>）同步的简单形式，所以名为互斥锁。互斥锁禁止多个进程同时进入受保护的代码“临界区”（<em>critical section</em>）。因此，在任意时刻，只有一个进程被允许进入这样的代码保护区。</p>
<p>mutex的语义相对于信号量要简单轻便一些，在锁争用激烈的测试场景下，mutex比信号量执行速度更快，可扩展性更好，另外mutex数据结构的定义比信号量小。</p>
<h2 id="初始化锁pthread-mutex-init"><a href="#初始化锁pthread-mutex-init" class="headerlink" title="初始化锁pthread_mutex_init"></a>初始化锁pthread_mutex_init</h2><p><code>pthread_mutex_init</code>是一个函数，在使用线程时，它是创建线程锁的第一个步骤，互斥锁的初始化。线程锁是一种用于多线程编程的同步机制，它是用来保护共享资源，确保在线程要访问共享变量时，只有一个线程进行访问。使用线程锁能够有效地避免竞争条件的发生。</p>
<p><code>pthread_mutex_init()</code>是以<strong>动态方式</strong>创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空（<em>NULL</em>），则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。</p>
<p>POSIX定义了一个宏<code>PTHREAD_MUTEX_INITIALIZER</code>来静态初始化互斥锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>使用<code>pthread_mutex_init</code>函数初始化的线程锁，在使用完毕后一定要记得调用<code>pthread_mutex_destroy</code>函数来销毁线程锁，并且需要确保所有线程都已退出该锁。</p>
<h3 id="函数原型-23"><a href="#函数原型-23" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* attr)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数-19"><a href="#函数参数-19" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>mutex</code>：是一个<code>pthread_mutex_t</code>类型指针，指向需要进行初始化操作的互斥锁对象。</p>
<p><code>attr</code>：是一个<code>pthread_mutexattr_t</code>类型指针，指向一个<code>pthread_mutexattr_t</code>类型对象，该对象<strong>用于定义互斥锁的属性</strong>，若将参数attr设置为NULL，则表示将互斥锁的属性设置为默认值，在这种情况下其实就等价于<code>PTHREAD_MUTEX_INITIALIZER</code>这种方式初始化，而不同之处在于， 使用宏不进行错误检查。</p>
<p>在不设置属性时，第二个参数可以设置为NULL。如果设置了属性，则需要使用<code>pthread_mutexattr_init</code>函数对属性进行初始化，并通过<code>pthread_mutexattr_settype</code>函数设置属性值，再将属性指针作为参数传递给<code>pthread_mutex_init</code>函数。</p>
<p>pthread_mutex_init常用的属性包括：</p>
<ul>
<li><code>PTHREAD_PROCESS_SHARED</code>：互斥锁可以在多个进程间共享。</li>
<li><code>PTHREAD_MUTEX_RECURSIVE</code>：互斥锁是可重入的，同一个线程可以多次获取同一个互斥锁，释放时也要相应多次。</li>
<li><code>PTHREAD_MUTEX_ERRORCHECK</code>：互斥锁是带错误检查的，如果同一个线程多次获取同一个互斥锁，则返回错误码EBUSY。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, &amp;attr);</span><br><span class="line">    <span class="comment">// 使用互斥锁</span></span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数返回值-19"><a href="#函数返回值-19" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>成功返回0。</li>
<li>失败将返回一个非0的错误码。</li>
</ul>
<h2 id="加锁pthread-mutex-lock和解锁pthread-mutex-unlock"><a href="#加锁pthread-mutex-lock和解锁pthread-mutex-unlock" class="headerlink" title="加锁pthread_mutex_lock和解锁pthread_mutex_unlock"></a>加锁pthread_mutex_lock和解锁pthread_mutex_unlock</h2><p>调用函数 <code>pthread_mutex_lock()</code>可以对互斥锁加锁、获取互斥锁，而调用函数 <code>pthread_mutex_unlock()</code>可以对互斥锁解锁、释放互斥锁。两个函数一般需要搭配使用。</p>
<h3 id="函数原型-24"><a href="#函数原型-24" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p><code>pthread_mutex_trylock()</code>语义与<code>pthread_mutex_lock()</code>类似，不同的是在锁已经被占据时返回EBUSY而不是挂起等待。</p>
<ul>
<li>如果线程不希望被阻塞，它可以使用<code>pthread_mutex_trylock()</code>尝试对互斥量进行加锁。如果调用<code>pthread_mutex_trylock()</code>时互斥量处于未锁住状态，那么<code>pthread_mutex_trylock()</code>将锁住互斥量，不会出现阻塞并返回0，否则<code>pthread_mutex_trylock()</code>就会失败，不能锁住互斥量，而返回EBUSY。</li>
</ul>
<p>调用 pthread_mutex_unlock()函数将已经处于锁定状态的互斥锁进行解锁。以下行为均属错误：</p>
<ul>
<li>对处于未锁定状态的互斥锁进行解锁操作；</li>
<li>解锁由其它线程锁定的互斥锁。</li>
</ul>
<h2 id="销毁锁pthread-mutex-destroy"><a href="#销毁锁pthread-mutex-destroy" class="headerlink" title="销毁锁pthread_mutex_destroy()"></a>销毁锁pthread_mutex_destroy()</h2><p>当不再需要互斥锁时，应该将其销毁，通过调用 <code>pthread_mutex_destroy()</code>函数来销毁互斥锁。</p>
<h3 id="函数原型-25"><a href="#函数原型-25" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>在调用成功情况下返回0，失败返回一个非0值的错误码。</p>
<ul>
<li>不能销毁还没有解锁的互斥锁，否则将会出现错误；</li>
<li>没有初始化的互斥锁也不能销毁。</li>
</ul>
<p>被<code>pthread_mutex_destroy()</code>销毁之后的互斥锁，就不能再对它进行上锁和解锁了，需要再次调用<code>pthread_mutex_init()</code>对互斥锁进行初始化之后才能使用。</p>
<h2 id="读写锁及相关函数"><a href="#读写锁及相关函数" class="headerlink" title="读写锁及相关函数"></a>读写锁及相关函数</h2><p>读写锁允许更高的并行性，也叫共享互斥锁。互斥量要么是加锁状态，要么就是解锁状态，而且一次只有一个线程可以对其加锁。</p>
<p>读写锁可以有3种状态：</p>
<ol>
<li>读模式下加锁状态（读锁）。</li>
<li>写模式加锁状态（写锁）。</li>
<li>不加锁状态。</li>
</ol>
<p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁，即允许多个线程读但只允许一个线程写（写独占，读共享）。</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。当读操作较多，写操作较少时，可用读写锁提高线程读并发性。</p>
<p>适合使用读写锁的场景：</p>
<ul>
<li><strong>缓存</strong>：在多个线程中读取同一个缓存时，使用读写锁可以提高程序的并发性，从而提高程序的性能。</li>
<li><strong>数据库</strong>：在数据库中，读操作通常比写操作频繁。使用读写锁可以提高并发性，从而提高程序的性能。</li>
<li><strong>日志</strong>：在日志系统中，写操作的频率通常比读操作高得多。使用读写锁可以防止读线程被写线程长时间阻塞，从而提高程序的性能。</li>
<li><strong>配置文件</strong>：在读取配置文件时，使用读写锁可以提高程序的并发性，从而提高程序的性能。</li>
</ul>
<h3 id="读写锁创建和销毁"><a href="#读写锁创建和销毁" class="headerlink" title="读写锁创建和销毁"></a>读写锁创建和销毁</h3><h4 id="函数原型-26"><a href="#函数原型-26" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//初始化一个读写锁对象,分配使用读写锁需要的资源.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">phtread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">//销毁一个读写锁对象,释放被锁使用的资源.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="函数参数-20"><a href="#函数参数-20" class="headerlink" title="函数参数"></a>函数参数</h4><ul>
<li><code>rwlock</code>：需要初始化的读写锁。</li>
<li><code>attr</code>：读写锁属性，通常使用默认属性，传NULL即可。</li>
</ul>
<h4 id="函数返回值-20"><a href="#函数返回值-20" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul>
<li>成功返回0。</li>
<li>失败返回非0。</li>
</ul>
<h3 id="读写锁加锁解锁"><a href="#读写锁加锁解锁" class="headerlink" title="读写锁加锁解锁"></a>读写锁加锁解锁</h3><h4 id="函数原型-27"><a href="#函数原型-27" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 加读锁 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;<span class="comment">//非阻塞加读锁</span></span><br><span class="line"><span class="comment">/* 加写锁 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;<span class="comment">//非阻塞加写锁</span></span><br><span class="line"><span class="comment">/* 释放锁 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<p>遵循写锁独占，读锁共享的原则：</p>
<ul>
<li>如果已经给一把锁加上写锁，那么再尝试加读锁或者写锁将会阻塞。</li>
<li>如果一把锁已经加上写锁，再尝试加上读锁或者写锁都将会阻塞，那么原来的写锁释放之后，尝试加上写锁的优先级更高。</li>
<li>如果一把锁已经加上读锁，那么其他线程或者当前线程尝试加上读锁会成功。</li>
</ul>
<h4 id="函数返回值-21"><a href="#函数返回值-21" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul>
<li>成功返回0。</li>
<li>失败返回非0。</li>
</ul>
<h3 id="使用实例-18"><a href="#使用实例-18" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 定义读写锁 */</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">/* 定义共享资源变量 */</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="comment">/* 读操作 其他线程允许读操作 不允许写操作 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read thread1 %d\n&quot;</span>, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 读操作，其他线程允许读操作，不允许写操作 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read thread2 %d\n&quot;</span>, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 写操作，其它线程都不允许读或写操作 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun3</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write thread1 \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 写操作，其它线程都不允许读或写操作 */</span> </span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun4</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write thread2 \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2, tid3, tid4;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/* 创建测试线程 */</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, fun3, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid4, <span class="literal">NULL</span>, fun4, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待线程结束，回收其资源 */</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid4, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件变量相关的函数"><a href="#条件变量相关的函数" class="headerlink" title="条件变量相关的函数"></a>条件变量相关的函数</h2><p>条件变量是一种同步机制，用于在多个线程之间传递信息，以便协调它们的行为。条件变量通常与锁一起使用，以便在共享资源上等待特定条件的出现。</p>
<p>当一个线程需要等待某个条件成立时，它可以调用条件变量的等待函数（如<code>pthread_cond_wait()</code>），将当前线程阻塞，并将锁释放，以便其他线程能够访问共享资源。当条件成立时，其他线程会通过条件变量的通知函数（如<code>pthread_cond_signal()</code>或<code>pthread_cond_broadcast()</code>）来通知等待的线程，从而唤醒它们并重新获取锁。</p>
<p>条件变量通常与锁一起使用，用于<strong>解决多个线程之间的同步问题</strong>。例如：</p>
<ul>
<li>多个线程需要等待某个事件的发生，例如生产者消费者模型。</li>
<li>多个线程需要协调执行某个任务，例如线程池。</li>
<li>多个线程需要按照某种顺序执行，例如读写锁。</li>
</ul>
<p>使用条件变量的一般<strong>流程</strong>如下：</p>
<p>1、初始化互斥锁和条件变量，例如<code>pthread_mutex_init</code>和<code>pthread_cond_init</code>函数；<br>2、在需要等待条件变量的线程中获取互斥锁，并使用<code>pthread_cond_wait</code>函数等待条件变量的信号；<br>3、在需要发送条件变量信号的线程中获取互斥锁，并使用<code>pthread_cond_signal</code>或<code>pthread_cond_broadcast</code>函数发送信号；<br>4、在线程退出前，使用<code>pthread_mutex_destroy</code>和<code>pthread_cond_destroy</code>函数销毁互斥锁和条件变量。</p>
<p>使用条件变量需要注意以下几点：</p>
<ul>
<li>使用条件变量前，需要先初始化，可以使用<code>pthread_cond_init</code>。</li>
<li>不再使用时，应使用<code>pthread_cond_destroy</code>销毁条件变量。</li>
<li>虽然<code>pthread_cond_wait</code>在等待时会释放互斥锁，但在被唤醒并从<code>pthread_cond_wait</code>返回时，它会再次获得该锁。</li>
<li>发送条件变量信号时需要获取互斥锁，并在发送信号之后释放互斥锁，以便等待线程能够获取互斥锁并检查条件。</li>
<li>由于存在所谓的”虚假唤醒”（<em>spurious wakeup</em>），线程在被唤醒后应该再次检查条件是否真的满足，这也是为什么通常在while循环中检查条件。</li>
<li>在使用条件变量时需要确保共享变量的一致性，避免出现竞态条件。</li>
</ul>
<h3 id="函数原型-28"><a href="#函数原型-28" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//初始化一个条件变量。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">/*参数1: cond条件变量</span></span><br><span class="line"><span class="comment">  参数2: attr条件变量属性，通常为默认值，传 NULL 即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//也可以使用静态初始化的方法，初始化条件变量:</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁一个条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞等待一个条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1:cond条件变量</span></span><br><span class="line"><span class="comment">参数2:mutex锁变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数作用:</span></span><br><span class="line"><span class="comment">1.阻塞等待条件变量cond满足</span></span><br><span class="line"><span class="comment">2.释放已掌握的互斥锁(解锁互斥量)相当于pthread_mutex_unlock(&amp;mutex);</span></span><br><span class="line"><span class="comment">1、2两步为一个原子操作.</span></span><br><span class="line"><span class="comment">3.当被唤醒后,pthread_cond_wait函数返回时,解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>该函数使调用线程在指定的条件变量<code>cond</code>上等待。为了等待条件变量，线程必须先获取与条件变量相关联的互斥锁<code>mutex</code>。当线程调用<code>pthread_cond_wait</code>后，它会自动释放这个<code>mutex</code>，并将自己置于条件变量的等待队列中。当条件变量被<code>signal</code>或广播时，线程被唤醒并重新尝试获取<code>mutex</code>。一旦成功获取，<code>pthread_cond_wait</code>返回，并且线程可以继续执行。</p>
<p><strong>注意事项</strong>：</p>
<ul>
<li>在调用<code>pthread_cond_wait</code>之前，线程必须持有互斥锁<code>mutex</code>。</li>
<li>当<code>pthread_cond_wait</code>返回时，线程将重新获得互斥锁，因此需要在返回后释放互斥锁。</li>
<li>由于存在“伪唤醒”，即使没有明确的<code>pthread_cond_signal</code>或<code>pthread_cond_broadcast</code>调用，<code>pthread_cond_wait</code>也可能返回（这种行为可能是由于多种原因引起的，包括操作系统的干扰、系统中断或其他未明确指定的原因）。因此，通常建议在循环中检查等待的条件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限时等待一个条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">  cond:条件变量</span></span><br><span class="line"><span class="comment">  mutex:锁变量</span></span><br><span class="line"><span class="comment">  abstime:绝对时间</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒至少一个阻塞在条件变量上的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">//该函数唤醒在指定条件变量cond上等待的一个线程.如果有多个线程在等待,选择哪个线程被唤醒是不确定的.</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li>调用<code>pthread_cond_signal</code>并不意味着与之相关的互斥锁<code>mutex</code>会被自动释放。信号仅仅表示等待条件的线程可以被唤醒。</li>
<li>如果没有线程在条件变量上等待，调用<code>pthread_cond_signal</code>不会有任何副作用。也就是说，没有“积累”的效应；如果之后有线程开始等待，它不会因为之前的<code>pthread_cond_signal</code>调用而被立即唤醒。</li>
</ul>
<p><code>pthread_cond_signal</code>的<strong>核心目的</strong>：从等待条件的线程队列中选择一个线程并唤醒它，使其可以再次运行。如果没有线程正在等待，那么<code>pthread_cond_signal</code>基本上不做任何事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒全部阻塞在条件变量上的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">//这与pthread_cond_signal不同,后者只唤醒一个等待该条件的线程.</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>在调用<code>pthread_cond_broadcast</code>（或任何与条件变量相关的函数）之前，通常需要持有与该条件变量相关联的互斥锁。</li>
<li>虽然<code>pthread_cond_broadcast</code>会唤醒所有等待的线程，但这并不意味着所有这些线程都会立即开始执行。哪个线程首先获得执行权取决于<strong>线程调度</strong>和<strong>优先级</strong>等因素。</li>
<li>使用<code>pthread_cond_broadcast</code>而不是<code>pthread_cond_signal</code>可能会导致更高的上下文切换开销，因为它可能唤醒多个线程。因此，只有在确实需要唤醒所有线程的情况下，才应使用它。</li>
</ul>
<h3 id="使用实例-19"><a href="#使用实例-19" class="headerlink" title="使用实例"></a>使用实例</h3><p>生产者消费者条件变量模型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pc</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;PC;</span><br><span class="line">PC *head = <span class="literal">NULL</span>;<span class="comment">//头节点</span></span><br><span class="line">PC *mp = <span class="literal">NULL</span>;  <span class="comment">//一个结点</span></span><br><span class="line"><span class="comment">//静态初始化锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">productor</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//生产一个结点</span></span><br><span class="line">        mp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PC));</span><br><span class="line">        mp-&gt;num = rand() % <span class="number">400</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---productor---%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        <span class="comment">//上菜到链表</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//唤醒消费者</span></span><br><span class="line">        pthread_cond_signal(&amp;has_product);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等待被唤醒</span></span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始消费</span></span><br><span class="line">        mp = head;</span><br><span class="line">        head = mp-&gt;next;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---consumer---%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        mp = <span class="literal">NULL</span>;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//创建生产者线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, productor, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建消费者线程</span></span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picyuan-1321960394.cos.ap-beijing.myqcloud.com/image-20231204235852173.png" alt="image-20231204235852173"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//等待被唤醒</span></span><br><span class="line">	pthread_cond_wait(&amp;has_product, &amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为啥要用<code>while</code>，不能用<code>if</code>呢？</p>
<ul>
<li>为了解决多消费者出现的逻辑问题，比如有两个消费者，都阻塞在条件变量上，此时生产者生产了一个货物，<code>pthread_cond_signal(&amp;has_product);</code>会同时唤醒两个条件变量，此时两个消费者共同竞争<code>mutex</code>，其中一个消费者竞争到锁开始消费，另一个消费者会阻塞在<code>mutex</code>上，持有锁的消费者消费完成后释放锁，此时阻塞在<code>mutex</code>上的消费者可能会拿到锁进行消费，但此时公共区可能并没有货物，所以阻塞在<code>mutex</code>上的消费者拿到锁后仍需要判断<code>head != NULL</code>，有货物再消费，没货物继续等待条件变量唤醒。因为，需要用<code>while</code>，不能用<code>if</code>。</li>
</ul>
<h2 id="信号量相关的函数"><a href="#信号量相关的函数" class="headerlink" title="信号量相关的函数"></a>信号量相关的函数</h2><p>信号量相当于进化版的互斥锁，由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p>
<p>信号量用于任务间的同步！简单来理解，信号量是一个被内核维护的整数，这个整数一般是“大于等于零”的，我们对这个信号量的操作一般为：将信号量设置一个值、发布(加上一个信号量)、消耗(减去一个信号量)、等待信号量的值为0。在POSIX下信号量分为命名信号量与未命名信号量。<strong>未命名信号量</strong>，也被称为<strong>基于内存的信号量</strong>，类型为<code>sem_t</code>，创建未命名信号量使用的函数为<code>sem_init()</code>。</p>
<h3 id="函数原型-29"><a href="#函数原型-29" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span><span class="comment">//编译时需要跟上后缀-pthread</span></span></span><br><span class="line"><span class="comment">//初始化一个无名信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">/*函数参数:</span></span><br><span class="line"><span class="comment">	sem: sem_t类型的地址处初始化一个无名信号量(创建信号量的id)</span></span><br><span class="line"><span class="comment">	pshared: 0表示信号量再一个进程的所有线程之间共享;非0(一般取1)表示再进程之间共享.</span></span><br><span class="line"><span class="comment">	value: 指定信号量的值(一般为一个大于等于0的整数)</span></span><br><span class="line"><span class="comment">函数返回值:</span></span><br><span class="line"><span class="comment">	成功: 返回0;</span></span><br><span class="line"><span class="comment">	失败: 返回-1,设置errno以指示错误.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/* 被销毁的信号量是之前使用sem_init()初始化的未命名信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//锁定信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/* 调用此函数成功的话,信号量value将会减1.如果等于0,该函数会阻塞调用进程,直到信号量的值大于0为止;信号量值大于0时该信号量值被减1并且函数返回. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试对信号量加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/* 和sem_wait函数类似,但是调用这个函数失败的话不阻塞而是返回错误error. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//限时尝试锁定信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"><span class="comment">/*函数参数:</span></span><br><span class="line"><span class="comment">	sem: 信号量</span></span><br><span class="line"><span class="comment">	abs_timeout: 采用的是绝对时间.</span></span><br><span class="line"><span class="comment">调用此函数成功的话信号量value将会减一.</span></span><br><span class="line"><span class="comment">如果调用前信号量的值为0,那么本函数将会阻塞一定的时间,一定的时间过后还是不能锁定信号量,那么此函数调用失败并且设置errno为ETIMEDOUT.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给信号量解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/* 调用此函数成功后信号量value将会加一. */</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者信号量模型"><a href="#生产者消费者信号量模型" class="headerlink" title="生产者消费者信号量模型"></a>生产者消费者信号量模型</h3><p>使用信号量完成线程间同步，模拟生产者，消费者问题：</p>
<ul>
<li>如果队列中有数据，生产者不能生产，只能阻塞。</li>
<li>如果队列中没有数据，消费者不能消费，只能等待数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5               </span></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM];                                     <span class="comment">//全局数组实现环形队列</span></span><br><span class="line"><span class="type">sem_t</span> blank_number, product_number;                 <span class="comment">//空格子信号量, 产品信号量</span></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;blank_number);                    <span class="comment">//生产者将空格子数--,为0则阻塞等待</span></span><br><span class="line">        <span class="built_in">queue</span>[i] = rand() % <span class="number">1000</span> + <span class="number">1</span>;               <span class="comment">//生产一个产品</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---Produce---%d\n&quot;</span>, <span class="built_in">queue</span>[i]);        </span><br><span class="line">        sem_post(&amp;product_number);                  <span class="comment">//将产品数++</span></span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;                            <span class="comment">//借助下标实现环形</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;product_number);                  <span class="comment">//消费者将产品数--,为0则阻塞等待</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---Consume---%d\n&quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="built_in">queue</span>[i] = <span class="number">0</span>;                               <span class="comment">//消费一个产品 </span></span><br><span class="line">        sem_post(&amp;blank_number);                    <span class="comment">//消费掉以后,将空格子数++</span></span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line">    sem_init(&amp;blank_number, <span class="number">0</span>, NUM);                <span class="comment">//初始化空格子信号量为5</span></span><br><span class="line">	sem_init(&amp;product_number, <span class="number">0</span>, <span class="number">0</span>);                <span class="comment">//产品数为0</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//创建生产者和消费者线程</span></span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//等待线程结束</span></span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>fcntl函数功能是针对<strong>文件描述符</strong>提供控制，根据不同的<code>cmd</code>对文件描述符可以执行的操作也非常多，用的最多的是文件记录锁，也就是<code>F_SETLK</code>命令，此命令搭配<code>flock</code>结构体，对文件进行加解锁操作，例如执行加锁操作，如果不解锁，本进程或者其他进程再次使用<code>F_SETLK</code>命令访问同一文件则会告知目前此文件已经上锁，加锁进程退出（正常、异常）后会自行解锁，使用此特性可以实现避免程序多次运行、锁定文件防止其他进行访问等操作。</p>
<p>当使用fcntl函数设置文件锁（<em>record lock</em>）后就<strong>只能有一个进程</strong>打开文件。</p>
<p>复制一个现有的描述符（<code>cmd = F_DUPFD</code>）。<br>获得&#x2F;设置文件描述符标记（<code>cmd = F_GETFD/F_SETFD</code>）。<br>获得&#x2F;设置文件状态标记（<code>cmd = F_GETFL/F_SETFL</code>）。<br>获得&#x2F;设置异步I&#x2F;O所有权（<code>cmd = F_GETOWN/F_SETOWN</code>）。<br>获得&#x2F;设置记录锁（<code>cmd = F_GETLK , F_SETLK/F_SETLKW</code>）。</p>
<h3 id="函数原型-30"><a href="#函数原型-30" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br></pre></td></tr></table></figure>

<p>参数fd是被参数cmd操作的描述符。针对cmd的值，fcntl能够接受第三个参数。</p>
<h3 id="函数参数-21"><a href="#函数参数-21" class="headerlink" title="函数参数"></a>函数参数</h3><p><code>fd</code>：文件描述符。</p>
<p><code>cmd</code>：操作命令。</p>
<table>
<thead>
<tr>
<th align="left">cmd</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>F_DUPFD</code></td>
<td>复制文件描述符，复制的是第一个参数<code>fd</code>。执行成功返回新复制的文件描述符。</td>
</tr>
<tr>
<td align="left"><code>F_GETFD</code></td>
<td>获得<code>fd</code>的<code>close-on-exec</code>标志。若标志未设置，则文件经过exec函数之后仍保持打开状态。</td>
</tr>
<tr>
<td align="left"><code>F_SETFD</code></td>
<td>设置<code>close-on-exec</code>标志，该标志以参数<code>arg</code>的<code>FD_CLOEXEC</code>位决定。</td>
</tr>
<tr>
<td align="left"><code>F_GETFL</code></td>
<td>取得文件描述词状态标志，此标志为<code>open()</code>的参数<code>flags</code>。</td>
</tr>
<tr>
<td align="left"><code>F_SETFL</code></td>
<td>设置文件描述词状态标志，参数<code>arg</code>为新标志，但只允许<code>O_APPEND</code>、<code>O_NONBLOCK</code>和<code>O_ASYBC</code>位的改变，其他位的改变将不受影响。</td>
</tr>
<tr>
<td align="left"><code>F_GETLK</code></td>
<td>根据<code>lock</code>描述，取得文件锁定的状态。</td>
</tr>
<tr>
<td align="left"><code>F_SETLK</code></td>
<td>设置<code>lock</code>描述的文件锁状态。此时<code>flock</code>结构的<code>l_type</code>值必须是<code>F_RDLCK</code>、<code>F_WRLCK</code>或<code>F_UNLCK</code>。执行成功返回0；否则无法建立锁定，返回-1，错误码为<code>EACCES</code>或<code>EAGAIN</code>。</td>
</tr>
<tr>
<td align="left"><code>F_SETLKW</code></td>
<td><code>F_SETLK</code>的阻塞版本（命令名中的W表示等待wait）。若存在其他锁，则调用进程睡眠；若捕捉到信号则睡眠中断；若在阻塞的过程中被信号中断，会立即返回-1，错误码为<code>EINTR</code>。</td>
</tr>
<tr>
<td align="left"><code>F_GETOWN</code></td>
<td>检索将收到<code>SIGIO</code>和<code>SIGURG</code>信号的进程号或进程组号。</td>
</tr>
<tr>
<td align="left"><code>F_SETOWN</code></td>
<td>设置进程号或进程组号。</td>
</tr>
</tbody></table>
<p><code>Lock</code>：为结构体<code>flock</code>，设置记录锁的具体状态。</p>
<p><code>lock</code>的结构体<code>flock</code>的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flcok</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> l_type;   <span class="comment">//锁定的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下的三个参数用于分段对文件加锁,若对整个文件加锁,则:l_whence = SEEK_SET,l_start = 0,l_len = 0 */</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> l_whence; <span class="comment">//决定l_start位置</span></span><br><span class="line">    <span class="type">off_t</span> l_start;      <span class="comment">//锁定区域的开头位置 </span></span><br><span class="line">    <span class="type">off_t</span> l_len;        <span class="comment">//锁定区域的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> l_pid;        <span class="comment">//锁定动作的进程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">zy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/blogs/2d14aaf0.html">http://example.com/blogs/2d14aaf0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">Linux常用函数</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blogs/6fbd99c.html" title="操作系统高级教程思考题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">操作系统高级教程思考题</div></div></a></div><div class="next-post pull-right"><a href="/blogs/b9528813.html" title="Linux系统命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Linux系统命令</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">Linux常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#close%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">close函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.1.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">open函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">第一个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">第二个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">第三个参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">实例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B3"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">实例3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">write函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">1.3.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">read函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-3"><span class="toc-number">1.4.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number">1.4.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#perror%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">perror函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-4"><span class="toc-number">1.5.2.</span> <span class="toc-text">函数参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lseek%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">lseek函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-5"><span class="toc-number">1.6.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-5"><span class="toc-number">1.6.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-4"><span class="toc-number">1.6.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">1.6.4.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-1"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-1"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">实例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getenv-%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">getenv()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">fork函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-5"><span class="toc-number">1.8.1.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">1.8.2.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">getpid函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getppid%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">getppid函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E6%97%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">exec族函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execl%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.1.</span> <span class="toc-text">execl函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execlp%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.2.</span> <span class="toc-text">execlp函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.12.</span> <span class="toc-text">孤儿进程与僵尸进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.12.1.</span> <span class="toc-text">僵尸进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">僵尸进程的危害</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.12.2.</span> <span class="toc-text">孤儿进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.13.</span> <span class="toc-text">SIGCHLD信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.</span> <span class="toc-text">wait函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-6"><span class="toc-number">1.14.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-6"><span class="toc-number">1.14.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-6"><span class="toc-number">1.14.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%AE%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.4.</span> <span class="toc-text">退出信息相关宏函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-4"><span class="toc-number">1.14.5.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.15.</span> <span class="toc-text">waitpid函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-7"><span class="toc-number">1.15.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-7"><span class="toc-number">1.15.2.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pid%E5%8F%82%E6%95%B0"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">pid参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#status%E5%8F%82%E6%95%B0"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">status参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#options%E5%8F%82%E6%95%B0"><span class="toc-number">1.15.2.3.</span> <span class="toc-text">options参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-7"><span class="toc-number">1.15.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-5"><span class="toc-number">1.15.4.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-2"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-2"><span class="toc-number">1.15.4.2.</span> <span class="toc-text">实例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipe%E5%87%BD%E6%95%B0-%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.16.</span> <span class="toc-text">pipe函数(无名管道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.16.1.</span> <span class="toc-text">管道的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%89%B9%E8%B4%A8"><span class="toc-number">1.16.2.</span> <span class="toc-text">管道特质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.16.3.</span> <span class="toc-text">管道的局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-8"><span class="toc-number">1.16.4.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-8"><span class="toc-number">1.16.5.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-8"><span class="toc-number">1.16.6.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-6"><span class="toc-number">1.16.7.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%90%91%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%BC%A0%E8%BE%BE%E6%B6%88%E6%81%AF"><span class="toc-number">1.16.7.1.</span> <span class="toc-text">子进程向父进程传达消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ulimit-%E2%80%93a-%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%A4%A7%E5%B0%8F%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">1.16.7.1.1.</span> <span class="toc-text">使用ulimit –a 命令可以查看管道缓冲大小命令：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mkfifo%E5%87%BD%E6%95%B0-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.17.</span> <span class="toc-text">mkfifo函数(有名管道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-9"><span class="toc-number">1.17.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-9"><span class="toc-number">1.17.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-9"><span class="toc-number">1.17.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-7"><span class="toc-number">1.17.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.</span> <span class="toc-text">mmap函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-10"><span class="toc-number">1.18.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-10"><span class="toc-number">1.18.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-10"><span class="toc-number">1.18.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.4.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-8"><span class="toc-number">1.18.5.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-3"><span class="toc-number">1.18.5.1.</span> <span class="toc-text">实例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-3"><span class="toc-number">1.18.5.2.</span> <span class="toc-text">实例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B3-1"><span class="toc-number">1.18.5.3.</span> <span class="toc-text">实例3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kill%E5%87%BD%E6%95%B0"><span class="toc-number">1.19.</span> <span class="toc-text">kill函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-11"><span class="toc-number">1.19.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-11"><span class="toc-number">1.19.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-11"><span class="toc-number">1.19.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-9"><span class="toc-number">1.19.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raise%E5%87%BD%E6%95%B0"><span class="toc-number">1.20.</span> <span class="toc-text">raise函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-12"><span class="toc-number">1.20.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-12"><span class="toc-number">1.20.2.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-10"><span class="toc-number">1.20.3.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alarm%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.</span> <span class="toc-text">alarm函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-13"><span class="toc-number">1.21.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-12"><span class="toc-number">1.21.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-13"><span class="toc-number">1.21.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-11"><span class="toc-number">1.21.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setitimer%E5%87%BD%E6%95%B0"><span class="toc-number">1.22.</span> <span class="toc-text">setitimer函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-14"><span class="toc-number">1.22.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-13"><span class="toc-number">1.22.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-14"><span class="toc-number">1.22.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Ealarm-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.22.4.</span> <span class="toc-text">与alarm()的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.23.</span> <span class="toc-text">信号集相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.24.</span> <span class="toc-text">信号处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#signal%E5%87%BD%E6%95%B0"><span class="toc-number">1.24.1.</span> <span class="toc-text">signal函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-15"><span class="toc-number">1.24.1.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-14"><span class="toc-number">1.24.1.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-15"><span class="toc-number">1.24.1.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sigaction%E5%87%BD%E6%95%B0"><span class="toc-number">1.24.2.</span> <span class="toc-text">sigaction函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-16"><span class="toc-number">1.24.2.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-15"><span class="toc-number">1.24.2.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-16"><span class="toc-number">1.24.2.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-12"><span class="toc-number">1.24.2.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setsid%E5%87%BD%E6%95%B0"><span class="toc-number">1.25.</span> <span class="toc-text">setsid函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-17"><span class="toc-number">1.25.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.25.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.26.</span> <span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.26.1.</span> <span class="toc-text">守护进程概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.26.2.</span> <span class="toc-text">创建守护进程的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.26.3.</span> <span class="toc-text">创建一个守护进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="toc-number">1.27.</span> <span class="toc-text">线程相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.27.1.</span> <span class="toc-text">流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-create%E5%87%BD%E6%95%B0"><span class="toc-number">1.28.</span> <span class="toc-text">pthread_create函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-18"><span class="toc-number">1.28.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-16"><span class="toc-number">1.28.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-17"><span class="toc-number">1.28.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-13"><span class="toc-number">1.28.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-exit%E5%87%BD%E6%95%B0"><span class="toc-number">1.29.</span> <span class="toc-text">pthread_exit函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-19"><span class="toc-number">1.29.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-17"><span class="toc-number">1.29.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.29.3.</span> <span class="toc-text">无返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-14"><span class="toc-number">1.29.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-join%E5%87%BD%E6%95%B0"><span class="toc-number">1.30.</span> <span class="toc-text">pthread_join函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-20"><span class="toc-number">1.30.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-18"><span class="toc-number">1.30.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-18"><span class="toc-number">1.30.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-15"><span class="toc-number">1.30.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-cancel%E5%87%BD%E6%95%B0"><span class="toc-number">1.31.</span> <span class="toc-text">pthread_cancel函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-21"><span class="toc-number">1.31.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.31.2.</span> <span class="toc-text">取消状态以及类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E7%82%B9"><span class="toc-number">1.31.3.</span> <span class="toc-text">取消点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-16"><span class="toc-number">1.31.4.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-detach%E5%87%BD%E6%95%B0"><span class="toc-number">1.32.</span> <span class="toc-text">pthread_detach函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-22"><span class="toc-number">1.32.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-17"><span class="toc-number">1.32.2.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.33.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%94%81pthread-mutex-init"><span class="toc-number">1.34.</span> <span class="toc-text">初始化锁pthread_mutex_init</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-23"><span class="toc-number">1.34.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-19"><span class="toc-number">1.34.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-19"><span class="toc-number">1.34.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E9%94%81pthread-mutex-lock%E5%92%8C%E8%A7%A3%E9%94%81pthread-mutex-unlock"><span class="toc-number">1.35.</span> <span class="toc-text">加锁pthread_mutex_lock和解锁pthread_mutex_unlock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-24"><span class="toc-number">1.35.1.</span> <span class="toc-text">函数原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E9%94%81pthread-mutex-destroy"><span class="toc-number">1.36.</span> <span class="toc-text">销毁锁pthread_mutex_destroy()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-25"><span class="toc-number">1.36.1.</span> <span class="toc-text">函数原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.37.</span> <span class="toc-text">读写锁及相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">1.37.1.</span> <span class="toc-text">读写锁创建和销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-26"><span class="toc-number">1.37.1.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-20"><span class="toc-number">1.37.1.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-20"><span class="toc-number">1.37.1.3.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81"><span class="toc-number">1.37.2.</span> <span class="toc-text">读写锁加锁解锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-27"><span class="toc-number">1.37.2.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-21"><span class="toc-number">1.37.2.2.</span> <span class="toc-text">函数返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-18"><span class="toc-number">1.37.3.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.38.</span> <span class="toc-text">条件变量相关的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-28"><span class="toc-number">1.38.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-19"><span class="toc-number">1.38.2.</span> <span class="toc-text">使用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.39.</span> <span class="toc-text">信号量相关的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-29"><span class="toc-number">1.39.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.39.2.</span> <span class="toc-text">生产者消费者信号量模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">1.40.</span> <span class="toc-text">fcntl函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-30"><span class="toc-number">1.40.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-21"><span class="toc-number">1.40.2.</span> <span class="toc-text">函数参数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/6fbd99c.html" title="操作系统高级教程思考题">操作系统高级教程思考题</a><time datetime="2023-12-14T14:46:27.000Z" title="Created 2023-12-14 22:46:27">2023-12-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2d14aaf0.html" title="Linux常用函数">Linux常用函数</a><time datetime="2023-11-30T05:58:58.000Z" title="Created 2023-11-30 13:58:58">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/b9528813.html" title="Linux系统命令">Linux系统命令</a><time datetime="2023-11-29T00:27:51.000Z" title="Created 2023-11-29 08:27:51">2023-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/66f88466.html" title="Cpp内存管理">Cpp内存管理</a><time datetime="2023-11-25T06:52:29.000Z" title="Created 2023-11-25 14:52:29">2023-11-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/81b624c3.html" title="Cpp面向对象高级编程">Cpp面向对象高级编程</a><time datetime="2023-11-25T06:30:53.000Z" title="Created 2023-11-25 14:30:53">2023-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By zy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>